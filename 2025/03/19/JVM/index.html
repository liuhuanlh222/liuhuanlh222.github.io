<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>JVM | Hexo</title><meta name="author" content="John Doe"><meta name="copyright" content="John Doe"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="概念定义：Java Virtual Machine - java程序运行环境（java二进制字节码的运行环境） 好处：  一次编写，到处运行 自动内存管理，垃圾回收功能 数组下标越界检查 多态  JVM JRE JDK三者关系：  内存结构程序计数器Program Counter Register程序计数器（寄存器） 作用 记住下一条jvm指令的执行地址，解释器读取二进制字节码转换为机器码 特点">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM">
<meta property="og:url" content="http://example.com/2025/03/19/JVM/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="概念定义：Java Virtual Machine - java程序运行环境（java二进制字节码的运行环境） 好处：  一次编写，到处运行 自动内存管理，垃圾回收功能 数组下标越界检查 多态  JVM JRE JDK三者关系：  内存结构程序计数器Program Counter Register程序计数器（寄存器） 作用 记住下一条jvm指令的执行地址，解释器读取二进制字节码转换为机器码 特点">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2025-03-19T08:33:04.000Z">
<meta property="article:modified_time" content="2025-04-18T03:53:36.461Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2025/03/19/JVM/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Error',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JVM',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-04-18 11:53:36'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">12</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><hr class="custom-hr"/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Hexo"><span class="site-name">Hexo</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">JVM</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2025-03-19T08:33:04.000Z" title="Created 2025-03-19 16:33:04">2025-03-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-04-18T03:53:36.461Z" title="Updated 2025-04-18 11:53:36">2025-04-18</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="JVM"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>定义：Java Virtual Machine - java程序运行环境（java二进制字节码的运行环境）</p>
<p>好处：</p>
<ul>
<li>一次编写，到处运行</li>
<li>自动内存管理，垃圾回收功能</li>
<li>数组下标越界检查</li>
<li>多态</li>
</ul>
<p>JVM JRE JDK三者关系：</p>
<p><img src="/../images/JVM/1.png" alt="三者关系"></p>
<h1 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h1><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>Program Counter Register程序计数器（寄存器）</p>
<p><strong>作用</strong></p>
<p>记住下一条jvm指令的执行地址，解释器读取二进制字节码转换为机器码</p>
<p><strong>特点</strong></p>
<ul>
<li>线程私有的，属于单个线程</li>
<li>不会存在内存溢出</li>
</ul>
<h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><p>栈：线程运行需要的内存空间</p>
<p>栈帧：每个方法运行时需要的内存（参数、局部变量、返回地址）</p>
<p>Java Virtual Machine Stacks（Java虚拟机栈）</p>
<ul>
<li>每个线程运行时所需要的内存，称为虚拟机栈</li>
<li>每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存</li>
<li>每个线程只能有一个活动栈帧，对应着当前正在执行的哪个方法</li>
</ul>
<ol>
<li>垃圾回收是否涉及栈内存？</li>
</ol>
<p>不涉及</p>
<ol start="2">
<li>栈内存分配越大越好吗？</li>
</ol>
<p>不是，物理地址大小一定，当栈内存越大会导致单个线程内存变大，从而导致线程数目变少，影响并发执行效率</p>
<ol start="3">
<li>方法内的局部变量是否是线程安全？</li>
</ol>
<ul>
<li>如果方法内局部变量没有逃离方法的作用范围，它是线程安全的</li>
<li>如果是局部变量引用了对象，并逃离方法的作用范围，需要考虑线程安全</li>
</ul>
<p><strong>栈内存溢出</strong></p>
<ul>
<li><p>栈帧过多导致栈内存溢出</p>
</li>
<li><p>栈帧过大导致栈内存溢出</p>
</li>
</ul>
<p>运行报错：java.lang.StackOverflowError栈内存溢出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1_2</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            method1();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">        method1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行报错，原因是出现类似于循环依赖问题（打印部门，部门里有员工，员工里有部门），解决方法，加上@JsonIgnore注解在Emp员工类上的dept属性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1_19</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> JsonProcessingException &#123;</span><br><span class="line">        <span class="type">Dept</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dept</span>();</span><br><span class="line">        d.setName(<span class="string">&quot;Market&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Emp</span> <span class="variable">e1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Emp</span>();</span><br><span class="line">        e1.setName(<span class="string">&quot;zhang&quot;</span>);</span><br><span class="line">        e1.setDept(d);</span><br><span class="line"></span><br><span class="line">        <span class="type">Emp</span> <span class="variable">e2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Emp</span>();</span><br><span class="line">        e2.setName(<span class="string">&quot;li&quot;</span>);</span><br><span class="line">        e2.setDept(d);</span><br><span class="line"></span><br><span class="line">        d.setEmps(Arrays.asList(e1, e2));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// &#123; name: &#x27;Market&#x27;, emps: [&#123; name:&#x27;zhang&#x27;, dept:&#123; name:&#x27;&#x27;, emps: [ &#123;&#125;]&#125; &#125;,] &#125;</span></span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        System.out.println(mapper.writeValueAsString(d));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Emp</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="keyword">private</span> Dept dept;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Dept <span class="title function_">getDept</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dept;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDept</span><span class="params">(Dept dept)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.dept = dept;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dept</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Emp&gt; emps;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Emp&gt; <span class="title function_">getEmps</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> emps;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setEmps</span><span class="params">(List&lt;Emp&gt; emps)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.emps = emps;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>线程运行诊断</strong></p>
<p>案例一：cpu占用过多</p>
<p>定位：</p>
<ul>
<li><p>用top定位哪个进程对cpu的占用过高</p>
</li>
<li><pre><code class="shell">#用ps命令进一步定位是哪个线程引起的cpu占用过高
ps H -eo pid,tid,%cpu | grep 进程id
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```shell</span><br><span class="line">  jstack 进程id</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>可以根据线程id找到有问题的线程，进一步定位到问题代码的源码行号</p>
</li>
</ul>
<p>案例二：程序运行很长时间没有结果</p>
<p>也可以利用jstack 进程id去排查问题</p>
<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>Native Method Stacks（本地方法栈）</p>
<p>由c&#x2F;c++实现的本地方法，java可以通过这些方法与底层操作系统进行交互。本地方法栈就是为本地方法的调用提供内存空间</p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>Heap（堆）</p>
<ul>
<li>通过new关键字，创建对象都会使用堆内存</li>
</ul>
<p>特点</p>
<ul>
<li>它是线程共享的，堆中对象都需要考虑线程安全的问题</li>
<li>有垃圾回收机制</li>
</ul>
<p><strong>堆内存溢出</strong></p>
<p>运行报错：java.lang.OutOfMemoryError: Java heap space（堆内存溢出）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1_5</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                list.add(a); <span class="comment">// hello, hellohello, hellohellohellohello ...</span></span><br><span class="line">                a = a + a;  <span class="comment">// hellohellohellohello</span></span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>堆内存诊断</strong></p>
<ol>
<li>jps工具（查看当前系统中有哪些java进程）</li>
<li>jmap工具（查看堆内存占用情况）</li>
</ol>
<ul>
<li><pre><code class="shell">jmap -heap 进程id
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3. jconsole工具（图形界面的，多功能的监测工具，可以连续监测）</span><br><span class="line"></span><br><span class="line">案例：垃圾回收后，内存占用仍然很高</span><br><span class="line"></span><br><span class="line">使用jvisualvm工具进行分析</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public class Demo1_13 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        List&lt;Student&gt; students = new ArrayList&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; 200; i++) &#123;</span><br><span class="line">            students.add(new Student());</span><br><span class="line">            //Student student = new Student();</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(1000000000L);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Student &#123;</span><br><span class="line">    private byte[] big = new byte[1024*1024];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p><strong>定义</strong></p>
<p>方法区是所有线程共享的内存，在java8以前是放在JVM内存中的，由永久代实现，受JVM内存大小参数的限制，在java8中移除了永久代的内容，方法区由元空间(Meta Space)实现，并直接放到了本地内存中，不受JVM参数的限制（当然，如果物理内存被占满了，方法区也会报OOM），并且将原来放在方法区的字符串常量池和静态变量都转移到了Java堆中</p>
<p><strong>组成</strong></p>
<p><strong>类元信息：</strong></p>
<ul>
<li>类元信息在类编译期间放入方法区，里面放置了类的基本信息，包括类的版本、字段、方法、接口以及常量池表（Constant Pool Table）</li>
<li>常量池表（Constant Pool Table）存储了类在编译期间生成的字面量、符号引用(什么是字面量？什么是符号引用？)，这些信息在类加载完后会被解析到运行时常量池中</li>
</ul>
<p> <strong>运行时常量池：</strong></p>
<ul>
<li>运行时常量池主要存放在类加载后被解析的字面量与符号引用，但不止这些</li>
<li>运行时常量池具备动态性，可以添加数据，比较多的使用就是String类的intern()方法</li>
</ul>
<p><strong>方法区内存溢出</strong></p>
<ul>
<li>1.8以前会导致永久代内存溢出（java.lang.OutOfMemoryError:PermGen space）</li>
<li>1.8以后会导致元空间内存溢出（java.lang.OutOfMemoryError:Metaspace）</li>
</ul>
<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><ul>
<li>常量池：就是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息</li>
<li>运行时常量池，常量池是*.class文件中的，当该类被加载，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址</li>
</ul>
<h3 id="StringTable"><a href="#StringTable" class="headerlink" title="StringTable"></a>StringTable</h3><p>面试题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s1 + s2;</span><br><span class="line"><span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s6</span> <span class="operator">=</span> s4.intern();</span><br><span class="line"></span><br><span class="line"><span class="comment">//问</span></span><br><span class="line">System.out.println(s3 == s4);</span><br><span class="line">System.out.println(s3 == s5);</span><br><span class="line">System.out.println(s3 == s6);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">x2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;c&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;d&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">x1</span> <span class="operator">=</span> <span class="string">&quot;cd&quot;</span>;</span><br><span class="line">x2.intern();</span><br><span class="line"></span><br><span class="line"><span class="comment">//问，如果调换了【最后两行代码】的位置呢，如果是jdk1.6呢</span></span><br><span class="line">System.out.println(x1 == x2);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StringTable [ &quot;a&quot;, &quot;b&quot; ,&quot;ab&quot; ]  hashtable 结构，不能扩容</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1_22</span> &#123;</span><br><span class="line">    <span class="comment">// 常量池中的信息，都会被加载到运行时常量池中， 这时 a b ab 都是常量池中的符号，还没有变为 java 字符串对象</span></span><br><span class="line">    <span class="comment">// ldc #2 会把 a 符号变为 &quot;a&quot; 字符串对象</span></span><br><span class="line">    <span class="comment">// ldc #3 会把 b 符号变为 &quot;b&quot; 字符串对象</span></span><br><span class="line">    <span class="comment">// ldc #4 会把 ab 符号变为 &quot;ab&quot; 字符串对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>; <span class="comment">// 懒惰的</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s1 + s2; <span class="comment">// new StringBuilder().append(&quot;a&quot;).append(&quot;b&quot;).toString()  new String(&quot;ab&quot;)</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span>;  <span class="comment">// javac 在编译期间的优化，结果已经在编译期确定为ab</span></span><br><span class="line"></span><br><span class="line">        System.out.println(s3 == s4);</span><br><span class="line">        System.out.println(s3 == s5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一个为false，第二个为true</p>
<p>s4为新生成的一个String对象，s5引用的是s3所指向对象的值</p>
<p>使用&#x3D;&#x3D;进行比较，比较的是指向对象的地址，所以第一个为false，第二个为true</p>
<p>而如果使用equals进行比较的话，两个都为true（原因是String对equals方法进行了重写，比较的是所指向对象的值）</p>
<p>而如果没有对equals方法进行重写的话比较的还是指向对象的内存地址（equals不能用于基本数据类型）</p>
<p>&#x3D;&#x3D;用于基本数据类型比较的是值，而用于引用数据类型比较的是两个对象的内存地址</p>
<h3 id="StringTable特性"><a href="#StringTable特性" class="headerlink" title="StringTable特性"></a>StringTable特性</h3><ul>
<li>常量池中的字符串仅是符号，第一次用到时才变对象</li>
<li>利用串池的机制，来避免重复创建字符串对象</li>
<li>字符串变量拼接的原理是StringBuilder（1.8）</li>
<li>字符串常量拼接的原理是编译器优化</li>
<li>可以使用intern方法，主动将串池中还没有的字符串对象放入串池<ul>
<li>1.8将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有则放入串池，会把串池中的对象返回</li>
<li>1.6将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有会把此对象复制一份，放入串池，会把串池中的对象返回</li>
</ul>
</li>
</ul>
<h4 id="1-8"><a href="#1-8" class="headerlink" title="1.8"></a>1.8</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1_23</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  [&quot;ab&quot;, &quot;a&quot;, &quot;b&quot;]</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">x</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="comment">//堆  new String(&quot;a&quot;)   new String(&quot;b&quot;) new String(&quot;ab&quot;)</span></span><br><span class="line">        <span class="comment">//将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有则放入串池，会把串池中的对象返回</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s.intern(); </span><br><span class="line"></span><br><span class="line">        System.out.println( s2 == x);</span><br><span class="line">        System.out.println( s == x );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会输出true，false</p>
<p>因为执行s.intern时此时串池中已经有了”ab”，所以不会放入，而是将串池中的”ab”返回给s2；这时s还是新创建的”ab”对象</p>
<p>s2的内存地址与x相同，而s的内存地址和x不相同</p>
<p>而如果是下面代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1_23</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  [&quot;a&quot;, &quot;b&quot;]</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="comment">//堆  new String(&quot;a&quot;)   new String(&quot;b&quot;) new String(&quot;ab&quot;)</span></span><br><span class="line">        <span class="comment">//将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有则放入串池，会把串池中的对象返回</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s.intern(); </span><br><span class="line"></span><br><span class="line">        System.out.println( s2 == <span class="string">&quot;ab&quot;</span>);</span><br><span class="line">        System.out.println( s == <span class="string">&quot;ab&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为true，true</p>
<p>因为原来串池中没有”ab”，这时候执行s.intern会将”ab”放入串池，这时候s与s2指向的都为串池中的”ab”内存地址</p>
<h4 id="1-6"><a href="#1-6" class="headerlink" title="1.6"></a>1.6</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1_23</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  [&quot;a&quot;, &quot;b&quot;]</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="comment">//堆  new String(&quot;a&quot;)   new String(&quot;b&quot;) new String(&quot;ab&quot;)</span></span><br><span class="line">        <span class="comment">//将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有会把此对象复制一份，放入串池，会把串池中的对象返回</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s.intern(); </span><br><span class="line"></span><br><span class="line">        System.out.println( s2 == <span class="string">&quot;ab&quot;</span>);</span><br><span class="line">        System.out.println( s == <span class="string">&quot;ab&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会输出true，false</p>
<p>因为1.6中在执行s.intern时如果串池没有则会将对象复制一份然后放入串池，将串池的对象返回。</p>
<p>执行s.intern，将s对象复制放入串池，这时s2指向的串池中的”ab”，而s还是新创建的”ab”对象，内存地址不同</p>
<p><strong>面试题</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1_21</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span>; <span class="comment">// ab</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s1 + s2;   <span class="comment">// new String(&quot;ab&quot;)</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s6</span> <span class="operator">=</span> s4.intern();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 问</span></span><br><span class="line">        System.out.println(s3 == s4);</span><br><span class="line">        System.out.println(s3 == s5);</span><br><span class="line">        System.out.println(s3 == s6);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">x2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;c&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;d&quot;</span>); <span class="comment">// new String(&quot;cd&quot;)</span></span><br><span class="line">        x2.intern();</span><br><span class="line">        <span class="type">String</span> <span class="variable">x1</span> <span class="operator">=</span> <span class="string">&quot;cd&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        System.out.println(x1 == x2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为false true true true</p>
<p>如果为1.6，则为false true true false</p>
<h3 id="StringTable位置"><a href="#StringTable位置" class="headerlink" title="StringTable位置"></a>StringTable位置</h3><h4 id="1-8-1"><a href="#1-8-1" class="headerlink" title="1.8"></a>1.8</h4><p>配置参数-Xmx10m -XX:-UseGCOverheadLimit</p>
<p>运行时报错：java.lang.OutOfMemoryError: Java heap space（堆内存溢出）</p>
<p>可以看出在1.8中StringTable在堆内存中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1_6</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">260000</span>; j++) &#123;</span><br><span class="line">                list.add(String.valueOf(j).intern());</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-6-1"><a href="#1-6-1" class="headerlink" title="1.6"></a>1.6</h4><p>配置参数-XX:MaxPermSize&#x3D;10m</p>
<p>运行时报错：java.lang.OutOfMemoryError:PermGen space（永久代内存溢出）</p>
<p>可以看出在1.6中StringTable在永久代内存中</p>
<h3 id="StringTable垃圾回收"><a href="#StringTable垃圾回收" class="headerlink" title="StringTable垃圾回收"></a>StringTable垃圾回收</h3><p>许多大规模的Java应用的瓶颈在于内存，测试表明，在这些类型的应用里面，Java堆中存活的数据集合差不多25%是String对象。更进一步，这里面差不多一半string对象是重复的，重复的意思是说： <code>stringl.equals(string2)= true</code>。堆上存在重复的String对象必然是一种内存的浪费。这个项目将在G1垃圾收集器中实现自动持续对重复的string对象进行去重，这样就能避免浪费内存。</p>
<p>注意这里说的重复，指的是在堆中的数据，而不是常量池中的，因为常量池中的本身就不会重复</p>
<h3 id="StringTable性能调优"><a href="#StringTable性能调优" class="headerlink" title="StringTable性能调优"></a>StringTable性能调优</h3><p>StringTable是靠我们的HashTable来实现的。即当我们的空间足够大的时候，我们的数据就会比较分散，查询的效率也会因此降低，反之，当我们的空间比较小的时候，我们的数据就会比较集中，查询的效率也会因此提高。<strong>当然了，StringTable的空间大小并不是越小越好，太小了，一直进行垃圾回收，导致经常要删除老数据，添加新的数据等问题也很难受。要是那些个老数据刚删掉没多久就要用到了呢</strong></p>
<p>如果程序涉及到的字符串足够多的情况下，那么可以适当调大StringTable的桶的大小，优化性能</p>
<p>当我们的系统数据会出现重复字符串的情况下，我们可以让我们对应的字符串对象入池，来减少内存的占用</p>
<h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><p>Direct Memory</p>
<ul>
<li>常见于NIO操作时，用于数据缓冲区</li>
<li>分配回收成本较高，但读写性能好</li>
<li>不受JVM内存回收管理</li>
</ul>
<p>传统IO读取，先读到系统缓冲区，在读到Java缓冲区（造成不必要的资源复制）</p>
<p><img src="/../images/JVM/2.png" alt="传统IO"></p>
<p>加入直接内存，java可以直接访问直接内存区域，省去了中间的系统内存缓冲区向java缓存区文件的复制操作，读写速度得到提升 </p>
<p><img src="/../images/JVM/3.png" alt="直接内存"></p>
<h3 id="直接内存溢出"><a href="#直接内存溢出" class="headerlink" title="直接内存溢出"></a>直接内存溢出</h3><p>运行以下代码报错：java.lang.OutOfMemoryError: Direct buffer memory</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1_10</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">_100Mb</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;ByteBuffer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocateDirect(_100Mb);</span><br><span class="line">                list.add(byteBuffer);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接内存对象如果不清空没办法被jvm垃圾回收，所以释放它需要其它函数</p>
<h3 id="分配和回收原理"><a href="#分配和回收原理" class="headerlink" title="分配和回收原理"></a>分配和回收原理</h3><ul>
<li><p>使用了Unsafe对象完成直接内存的分配回收，并且利用回收需要主动调用freeMemory方法</p>
</li>
<li><p>ByteBuffer的实现类内存，使用了Cleaner（虚引用）来监测ByteBuffer对象，一旦ByteBuffer对象被垃圾回收，那么就会由ReferenceHandler线程通过Cleaner的clean方法调用freeMemory来释放直接内存</p>
</li>
</ul>
<p><strong>禁用显示回收对直接内存的影响</strong></p>
<p>代码中的<strong>System.gc是显示垃圾回收</strong>，是一次Full GC 比较<strong>耗时，影响程序执行</strong>；可以使用命令<strong>禁用显示回收，</strong>但是会造成ByteBuffer对象存活，<strong>直接内存无法释放，造成长时间得不到释放的问题。</strong></p>
<p>解决方法：直接使用<strong>Unsafe调用FreeMemory手动释放</strong> UNSAFE.freeMemory(address);</p>
<h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><h2 id="如何判断对象可以回收"><a href="#如何判断对象可以回收" class="headerlink" title="如何判断对象可以回收"></a>如何判断对象可以回收</h2><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a><strong>引用计数法</strong></h3><p>只要一个对象被其他变量所引用，就让该对象的计数+1，如果引用了两次，计数就+2，如果某一个变量不再引用，计数-1，当该对象引用计数为0时，表明该对象未被引用，就可以当作垃圾回收</p>
<p>存在弊端：</p>
<p><img src="/../images/JVM/4.png" alt="弊端"></p>
<p>A对象引用B对象，B对象的引用计数为1，B对象反过来也引用A对象，A对象的引用计数也为1，造成<strong>循环依赖</strong>，两者一直相互引用，内存无法得到释放，从而导致<strong>内存泄漏</strong></p>
<h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>Java虚拟机中的垃圾回收器采用可达性分析来探索所有存活的对象</p>
<ul>
<li>首先要确定一系列根对象：肯定不能当成垃圾被回收的对象（GC Root对象）</li>
<li>在垃圾回收之前，要对堆内存中的所有对象进行一遍扫描，看哪些对象被根对象直接或间接引用，这些对象不能被回收，反之没有被根对象直接或间接引用，就可以作为垃圾，将来被回收（扫描堆中的对象，看是否能够沿着GC Root对象为起点的引用链找到该对象，找不到，表示可以回收）</li>
</ul>
<p>哪些对象可以作为GC Root？</p>
<p><img src="/../images/JVM/5.png" alt="弊端"></p>
<p>上图分为四个类：</p>
<ul>
<li>系统类：由启动类加载器加载的类，核心的类，在运行期间肯定会用到的类（Object，HashMap）</li>
<li>本地方法栈：Java虚拟机在执行方法时，必须调用操作系统方法，操作系统方法所引用的Java方法</li>
<li>活动线程：运行线程的栈帧中所引用的对象</li>
<li>正在加锁的对象：synchronized关键字对一个对象加了锁，被加锁的对象不能被回收</li>
</ul>
<h3 id="四种引用"><a href="#四种引用" class="headerlink" title="四种引用"></a>四种引用</h3><p>强引用 &gt; 软引用 &gt; 弱引用 &gt; 虚引用</p>
<p><img src="/../images/JVM/6.png" alt="四种引用"></p>
<ol>
<li>强引用：Java中默认的就是强引用，new了一个Object对象，并将其赋值给obj，这个obj就是new Object()的强引用</li>
</ol>
<p>无论任何情况下，只要强引用关系还存在，垃圾回收器永远不会回收被引用的对象</p>
<ol start="2">
<li>软引用：软引用是用于描述一些有用但非必须的引用</li>
</ol>
<ul>
<li><p>仅有软引用引用该对象时，只有在内存不足的情况下，并且没有其他强引用被引用的对象时才会被回收，内存够是不会被回收的</p>
</li>
<li><p>当软引用所引用对象被回收时，软引用会进入引用队列，对软引用自身所占内存进行释放（配合引用队列释放软引用自身）</p>
</li>
</ul>
<ol start="3">
<li>弱引用：也是用来描述些非必须对象，但是强度比软引用更弱一些</li>
</ol>
<ul>
<li>弱引用引用的对象且没有被其他强引用被引用，只要垃圾回收执行，就会被回收，不管是否内存不足</li>
<li>弱引用的回收也可以配合引用队列来释放弱引用自身</li>
</ul>
<p><img src="/../images/JVM/7.png" alt="软弱引用"></p>
<ol start="4">
<li>虚引用：最弱的一种引用关系</li>
</ol>
<ul>
<li>必须配合引用队列使用，主要配合ByteBuffer使用，被引用对象回收时，会将虚引用入队，由Reference Handler线程调用虚引用相关方法释放直接内存</li>
</ul>
<p><img src="/../images/JVM/8.png" alt="虚引用"></p>
<ol start="5">
<li>终结器引用</li>
</ol>
<ul>
<li>无需手动编码，但其内部配合引用队列使用，在垃圾回收时，终结器引用入队（被引用对象暂时没有被回收），再由Finalizer线程通过终结器引用找到被引用对象并调用它的finalize方法，第二次GC时才能回收被引用对象</li>
</ul>
<p><img src="/../images/JVM/9.png" alt="终结器引用"></p>
<h4 id="软引用应用"><a href="#软引用应用" class="headerlink" title="软引用应用"></a>软引用应用</h4><p>设置堆内存最大值为20m，打印GC详细信息</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xmx20m -XX:+PrintGCDetails -verbose:gc</span><br></pre></td></tr></table></figure>

<p>运行会造成堆内存溢出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        List&lt;<span class="type">byte</span>[]&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">byte</span>[_4MB]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>运行，由GC信息可知，在第五次添加的时候，内存已经不够，在一次完全的垃圾回收后，内存空间仍然不足，又触发了一次新的内存回收，将软引用的内存回收</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">soft</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// list --&gt; SoftReference --&gt; byte[]</span></span><br><span class="line">    List&lt;SoftReference&lt;<span class="type">byte</span>[]&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        SoftReference&lt;<span class="type">byte</span>[]&gt; ref = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">byte</span>[_4MB]);</span><br><span class="line">        System.out.println(ref.get());</span><br><span class="line">        list.add(ref);</span><br><span class="line">        System.out.println(list.size());</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;循环结束：&quot;</span> + list.size());</span><br><span class="line">    <span class="keyword">for</span> (SoftReference&lt;<span class="type">byte</span>[]&gt; ref : list) &#123;</span><br><span class="line">        System.out.println(ref.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../images/JVM/10.png" alt="软引用回收"></p>
<p><strong>软引用配合引用队列，将软引用对象清理掉</strong>（注意：这个软引用对象和上面的软引用内存不一样，软引用对象是对应的软引用本身，而软引用内存是指指向的对象）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo2_4</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_4MB</span> <span class="operator">=</span> <span class="number">4</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;SoftReference&lt;<span class="type">byte</span>[]&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 引用队列</span></span><br><span class="line">        ReferenceQueue&lt;<span class="type">byte</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 关联了引用队列， 当软引用所关联的 byte[]被回收时，软引用自己会加入到 queue 中去</span></span><br><span class="line">            SoftReference&lt;<span class="type">byte</span>[]&gt; ref = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">byte</span>[_4MB], queue);</span><br><span class="line">            System.out.println(ref.get());</span><br><span class="line">            list.add(ref);</span><br><span class="line">            System.out.println(list.size());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从队列中获取无用的 软引用对象，并移除</span></span><br><span class="line">        Reference&lt;? <span class="keyword">extends</span> <span class="title class_">byte</span>[]&gt; poll = queue.poll();</span><br><span class="line">        <span class="keyword">while</span> (poll != <span class="literal">null</span>) &#123;</span><br><span class="line">            list.remove(poll);</span><br><span class="line">            poll = queue.poll();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;===========================&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (SoftReference&lt;<span class="type">byte</span>[]&gt; reference : list) &#123;</span><br><span class="line">            System.out.println(reference.get());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../images/JVM/11.png" alt="软引用回收"></p>
<h4 id="弱引用应用"><a href="#弱引用应用" class="headerlink" title="弱引用应用"></a>弱引用应用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo2_5</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_4MB</span> <span class="operator">=</span> <span class="number">4</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//  list --&gt; WeakReference --&gt; byte[]</span></span><br><span class="line">        List&lt;WeakReference&lt;<span class="type">byte</span>[]&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            WeakReference&lt;<span class="type">byte</span>[]&gt; ref = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">byte</span>[_4MB]);</span><br><span class="line">            list.add(ref);</span><br><span class="line">            <span class="keyword">for</span> (WeakReference&lt;<span class="type">byte</span>[]&gt; w : list) &#123;</span><br><span class="line">                System.out.print(w.get()+<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;循环结束：&quot;</span> + list.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现，在第五次添加的时候，内存不够了，回收掉了第四个，才能添加第五个，。。第10次是因为弱引用本身也占用内存，放不下时，进行了Full GC，将弱引用内存全部清空</p>
<p><img src="/../images/JVM/12.png" alt="弱引用"></p>
<h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><h3 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h3><p><img src="/../images/JVM/13.png" alt="标记清除"></p>
<p>标记清除算法分为“标记”和“清除”两个阶段，首先通过可达性分析算法，标记出所有需要回收的对象，然后统一回收所以被标记的对象</p>
<ul>
<li>优点：不需要做额外的处理，清除速度快</li>
<li>缺点：会造成内存碎片，后续可能发生大对象找不到可利用空间的问题</li>
</ul>
<h3 id="标记整理"><a href="#标记整理" class="headerlink" title="标记整理"></a>标记整理</h3><p>标记整理算法的“标记”过程与标记清除算法的“标记”过程一致，但标记之后不会直接清理。而是将所有存活对象都移动到内存的一端。移动结束后直接清理掉剩余部分</p>
<p><img src="/../images/JVM/14.png" alt="标记整理"></p>
<p>优点：没有内存碎片</p>
<p>缺点：效率低、速度慢</p>
<h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><p>将内存分成两块，每次申请内存时都使用其中的一块，当内存不够时，将这一块中所有存活的复制到另一块上。然后再把原来块的内存全部清空</p>
<p><img src="/../images/JVM/15.png" alt="复制"></p>
<p><img src="/../images/JVM/16.png" alt="复制"></p>
<p>优点：没有内存碎片</p>
<p>缺点：需要占用双倍内存空间</p>
<h2 id="分代回收"><a href="#分代回收" class="headerlink" title="分代回收"></a>分代回收</h2><p>长时间使用的对象放在老年代中，用完可以丢弃的对象放在新生代中。老年代的垃圾回收很久发生一次，新生代的垃圾回收发生的比较频繁</p>
<ul>
<li>新的对象默认分配再伊甸园区域，不断添加新的对象，当伊甸园内存不足时，触发minor gc垃圾回收</li>
<li>minor gc会引发stop the world，暂停其它用户的线程，等垃圾回收结束后，用户线程才恢复运行</li>
</ul>
<p><img src="/../images/JVM/17.png" alt="新生代"></p>
<ul>
<li>通过可达性分析沿着GC Root引用链，看是否可以作为垃圾，采用标记复制算法，将伊甸园和幸村区from存活的对象复制到幸村区To，存活的对象寿命加一，回收掉伊甸园和from标记为垃圾的对象，并且交换幸村区from和to</li>
</ul>
<p><img src="/../images/JVM/18.png" alt="回收"></p>
<p><img src="/../images/JVM/19.png" alt="回收"></p>
<ul>
<li>当新的对象再次将伊甸园填满时，触发第二次垃圾回收，找到伊甸园中存活的对象放入幸存区To中，寿命+1，将幸存区from中存活的对象放入幸村区To中，寿命也+1，不要的对象回收掉，交换幸村区from和to</li>
</ul>
<p><img src="/../images/JVM/20.png" alt="再回收"></p>
<p><img src="/../images/JVM/23.png" alt="再回收"></p>
<ul>
<li>当寿命超过了阈值（默认是15），说明对象经常被使用，将垃圾晋升到老年代</li>
<li>当老年代空间不足，会先尝试触发minor GC，如果之后空间仍不足，那么促发full gc（整个清理）stop the world时间更长</li>
</ul>
<p><strong>相关JVM参数</strong></p>
<p><img src="/../images/JVM/24.png" alt="JVM参数"></p>
<h3 id="GC案例分析"><a href="#GC案例分析" class="headerlink" title="GC案例分析"></a>GC案例分析</h3><p>设置参数：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc</span><br></pre></td></tr></table></figure>

<p>运行代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo2_1</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_512KB</span> <span class="operator">=</span> <span class="number">512</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_1MB</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_6MB</span> <span class="operator">=</span> <span class="number">6</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_7MB</span> <span class="operator">=</span> <span class="number">7</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_8MB</span> <span class="operator">=</span> <span class="number">8</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../images/JVM/25.png" alt="运行"></p>
<p>执行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo2_1</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_512KB</span> <span class="operator">=</span> <span class="number">512</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_1MB</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_6MB</span> <span class="operator">=</span> <span class="number">6</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_7MB</span> <span class="operator">=</span> <span class="number">7</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_8MB</span> <span class="operator">=</span> <span class="number">8</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        ArrayList&lt;Object&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">byte</span>[_7MB]);</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">byte</span>[_512KB]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../images/JVM/26.png" alt="运行"></p>
<p>执行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo2_1</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_512KB</span> <span class="operator">=</span> <span class="number">512</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_1MB</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_6MB</span> <span class="operator">=</span> <span class="number">6</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_7MB</span> <span class="operator">=</span> <span class="number">7</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_8MB</span> <span class="operator">=</span> <span class="number">8</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        ArrayList&lt;Object&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">byte</span>[_7MB]);</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">byte</span>[_512KB]);</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">byte</span>[_512KB]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../images/JVM/27.png" alt="运行"></p>
<p>执行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo2_1</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_512KB</span> <span class="operator">=</span> <span class="number">512</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_1MB</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_6MB</span> <span class="operator">=</span> <span class="number">6</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_7MB</span> <span class="operator">=</span> <span class="number">7</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_8MB</span> <span class="operator">=</span> <span class="number">8</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        ArrayList&lt;Object&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">byte</span>[_8MB]);</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">byte</span>[_8MB]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../images/JVM/28.png" alt="运行"></p>
<p>运行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo2_1</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_512KB</span> <span class="operator">=</span> <span class="number">512</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_1MB</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_6MB</span> <span class="operator">=</span> <span class="number">6</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_7MB</span> <span class="operator">=</span> <span class="number">7</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_8MB</span> <span class="operator">=</span> <span class="number">8</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            ArrayList&lt;Object&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">byte</span>[_8MB]);</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">byte</span>[_8MB]);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        System.out.println(<span class="string">&quot;sleep...&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个线程的OutOfMemoryError，不会导致Java进程结束</p>
<p><img src="/../images/JVM/29.png" alt="运行"></p>
<h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h2><h3 id="串行"><a href="#串行" class="headerlink" title="串行"></a>串行</h3><p>单线程的收集器，说明它只会使用一个CPU或一条收集线程区完成垃圾收集工作，并且再它进行垃圾收集时，必须暂停其它所有的工作线程，直到它收集结束</p>
<p>优势：简单而又高效（与其它收集器的单线程相比）对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集，自然可以获得最高的单线程收集效率</p>
<p>场景：适合堆内存较小，个人电脑</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UserSerialGC =Serial +SerialOld 指定年轻代和老年代都使用串行收集器</span><br><span class="line">等价于新生代使用Serial GC（复制算法），老年代使用Serial Old GC（标记+整理算法）</span><br></pre></td></tr></table></figure>

<p>用户工作的线程，再安全点停下来</p>
<p><img src="/../images/JVM/30.png" alt="串行"></p>
<h3 id="吞吐量优先"><a href="#吞吐量优先" class="headerlink" title="吞吐量优先"></a>吞吐量优先</h3><p>多线程的收集器，主要让单位时间内，STW（垃圾收集器最大停顿时间）的时间最短（0.2+0.2 &#x3D; 0.4），可以高效利用CPU时间，尽快完成线程的运算任务（垃圾回收时间占比最低，这样就称吞吐量高）</p>
<p>场景：堆内存较大，多核CPU来支持（单核，也是多个线程轮流争抢单核CPU的时间片，效率更低），适合再后台运算而不许需要太多交互的任务。parallel并行执行，指多个垃圾回收器可以并行的运行，占用不同的cpu。但是在此期间，用户线程是被暂停的，只有垃圾回收线程在运行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseParallelGC 手动指定年轻代使用Parallel并行收集器执行内存回收任务(复制算法）</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseParallelOldGC 手动指定老年代使用并行回收收集器(标记+整理算法)</span><br><span class="line">jdk8默认是开启的.上面两个参数,默认开启一个,另一个也会被开启(互相激活)</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseAdaptiveSizePolicy：自适应调整新生代大小(新生代占比和晋升阈值大小)</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:ParallelGCThreads：设置年轻代并行收集器的线程数，</span><br><span class="line">最好与CPU数量相等，以避免过多的线程数影响垃圾收集性能,在默认情况下，CPU数量小于8， ParallelGCThreads的值等于CPU数量，当CPU数量大于8,ParallelGCThreads的值等于3+(5*CPU_COUNT/8)</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:GCTimeRatio：垃圾收集时间占总时间的比例(=1/(N+1))，用于衡量吞吐量的大小</span><br><span class="line">取值范围(0,100),默认99,也就是垃圾回收时间不超过1%，很难达到，一般设置为19，即100分钟只允许5分钟垃圾回收</span><br><span class="line">与-XX:MaxGCPauseMillis参数有一定矛盾性,暂停时间越长,Radio参数就越容易超过设定的比例</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:MaxGCPauseMillis 设置垃圾收集器最大停顿时间(即STW的时间)单位是毫秒(该参数使用需谨慎)</span><br><span class="line">为了尽可能地把停顿时间控制在MaxGCPauseMillis以内,收集器在工作时会调整Java堆大小或者其他一些参数</span><br><span class="line">对于用户来讲,停顿时间越短体验越好,但是在服务器端,我们注重高并发,整体的吞吐量,所以服务器端适合Parallel，进行控制</span><br></pre></td></tr></table></figure>

<p><img src="/../images/JVM/31.png" alt="吞吐量优先"></p>
<h3 id="响应时间优先"><a href="#响应时间优先" class="headerlink" title="响应时间优先"></a>响应时间优先</h3><p>多线程</p>
<p>场景：堆内存较大，多核CPU</p>
<p>尽可能让单词STW的时间最短0.1+0.1+0.1+0.1+0.1 &#x3D; 0.5</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseConcMarkSweepGC(老年代，标记清除算法) ~ -XX:+UseParNewGC ~ SerialOld (新生代，复制算法)</span><br><span class="line">concurrent 并发(垃圾回收器进行垃圾回收时，其他用户线程也可以并发进行，与垃圾回收线程抢占cpu)mark标记，sweep清除()</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:ParallelGCThreads=n 并行的垃圾回收线程数，一般跟cpu数目相等</span><br><span class="line">-XX:ConcGCTreads=threads 并发的垃圾回收线程数目，</span><br><span class="line">一般是ParallelGCThreads的 1/4，即一个cpu做垃圾回收，剩下3个cpu留给人家用户线程。</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:CMSInitiatingOccupancyFraction=percent，开始执行CMS垃圾回收时的内存占比，</span><br><span class="line">早期默认65，即只要老年代内存占用率达到65％的时候就要开始清理，留下35％的空间给新产生的浮动垃圾。</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+CMSScavengeBeforeRemark 在重新标记之前，对新生代做一次垃圾回收</span><br></pre></td></tr></table></figure>

<p><img src="/../images/JVM/32.png" alt="响应时间优先"></p>
<p>CMS回收器发生并行失败时，CMS回收器会退化成SerialOld的单线程的基于标记整理的垃圾回收器</p>
<p><strong>CMS老年代回收过程</strong></p>
<ul>
<li>当老年代空间不足时，所有进程运行到安全点暂停，垃圾回收的线程进行初始化标记，初始化标记比较快，只是标记空间对象。此过程会Stop The World，阻塞其它用户线程</li>
<li>初始标记完成后，达到下一个安全点，其它用户线程也可以继续运行了，此时垃圾回收线程进行并发标记，即可以根其它用户线程并发工作，将其它垃圾标记出来。此过程不会STW，响应时间很短几乎不影响用户线程工作</li>
<li>达到下一个安全点之后，进行重新标记，因为上一个并发标记时，其它用户线程也在并发执行，有可能会产生新对象引用，对垃圾回收线程造成了干扰，需要重新标记。此过程会STW</li>
<li>到下一个安全点之后，其它用户线程恢复，垃圾回收线程开始并发的清理垃圾，恢复运行</li>
</ul>
<p>整个工作阶段只会在初始标记和重新标记的时候STW，其它阶段并发执行，响应时间特别短</p>
<p><strong>CMS垃圾回收器</strong></p>
<ul>
<li>CMS垃圾回收器对cpu的占用率并不高，但是用户工作线程也在运行，垃圾回收线程占用用户线程的工作线程，整个应用程序的吞吐量变小了</li>
<li>CMS在执行最后一步并发清理的时候，由于其它线程还在运行，就会产生新的垃圾，而新的垃圾只有等到下次垃圾回收才能清理。这些垃圾被称为浮动垃圾，所以要预留一些空间来存放浮动垃圾</li>
<li>重新标记阶段，新生代的对象可能会引用老年代的对象，重新标记时需要扫描整个堆，做可达性分析时，只要新生代的引用存在，不管有没有必要，都会通过新生代引用找到老年代，对性能影响有些大。因为新生代对象很多，且很多要作为垃圾被回收。可达性分析又会通过新生代引用去找老年代，但是就算找到了老年代，这些新生代还是要被回收，也就是说没有必要查找老年代。所以需要在重新标记之前，先回收新生代(-XX:+CMSScavengeBeforeRemark参数设置)，就不会存在新生代引用老年代，然后去查找老年代了。新生代的垃圾回收(通过-XX:+UseParNewGC)之后，新生代对象少了，重新标记的压力就轻了。</li>
<li>因为CMS基于标记清除算法，有可能会产生比较多的内存碎片。这样会造成将来给对象分配空间时minorGC后内存空间不足，老年代的空间也不足，会造成并发失败。CMS就会退化成SerialOld串行地垃圾回收，通过标记整理碎片来得到空间。但是会导致垃圾回收的时间变得很长（要整理），给用户造成不好的体验。</li>
</ul>
<h3 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h3><p>2017 JDK9 默认，取代CMS垃圾回收器</p>
<p>使用场景：</p>
<ul>
<li>同时注重吞入量和低延迟，默认的暂停目标是200ms，在用户线程工作的同时，垃圾回收线程也在并发的执行</li>
<li>超大堆内存，会将堆划分为多个大小相等的Region（区域，1248M）</li>
<li>整体上是 标记+整理 算法，两个区域之间是 复制 算法</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseG1GC 显示启动G1</span><br><span class="line">-XX:G1HeapRegionSize=size 设置区域大小</span><br><span class="line">-XX:MaxGCPauseMillis=time 设置暂停目标</span><br></pre></td></tr></table></figure>

<h4 id="垃圾回收阶段"><a href="#垃圾回收阶段" class="headerlink" title="垃圾回收阶段"></a>垃圾回收阶段</h4><p><img src="/../images/JVM/33.png" alt="G1垃圾回收"></p>
<p>新生代垃圾收集：发生时机就是伊甸园满的时候</p>
<p>新生代垃圾收集+并发标记：当老年代内存超过阈值时，在新生代垃圾回收的同时，并发标记</p>
<p>混合收集：不只清理年轻代，还会将老年代的一部分区域进行清理</p>
<h4 id="Young-Collection"><a href="#Young-Collection" class="headerlink" title="Young Collection"></a>Young Collection</h4><p>Young GC主要是对伊甸园进行GC，他在Eden空间耗尽时会被触发。在这种情况下，Eden空间的数据移动到Survivor空间中，如果Survivor空间不够，Eden空间的部分数据会直接晋升到老年代空间。Survivor区的数据移动到新的Survivor区中，也有部分数据晋升到老年代空间中。最终Eden空间的数据为空，GC停止工作，应用线程极速执行</p>
<p><img src="/../images/JVM/34.png" alt="Young Collection"></p>
<h4 id="Young-Collection跨代引用"><a href="#Young-Collection跨代引用" class="headerlink" title="Young Collection跨代引用"></a>Young Collection跨代引用</h4><p>新生代垃圾回收时，先找到GC Root对象，进行可达性分析算法，找到存活对象，存活对象复制到幸村区。</p>
<p>那如何找到所有的根对象呢？根对象有一部分来自于老年代，老年代存活的对象特别多，如果遍历一遍老年代去寻找根对象，那这样扫描下来会耗费大量的时间。G1引进了RSet的概念。它的全称是Remembered Set，作用是跟踪指向某个heap区内的对象引用。</p>
<p>老年代维护采用card table技术，将老年代区域再细分为card（下图右侧橙色区域），每个card大约为512k，如果老年代，如果老年代对象引用了新生代，对应的card标记为dirty card（粉丝区域），在做Gc Root遍历时，不需要找整个老年代，只需要关注dirty card区域，减少扫描范围，提过搜索效率</p>
<p>当堆新生代进行回收时，通过Remembered Set记录找到对应的dirty card，然后在dirty card区域遍历Region的Gc Root</p>
<p><img src="/../images/JVM/37.png" alt="Young Collection跨代引用"></p>
<h4 id="Young-Collection-CM"><a href="#Young-Collection-CM" class="headerlink" title="Young Collection+CM"></a>Young Collection+CM</h4><ul>
<li>当堆空间的内存占用达到阈值（-XX:InitiatingHeapOccupancyPercent，默认45%）就开始老年代的并发标记过程。</li>
<li>初始标记阶段：标记GC Roots直接可达的对象，也就是直接引用关系对象，会发生STW（由于是直接可达的对象的标记，所以暂停时间很短），并且会触发一次Young GC。</li>
<li>根区域的扫描（Root Region Scanning）：G1扫描Survivor区直接可达的老年代区域对象，并标记被引用的对象。这一个过程必须在Young GC之前完成（因为Young GC会操作Survivor区中的对象）。</li>
<li>并发标记（Concurrent Marking）：在整个堆中进行并发标记（与程序线程并发执行），此过程可能会被Young GC打断，在并发标记阶段中，若发现某些region中所有对象都是垃圾，那这个region就会被立即回收，同时并发标记过程中，会计算每个region的对象活性（该region存活对象的比例，G1垃圾回收的时候并不是所有region都会参与回收的，根据回收的价值高低来优先回收价值较高的region）。</li>
<li>再次标记：由于并发标记阶段是收集器的标记线程和程序线程并发执行的，需要进行再次标记，修正上一次的标记结果，可以理解为增量补偿标记。会出现STW（暂停时间较短）。G1采用的是比CMS跟快的初始快照算法：snapshot-at-the-beginning（SATB）。</li>
<li>独占清理：计算各个region的存活对象和GC回收比例，并进行排序（回收价值高低排序），识别可以混合回收的区域。为下阶段做铺垫，会发生STW。需要注意的是这个阶段实际上并不会做垃圾的回收。</li>
<li>并发清理阶段：识别并清理完成空闲的区域。</li>
</ul>
<p><img src="/../images/JVM/35.png" alt="Young Collection+CM"></p>
<h4 id="Remark-SATB"><a href="#Remark-SATB" class="headerlink" title="Remark-SATB"></a>Remark-SATB</h4><p>SATB是GC开始时活着的对象的一个快照。它是通过Root   Tracing得到的，作用是维持并发GC的正确性。对象存在三种状态，白：对象没有被标记到，标记阶段结束后，会被当做垃圾回收掉。灰：对象被标记了，但是它的field还没有被标记或标记完。黑：对象被标记了，且它的所有field也被标记完了</p>
<p><img src="/../images/JVM/38.png" alt="对象三种状态"></p>
<p>SATB利用写屏障，将所有即将被删除的引用关系的旧引用记录下来（加入到队列中），标记为灰色，最后这些旧引用为根Stop The World地重新扫描一遍即可避免漏标问题。</p>
<p><img src="/../images/JVM/39.png" alt="加入队列中"></p>
<p>因此G1 Remark阶段Stop The World与CMS的remark有一个本质的区别，那就是这个暂停只需要扫描所有的队列中对象即可，而CMS的remark需要重新扫描整个根集合，因而CMS remark有可能会非常慢</p>
<h4 id="Mixed-Collection"><a href="#Mixed-Collection" class="headerlink" title="Mixed Collection"></a>Mixed Collection</h4><p>混合式垃圾回收，每次- 收集既可能只收集年轻代分区(年轻代收集)，也可能在收集年轻代的同时，包含部分老年代分区(混合- 收集)，这样即使堆内存很大时，也可以限制收集范围，从而降低停顿。</p>
<p>G1有一个参数：“-XX：InitiatingHeapOccupancyPercent”,默认值是45%，当老年代的大小占据了堆内存的45%的Region时，此时就会触发一个新生代和老年代的混合回收阶段，对E S 0 H进行全面回收。</p>
<p>该阶段一旦触发会导致系统进入STW，同时进行最后一个标记：</p>
<ul>
<li>最终标记阶段：会根据并发标记阶段记录的对象修改，最终标记哪些对象是存活，哪些对象是垃圾</li>
</ul>
<p>此时老年代也是根据标记-复制算法来进行回收的，会将标记存活的对象拷贝到新的Region中作为老年代区域：</p>
<ul>
<li>标记完成后马上开始垃圾的回收。对于一个混合的回收过程，G1从老年代移动存活的对象到空闲区域，这些空闲的区域变成了老年代region。当越来越多的对象晋升到老年代region的时候，为了避免堆内存被耗尽，就会触发混合垃圾收集Mixed GC，该算法并不是一个Old GC也不是Full GC，除了回收整个Young region之外，还会回收一部分Old region，部分的region垃圾回收设计可以对垃圾回收的耗时进行控制。</li>
<li>在并发标记结束之后，老年代中能够完全确认为垃圾的region中的内存分段被回收了，部分为垃圾的region中内存分段也被计算出来了，默认情况下，这些老年代的内存分段会被分为8次回收（可以通过-XX:G1MixedGCCountTarget设置）。</li>
<li>混合回收的回收集包括1&#x2F;8的老年代的内存分段，Eden区内存分段，Survivor内存分段，混合回收的算法和年轻代回收的算法完全一致。</li>
<li>混合回收并不一定要进行8次，有一个阈值设置：-XX:G1HeapWastePercent，默认值10%，代表允许整个堆内存中有10%的内存可以被浪费，意味着如果发现可以回收的垃圾占对内存的比例低于10%，则不进行混合回收，因为GC花费的时间相对于较少的垃圾回收来说得不偿失。</li>
<li>由于老年代的内存分段默认分为8次回收，G1会优先回收垃圾多的内存分段，<strong>垃圾占内存分段比例越高的会优先被回收</strong>。并且有一个阈值决定内存分段是否被回收：-XX:G1MixedGCLiveThresholdPercent，默认为65%，代表垃圾占内存分段比例要达到65%来回被回收，如果垃圾占比太低，意味着存活的对象多，复制算法就会花费更多的时间区复制存活的对象。</li>
<li>必要的情况下（对象分配速度远大于回收速度），Full GC仍然会触发（Full GC的成本较高，单线程，性能差，STW时间长）</li>
<li>堆内存太小、对象分配速度远大于回收速度等原因都可以导致G1在复制存活对象的时候没有空闲的内存分段可用，最终造成Full GC的触发。</li>
</ul>
<p><img src="/../images/JVM/36.png" alt="Mixed Collection"></p>
<h4 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h4><p><strong>SerialGC</strong></p>
<p>新生代内存不足发生的垃圾收集 -minor gc</p>
<p>老年代内存不足发生的垃圾收集 -full gc</p>
<p><strong>ParallelGC</strong></p>
<p>新生代内存不足发生的垃圾收集 -minor gc</p>
<p>老年代内存不足发生的垃圾收集 -full gc</p>
<p><strong>CMS</strong></p>
<p>新生代内存不足发生的垃圾收集 -minor gc</p>
<p>老年代内存不足时，垃圾回收速度低于产生速度时候，并发失败，退化为单线程SerialGC串行执行，为fullGC，否则不是</p>
<p><strong>G1</strong></p>
<p>新生代内存不足发生的垃圾收集 -minor gc</p>
<p>老年代内存不足：超过阈值时先并发标记再混合收集，当回收速度高于新的用于线程产生垃圾的速度，处于并发垃圾收集。当垃圾回收速度低于新产生的垃圾速度，退化为full GC，响应时间较长</p>
<h3 id="G1垃圾回收优化"><a href="#G1垃圾回收优化" class="headerlink" title="G1垃圾回收优化"></a>G1垃圾回收优化</h3><h4 id="JDK-8u20字符串去重"><a href="#JDK-8u20字符串去重" class="headerlink" title="JDK 8u20字符串去重"></a>JDK 8u20字符串去重</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseStringDeduplication 开启字符串去重功能，默认打开</span><br></pre></td></tr></table></figure>

<p><img src="/../images/JVM/40.png" alt="字符串去重"></p>
<p>会将所有新分配的字符串放入一个队列中，当新生代回收时，G1并发检查是否有字符串去重，如果它们值一样，让它们引用同一个char[]。s1和s2引用的是堆中两个不同的对象，只不过那两个对象都指向同一个字符串而已，所以s1!&#x3D;s2</p>
<p>优点：节省大量内存</p>
<p>缺点：略微占用太多了cpu时间，新生代回收时间略微增加</p>
<p><strong>注意：</strong>与String.intern()不一样，String.intern()关注的是字符串对象，而字符串去重关注的是char[]，在JVM内部，使用了不同的字符串表</p>
<h4 id="JDK-8u40并发卸载"><a href="#JDK-8u40并发卸载" class="headerlink" title="JDK 8u40并发卸载"></a>JDK 8u40并发卸载</h4><p>之前jdk版本中，一般是不卸载的，类加载之后，会一直占用内存</p>
<p>在所有对象都经过并发标记后，就能知道哪些类不在使用，当一个类加载器的所有类都不在使用则卸载它所加载的所有类</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+ClassUnloadingWithConcurrentMark 默认启用</span><br></pre></td></tr></table></figure>

<p><strong>卸载条件：</strong></p>
<p>类的实例都被回收掉</p>
<p>类所在的类加载器其中的所有类都不在使用</p>
<h4 id="JDK-8u60回收巨型对象"><a href="#JDK-8u60回收巨型对象" class="headerlink" title="JDK 8u60回收巨型对象"></a>JDK 8u60回收巨型对象</h4><p>当一个对象大于region的一半时，称之为巨型对象</p>
<p>G1一般不会对巨型对象进行拷贝，回收时被优先考虑</p>
<p>G1会跟踪老年代所有incoming引用，这样老年代incoming引用为0的巨型对象就可以在新生代垃圾回收时处理掉</p>
<p><img src="/../images/JVM/41.png" alt="巨型对象"></p>
<h4 id="JDK-9并发标记起始时间的调整"><a href="#JDK-9并发标记起始时间的调整" class="headerlink" title="JDK 9并发标记起始时间的调整"></a>JDK 9并发标记起始时间的调整</h4><p>为了减少Full GC，可以提前让并发标记，混合收集提前开始</p>
<p>JDK9之前需要使用 -XX:InitiatingHeapOccupancyPercent 老年代在整个堆内存的占比的阈值，超过时，并发垃圾回收开始，默认是45%</p>
<p>JDK 9可以动态调整-XX:InitiatingHeapOccupancyPercent 用来设置初始值，在垃圾回收过程中，进行数据采样并动态调整阈值，会添加一个安全的空挡空间，减少Full GC产生几率</p>
<h3 id="垃圾回收调优"><a href="#垃圾回收调优" class="headerlink" title="垃圾回收调优"></a>垃圾回收调优</h3><p>查看虚拟机运行参数（本地虚拟机与GC相关参数）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+PrintFlagsFinal -version | findstr “GC”</span><br></pre></td></tr></table></figure>

<p><img src="/../images/JVM/42.png" alt="相关参数"></p>
<p>掌握相关工具：jmap、jconsole、jstat查看GC相关状态</p>
<p>调优不仅仅从内存GC，还应该考虑线程堆锁的竞争，CPU的占用，以及IO的调用，网络延迟，软硬件的考虑</p>
<h4 id="确认目标"><a href="#确认目标" class="headerlink" title="确认目标"></a>确认目标</h4><p>对于GC调优来说，首先就要清楚调优的目标是什么？要清楚自己的应用程序是做什么的，如果是做科学运算的，就要关注高吞吐量，如果是互联网项目，就要追求低延迟，提高用户体验</p>
<ul>
<li>高吞吐量：ParallelGC</li>
<li>低延迟：CMS（不推荐），G1，ZGC（java12）</li>
</ul>
<p>GC调优从性能的角度看，通常关注三个方面：内存占用，延时和吞吐量</p>
<p>大多数情况下调优会侧重于一个或者两个方面的目标，很少有情况可以兼顾三个不同的角度。也可能需要考虑其它GC相关的场景，例如，OOM也可能与不合理的GC相关参数有关；或者，应用启动速度方面的需求，GC也会是个考虑的方面</p>
<h4 id="最快的GC是不发生GC"><a href="#最快的GC是不发生GC" class="headerlink" title="最快的GC是不发生GC"></a>最快的GC是不发生GC</h4><p>查看Full GC前后的内存占用，考虑下面几个问题</p>
<ul>
<li>数据是不是太多？<ul>
<li>“select * from 大表”会将所有数据从mysql中查出来读入java内存</li>
<li>“select * from 大表 limit n”限制数量</li>
</ul>
</li>
<li>数据表示是否太过臃肿？<ul>
<li>对象图，一次性取出对象相关联不用的数据</li>
<li>对象大小对内存占用，Java中最小的Object占用16字节（Integer 16 int 4）</li>
</ul>
</li>
<li>是否存在内存泄漏？<ul>
<li>static Map map &#x3D; …不断地往静态地map对象中存放对象，会造成内存溢出</li>
<li>长时间存活的对象推荐使用，软&#x2F;弱引用</li>
<li>不推荐Java实现缓存，建议第三方缓存实现redis&#x2F;memorycache</li>
</ul>
</li>
</ul>
<h4 id="新生代调优"><a href="#新生代调优" class="headerlink" title="新生代调优"></a>新生代调优</h4><p><strong>新生代特点：</strong></p>
<ul>
<li>new对象首先在伊甸园中分配，分配速度特别快<ul>
<li>每个线程都会在内存中分配一块私有区域（TLAB），当new一个对象时，首先检查TLAB中有没有可用内存，有的话，优先在TLAB中进行对象分配，可以避免多个线程同时创建对象时对内存占用的干扰</li>
</ul>
</li>
<li>死亡对象的回收代价是零<ul>
<li>新生代发生垃圾回收时，采用复制算法（伊甸园+幸存区from -&gt; 幸存区to），复制完后，伊甸园和幸存区from的内存都被释放掉</li>
</ul>
</li>
<li>大部分对象用过即死</li>
<li>Minor GC 的时间远远低于Full GC</li>
</ul>
<h4 id="新生代内存越大越好吗？"><a href="#新生代内存越大越好吗？" class="headerlink" title="新生代内存越大越好吗？"></a>新生代内存越大越好吗？</h4><p>设置新生代的初始大小和最大大小（以字节为单位）。GC是在该区域比在其它区域更频繁地执行。如果年轻一代太小，则会执行触发多次minor GC。如果尺寸太大，仅执行新生代的垃圾收集，可能需要很长时间。建议新生代保持占堆的25%~50%</p>
<p>新生区大小建议：</p>
<ul>
<li>新生代能容纳所有（并发量+（请求+响应））的数据</li>
<li>幸存区大到能保留（当前活跃对象+需要晋升对象）<ul>
<li>晋升阈值配置得当，让长时间存活对象尽快晋升（不然会耗费幸村区的内存，而且不断的重复复制）</li>
</ul>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:MaxTenuringThreshold=threshold 调整最大晋升阈值</span><br><span class="line">-XX:+PrintTenuringDistribution 打印晋升区的存活对象</span><br></pre></td></tr></table></figure>

<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Desired survivor size <span class="number">48286924</span> bytes, new threshold <span class="number">10</span> (max <span class="number">10</span>)</span><br><span class="line">- age <span class="number">1</span>: <span class="number">28992024</span> bytes, <span class="number">28992024</span> total</span><br><span class="line">- age <span class="number">2</span>: <span class="number">1366864</span> bytes, <span class="number">30358888</span> total</span><br><span class="line">- age <span class="number">3</span>: <span class="number">1425912</span> bytes, <span class="number">31784800</span> total</span><br></pre></td></tr></table></figure>

<h4 id="老年代调优"><a href="#老年代调优" class="headerlink" title="老年代调优"></a>老年代调优</h4><p>以CMS为例</p>
<ul>
<li>CMS的老年代内存越大越好</li>
<li>先尝试不做老年代调优，如果没有Full GC证明不是因为老年代内存不足引起的垃圾回收，即使发生了Full GC，也先尝试调优新生代</li>
<li>观察发生了Full GC时老年代内存占用，将老年代内存预设调大1&#x2F;4 ~ 1&#x2F;3</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:CMSInitiatingOccupancyFraction=percent</span><br></pre></td></tr></table></figure>

<h4 id="GC调优案例"><a href="#GC调优案例" class="headerlink" title="GC调优案例"></a>GC调优案例</h4><p><strong>案例1：Full GC和Minor GC频繁</strong></p>
<p>业务高峰来了，创建大量对象将新生代空间塞满，幸存区的晋升阈值就会降低，导致很多生存周期很短的对象，也会被晋升到老年代，进一步触发老年代Full GC的发生</p>
<p>先试着增大新生代内存大小，内存充裕了，垃圾回收就不会那么频繁，同时增大了幸存区和幸存区阈值，让生命周期较短的对象，尽可能地留在新生代，进一步减少触发老年代地GC</p>
<p><strong>案例2：请求高峰期发生Full GC，单次暂停时间特别长（CMS）</strong></p>
<p>查看GC日志，判断CMS的哪一阶段耗费时间较长（一般重新标记耗时较长）</p>
<p>所以需要在重新标记之前，先回收新生代（-XX:+CMSScavengeBeforeRemark参数设置），新生代的对象少了，重新标记的压力就轻了</p>
<p><img src="/../images/JVM/43.png" alt="重新标记"></p>
<p><strong>案例3：老年代充裕情况下，发生Full GC（CMS jdk1.7）</strong></p>
<p>1.8采用元空间作为方法区的实现</p>
<p>1.7采用永久代作为方法区的实现</p>
<h1 id="类加载与字节码技术"><a href="#类加载与字节码技术" class="headerlink" title="类加载与字节码技术"></a>类加载与字节码技术</h1><p><img src="/../images/JVM/44.png" alt="总结构"></p>
<h2 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h2><p>通过javac类名.java编译java文件后，会生成一个.class文件</p>
<p>以下是字节码文件：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000000</span> ca fe ba be <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">34</span> <span class="number">00</span> <span class="number">23</span> <span class="number">0</span>a <span class="number">00</span> <span class="number">06</span> <span class="number">00</span> <span class="number">15</span> <span class="number">09</span> </span><br><span class="line"><span class="number">0000020</span> <span class="number">00</span> <span class="number">16</span> <span class="number">00</span> <span class="number">17</span> <span class="number">08</span> <span class="number">00</span> <span class="number">18</span> <span class="number">0</span>a <span class="number">00</span> <span class="number">19</span> <span class="number">00</span> <span class="number">1</span>a <span class="number">07</span> <span class="number">00</span> <span class="number">1</span>b <span class="number">07</span> </span><br><span class="line"><span class="number">0000040</span> <span class="number">00</span> <span class="number">1</span>c <span class="number">01</span> <span class="number">00</span> <span class="number">06</span> <span class="number">3</span>c <span class="number">69</span> <span class="number">6</span>e <span class="number">69</span> <span class="number">74</span> <span class="number">3</span>e <span class="number">01</span> <span class="number">00</span> <span class="number">03</span> <span class="number">28</span> <span class="number">29</span> </span><br><span class="line"><span class="number">0000060</span> <span class="number">56</span> <span class="number">01</span> <span class="number">00</span> <span class="number">04</span> <span class="number">43</span> <span class="number">6</span>f <span class="number">64</span> <span class="number">65</span> <span class="number">01</span> <span class="number">00</span> <span class="number">0</span>f <span class="number">4</span>c <span class="number">69</span> <span class="number">6</span>e <span class="number">65</span> <span class="number">4</span>e </span><br><span class="line"><span class="number">0000100</span> <span class="number">75</span> <span class="number">6</span>d <span class="number">62</span> <span class="number">65</span> <span class="number">72</span> <span class="number">54</span> <span class="number">61</span> <span class="number">62</span> <span class="number">6</span>c <span class="number">65</span> <span class="number">01</span> <span class="number">00</span> <span class="number">12</span> <span class="number">4</span>c <span class="number">6</span>f <span class="number">63</span> </span><br><span class="line"><span class="number">0000120</span> <span class="number">61</span> <span class="number">6</span>c <span class="number">56</span> <span class="number">61</span> <span class="number">72</span> <span class="number">69</span> <span class="number">61</span> <span class="number">62</span> <span class="number">6</span>c <span class="number">65</span> <span class="number">54</span> <span class="number">61</span> <span class="number">62</span> <span class="number">6</span>c <span class="number">65</span> <span class="number">01</span> </span><br><span class="line"><span class="number">0000140</span> <span class="number">00</span> <span class="number">04</span> <span class="number">74</span> <span class="number">68</span> <span class="number">69</span> <span class="number">73</span> <span class="number">01</span> <span class="number">00</span> <span class="number">1</span>d <span class="number">4</span>c <span class="number">63</span> <span class="number">6</span>e <span class="number">2</span>f <span class="number">69</span> <span class="number">74</span> <span class="number">63</span> </span><br><span class="line"><span class="number">0000160</span> <span class="number">61</span> <span class="number">73</span> <span class="number">74</span> <span class="number">2</span>f <span class="number">6</span>a <span class="number">76</span> <span class="number">6</span>d <span class="number">2</span>f <span class="number">74</span> <span class="number">35</span> <span class="number">2</span>f <span class="number">48</span> <span class="number">65</span> <span class="number">6</span>c <span class="number">6</span>c <span class="number">6</span>f </span><br><span class="line"><span class="number">0000200</span> <span class="number">57</span> <span class="number">6</span>f <span class="number">72</span> <span class="number">6</span>c <span class="number">64</span> <span class="number">3</span>b <span class="number">01</span> <span class="number">00</span> <span class="number">04</span> <span class="number">6</span>d <span class="number">61</span> <span class="number">69</span> <span class="number">6</span>e <span class="number">01</span> <span class="number">00</span> <span class="number">16</span> </span><br><span class="line"><span class="number">0000220</span> <span class="number">28</span> <span class="number">5</span>b <span class="number">4</span>c <span class="number">6</span>a <span class="number">61</span> <span class="number">76</span> <span class="number">61</span> <span class="number">2</span>f <span class="number">6</span>c <span class="number">61</span> <span class="number">6</span>e <span class="number">67</span> <span class="number">2</span>f <span class="number">53</span> <span class="number">74</span> <span class="number">72</span> </span><br><span class="line"><span class="number">0000240</span> <span class="number">69</span> <span class="number">6</span>e <span class="number">67</span> <span class="number">3</span>b <span class="number">29</span> <span class="number">56</span> <span class="number">01</span> <span class="number">00</span> <span class="number">04</span> <span class="number">61</span> <span class="number">72</span> <span class="number">67</span> <span class="number">73</span> <span class="number">01</span> <span class="number">00</span> <span class="number">13</span> </span><br><span class="line"><span class="number">0000260</span> <span class="number">5</span>b <span class="number">4</span>c <span class="number">6</span>a <span class="number">61</span> <span class="number">76</span> <span class="number">61</span> <span class="number">2</span>f <span class="number">6</span>c <span class="number">61</span> <span class="number">6</span>e <span class="number">67</span> <span class="number">2</span>f <span class="number">53</span> <span class="number">74</span> <span class="number">72</span> <span class="number">69</span> </span><br><span class="line"><span class="number">0000300</span> <span class="number">6</span>e <span class="number">67</span> <span class="number">3</span>b <span class="number">01</span> <span class="number">00</span> <span class="number">10</span> <span class="number">4</span>d <span class="number">65</span> <span class="number">74</span> <span class="number">68</span> <span class="number">6</span>f <span class="number">64</span> <span class="number">50</span> <span class="number">61</span> <span class="number">72</span> <span class="number">61</span> </span><br><span class="line"><span class="number">0000320</span> <span class="number">6</span>d <span class="number">65</span> <span class="number">74</span> <span class="number">65</span> <span class="number">72</span> <span class="number">73</span> <span class="number">01</span> <span class="number">00</span> <span class="number">0</span>a <span class="number">53</span> <span class="number">6</span>f <span class="number">75</span> <span class="number">72</span> <span class="number">63</span> <span class="number">65</span> <span class="number">46</span> </span><br><span class="line"><span class="number">0000340</span> <span class="number">69</span> <span class="number">6</span>c <span class="number">65</span> <span class="number">01</span> <span class="number">00</span> <span class="number">0</span>f <span class="number">48</span> <span class="number">65</span> <span class="number">6</span>c <span class="number">6</span>c <span class="number">6</span>f <span class="number">57</span> <span class="number">6</span>f <span class="number">72</span> <span class="number">6</span>c <span class="number">64</span></span><br><span class="line"><span class="number">0000360</span> <span class="number">2</span>e <span class="number">6</span>a <span class="number">61</span> <span class="number">76</span> <span class="number">61</span> <span class="number">0</span>c <span class="number">00</span> <span class="number">07</span> <span class="number">00</span> <span class="number">08</span> <span class="number">07</span> <span class="number">00</span> <span class="number">1</span>d <span class="number">0</span>c <span class="number">00</span> <span class="number">1</span>e </span><br><span class="line"><span class="number">0000400</span> <span class="number">00</span> <span class="number">1</span>f <span class="number">01</span> <span class="number">00</span> <span class="number">0</span>b <span class="number">68</span> <span class="number">65</span> <span class="number">6</span>c <span class="number">6</span>c <span class="number">6</span>f <span class="number">20</span> <span class="number">77</span> <span class="number">6</span>f <span class="number">72</span> <span class="number">6</span>c <span class="number">64</span> </span><br><span class="line"><span class="number">0000420</span> <span class="number">07</span> <span class="number">00</span> <span class="number">20</span> <span class="number">0</span>c <span class="number">00</span> <span class="number">21</span> <span class="number">00</span> <span class="number">22</span> <span class="number">01</span> <span class="number">00</span> <span class="number">1</span>b <span class="number">63</span> <span class="number">6</span>e <span class="number">2</span>f <span class="number">69</span> <span class="number">74</span> </span><br><span class="line"><span class="number">0000440</span> <span class="number">63</span> <span class="number">61</span> <span class="number">73</span> <span class="number">74</span> <span class="number">2</span>f <span class="number">6</span>a <span class="number">76</span> <span class="number">6</span>d <span class="number">2</span>f <span class="number">74</span> <span class="number">35</span> <span class="number">2</span>f <span class="number">48</span> <span class="number">65</span> <span class="number">6</span>c <span class="number">6</span>c </span><br><span class="line"><span class="number">0000460</span> <span class="number">6</span>f <span class="number">57</span> <span class="number">6</span>f <span class="number">72</span> <span class="number">6</span>c <span class="number">64</span> <span class="number">01</span> <span class="number">00</span> <span class="number">10</span> <span class="number">6</span>a <span class="number">61</span> <span class="number">76</span> <span class="number">61</span> <span class="number">2</span>f <span class="number">6</span>c <span class="number">61</span> </span><br><span class="line"><span class="number">0000500</span> <span class="number">6</span>e <span class="number">67</span> <span class="number">2</span>f <span class="number">4</span>f <span class="number">62</span> <span class="number">6</span>a <span class="number">65</span> <span class="number">63</span> <span class="number">74</span> <span class="number">01</span> <span class="number">00</span> <span class="number">10</span> <span class="number">6</span>a <span class="number">61</span> <span class="number">76</span> <span class="number">61</span> </span><br><span class="line"><span class="number">0000520</span> <span class="number">2</span>f <span class="number">6</span>c <span class="number">61</span> <span class="number">6</span>e <span class="number">67</span> <span class="number">2</span>f <span class="number">53</span> <span class="number">79</span> <span class="number">73</span> <span class="number">74</span> <span class="number">65</span> <span class="number">6</span>d <span class="number">01</span> <span class="number">00</span> <span class="number">03</span> <span class="number">6</span>f </span><br><span class="line"><span class="number">0000540</span> <span class="number">75</span> <span class="number">74</span> <span class="number">01</span> <span class="number">00</span> <span class="number">15</span> <span class="number">4</span>c <span class="number">6</span>a <span class="number">61</span> <span class="number">76</span> <span class="number">61</span> <span class="number">2</span>f <span class="number">69</span> <span class="number">6</span>f <span class="number">2</span>f <span class="number">50</span> <span class="number">72</span> </span><br><span class="line"><span class="number">0000560</span> <span class="number">69</span> <span class="number">6</span>e <span class="number">74</span> <span class="number">53</span> <span class="number">74</span> <span class="number">72</span> <span class="number">65</span> <span class="number">61</span> <span class="number">6</span>d <span class="number">3</span>b <span class="number">01</span> <span class="number">00</span> <span class="number">13</span> <span class="number">6</span>a <span class="number">61</span> <span class="number">76</span> </span><br><span class="line"><span class="number">0000600</span> <span class="number">61</span> <span class="number">2</span>f <span class="number">69</span> <span class="number">6</span>f <span class="number">2</span>f <span class="number">50</span> <span class="number">72</span> <span class="number">69</span> <span class="number">6</span>e <span class="number">74</span> <span class="number">53</span> <span class="number">74</span> <span class="number">72</span> <span class="number">65</span> <span class="number">61</span> <span class="number">6</span>d </span><br><span class="line"><span class="number">0000620</span> <span class="number">01</span> <span class="number">00</span> <span class="number">07</span> <span class="number">70</span> <span class="number">72</span> <span class="number">69</span> <span class="number">6</span>e <span class="number">74</span> <span class="number">6</span>c <span class="number">6</span>e <span class="number">01</span> <span class="number">00</span> <span class="number">15</span> <span class="number">28</span> <span class="number">4</span>c <span class="number">6</span>a </span><br><span class="line"><span class="number">0000640</span> <span class="number">61</span> <span class="number">76</span> <span class="number">61</span> <span class="number">2</span>f <span class="number">6</span>c <span class="number">61</span> <span class="number">6</span>e <span class="number">67</span> <span class="number">2</span>f <span class="number">53</span> <span class="number">74</span> <span class="number">72</span> <span class="number">69</span> <span class="number">6</span>e <span class="number">67</span> <span class="number">3</span>b </span><br><span class="line"><span class="number">0000660</span> <span class="number">29</span> <span class="number">56</span> <span class="number">00</span> <span class="number">21</span> <span class="number">00</span> <span class="number">05</span> <span class="number">00</span> <span class="number">06</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">02</span> <span class="number">00</span> <span class="number">01</span> </span><br><span class="line"><span class="number">0000700</span> <span class="number">00</span> <span class="number">07</span> <span class="number">00</span> <span class="number">08</span> <span class="number">00</span> <span class="number">01</span> <span class="number">00</span> <span class="number">09</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">2</span>f <span class="number">00</span> <span class="number">01</span> <span class="number">00</span> <span class="number">01</span> </span><br><span class="line"><span class="number">0000720</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">05</span> <span class="number">2</span>a b7 <span class="number">00</span> <span class="number">01</span> b1 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">02</span> <span class="number">00</span> <span class="number">0</span>a <span class="number">00</span> </span><br><span class="line"><span class="number">0000740</span> <span class="number">00</span> <span class="number">00</span> <span class="number">06</span> <span class="number">00</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">04</span> <span class="number">00</span> <span class="number">0</span>b <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">0</span>c <span class="number">00</span> </span><br><span class="line"><span class="number">0000760</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">05</span> <span class="number">00</span> <span class="number">0</span>c <span class="number">00</span> <span class="number">0</span>d <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">09</span> <span class="number">00</span> <span class="number">0</span>e <span class="number">00</span> </span><br><span class="line"><span class="number">0001000</span> <span class="number">0</span>f <span class="number">00</span> <span class="number">02</span> <span class="number">00</span> <span class="number">09</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">37</span> <span class="number">00</span> <span class="number">02</span> <span class="number">00</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line"><span class="number">0001020</span> <span class="number">09</span> b2 <span class="number">00</span> <span class="number">02</span> <span class="number">12</span> <span class="number">03</span> b6 <span class="number">00</span> <span class="number">04</span> b1 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">02</span> <span class="number">00</span> <span class="number">0</span>a </span><br><span class="line"><span class="number">0001040</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">0</span>a <span class="number">00</span> <span class="number">02</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">06</span> <span class="number">00</span> <span class="number">08</span> <span class="number">00</span> <span class="number">07</span> <span class="number">00</span> <span class="number">0</span>b </span><br><span class="line"><span class="number">0001060</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">0</span>c <span class="number">00</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">09</span> <span class="number">00</span> <span class="number">10</span> <span class="number">00</span> <span class="number">11</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line"><span class="number">0001100</span> <span class="number">00</span> <span class="number">12</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">05</span> <span class="number">01</span> <span class="number">00</span> <span class="number">10</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">01</span> <span class="number">00</span> <span class="number">13</span> <span class="number">00</span> </span><br><span class="line"><span class="number">0001120</span> <span class="number">00</span> <span class="number">00</span> <span class="number">02</span> <span class="number">00</span> <span class="number">14</span></span><br></pre></td></tr></table></figure>

<p>根据jvm规范，类文件结构如下：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">u4 			   magic</span><br><span class="line">u2             minor_version;    </span><br><span class="line">u2             major_version;    </span><br><span class="line">u2             constant_pool_count;    </span><br><span class="line">cp_info        constant_pool[constant_pool_count-<span class="number">1</span>];    </span><br><span class="line">u2             access_flags;    </span><br><span class="line">u2             this_class;    </span><br><span class="line">u2             super_class;   </span><br><span class="line">u2             interfaces_count;    </span><br><span class="line">u2             interfaces[interfaces_count];   </span><br><span class="line">u2             fields_count;    </span><br><span class="line">field_info     fields[fields_count];   </span><br><span class="line">u2             methods_count;    </span><br><span class="line">method_info    methods[methods_count];    </span><br><span class="line">u2             attributes_count;    </span><br><span class="line">attribute_info attributes[attributes_count];</span><br></pre></td></tr></table></figure>

<ol>
<li>魔数</li>
</ol>
<p>u4 magic</p>
<p>对应字节码文件的0~3个字节</p>
<p>0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 09</p>
<p>ca fe ba be：意思是.class文件，不同的东西有不同的魔数，比如.jpg、png图片等</p>
<ol start="2">
<li>版本</li>
</ol>
<p>u2 minor_version</p>
<p>u2 major_version</p>
<p>0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 09</p>
<p>00 00 00 34：34H（16进制） &#x3D; 52（10进制），代表JDK8</p>
<ol start="3">
<li>常量池</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/">传送门</a></p>
<ol start="4">
<li>字节码指令</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5">字节码指令</a></p>
<p><strong>javap工具</strong></p>
<p>java中提供了javap工具来反编译class文件</p>
<h2 id="图解方法执行流程"><a href="#图解方法执行流程" class="headerlink" title="图解方法执行流程"></a>图解方法执行流程</h2><p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo3_1</span> &#123;    </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        </span><br><span class="line">		<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;        </span><br><span class="line">		<span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> Short.MAX_VALUE + <span class="number">1</span>;        </span><br><span class="line">		<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a + b;        </span><br><span class="line">		System.out.println(c);   </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>常量池载入运行时常量池</strong></p>
<p>常量池也属于方法区，只不过是单独提出来了</p>
<p><img src="/../images/JVM/45.png" alt="运行时常量池"></p>
<p><strong>方法字节码载入方法区</strong></p>
<p>（stack &#x3D; 2， locals &#x3D; 4）对应操作数栈有2个空间（每个空间4个字节），局部变量表中有4个槽位</p>
<p><img src="/../images/JVM/46.png" alt="方法字节码"></p>
<p><strong>执行引擎开始执行字节码</strong></p>
<p><strong>bipush 10</strong></p>
<p>将一个byte压入操作数栈（其长度会补齐4个字节），类似的指令还有：</p>
<ul>
<li>sipush将一个short压入操作数栈（其长度会补齐4个字节）</li>
<li>ldc将一个int压入操作数栈</li>
<li>ldc2_w将一个long压入操作数栈（<strong>分两次压入</strong>，因为long是8个字节）</li>
<li>这里小的数字都是和字节码指令存在一起，<strong>超过short范围的数字存入了常量池</strong></li>
</ul>
<p><img src="/../images/JVM/47.png" alt="bipush 10"></p>
<p><strong>istore 1</strong></p>
<p>将操作数栈栈顶元素弹出，放入局部变量表的slot 1中</p>
<p>对应代码中的a &#x3D; 1</p>
<p><img src="/../images/JVM/48.png" alt="istore 1"></p>
<p><strong>ldc #3</strong></p>
<p>读取运行时常量池中的#3，即32768（超过short最大值范围的数字会被放到运行时常量池中），将其加载到操作数栈中</p>
<p>注意Shot.MAX_VALUE是32767，所以32768 &#x3D; Short.MAX_VALUE + 1实际是在编译期间计算好的</p>
<p><img src="/../images/JVM/49.png" alt="ldc #3"></p>
<p><strong>istore 2</strong></p>
<p>将操作数栈中的元素弹出，放到局部变量表的2号位置</p>
<p><img src="/../images/JVM/50.png" alt="istore 2"></p>
<p><strong>iload1 iload2</strong></p>
<p>将局部变量表中1号位置和2号位置的元素放入操作数栈中。因为只能在操作数栈中执行运算操作</p>
<p><img src="/../images/JVM/51.png" alt="iload 1和iload 2"></p>
<p><strong>iadd</strong></p>
<p>将操作数栈中的两个元素弹出栈并相加，结果压入操作数栈中</p>
<p><img src="/../images/JVM/52.png" alt="iadd"></p>
<p><img src="/../images/JVM/53.png" alt="iadd"></p>
<p><strong>istore 3</strong></p>
<p>将操作数栈中的元素弹出，放入局部变量表的3号位置</p>
<p><img src="/../images/JVM/54.png" alt="istore 3"></p>
<p><img src="/../images/JVM/55.png" alt="istore 3"></p>
<p><strong>getstatic #4</strong></p>
<p>在运行池常量池中找到#4，发现是一个对象，在堆内存中找到该对象，并将其引用放入操作数栈中</p>
<p><img src="/../images/JVM/56.png" alt="getstatic #4"></p>
<p><img src="/../images/JVM/57.png" alt="getstatic #4"></p>
<p><strong>iload 3</strong></p>
<p>将局部变量表中3号位置的元素压入栈中</p>
<p><img src="/../images/JVM/58.png" alt="iload 3"></p>
<p><strong>invokevirtual #5</strong></p>
<p>找到常量池#5项，定位到方法区java&#x2F;io&#x2F;PrintStream.println:(I)V方法</p>
<p>生成新的栈帧（分配locals、stack等）</p>
<p>传递参数，执行新栈帧中的字节码</p>
<p><img src="/../images/JVM/59.png" alt="invokevirtual #5"></p>
<p>执行完毕，弹出栈帧，清除main操作数栈内容</p>
<p><img src="/../images/JVM/60.png" alt="执行完毕"></p>
<p><strong>return</strong></p>
<p>完成main方法调用，弹出main栈帧，程序结束</p>
<h2 id="练习-分析i"><a href="#练习-分析i" class="headerlink" title="练习-分析i++"></a>练习-分析i++</h2><p>对应代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.jvm.t3.bytecode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从字节码角度分析a++相关题目</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo3_2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> a++ + ++a a--;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">        System.out.println(b) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析：</p>
<p>注意iinc指令是直接在局部变量slot上进行运算</p>
<p>a++和++a的区别是先执行iload还是先执行iinc</p>
<p>可以跟着下图方法区每个步骤进行分析，过程和上述图解方法执行流程类似，在这里不进行分析</p>
<p><img src="/../images/JVM/61.png" alt="分析执行"></p>
<h2 id="通过字节码指令分析问题"><a href="#通过字节码指令分析问题" class="headerlink" title="通过字节码指令分析问题"></a>通过字节码指令分析问题</h2><p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; <span class="number">10</span>)&#123;</span><br><span class="line">            x = x++;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么最终x的结果为0呢？通过字节码执行分析：</p>
<p>x++可以进行拆分为<strong>iload_x和iinc x,1</strong></p>
<p>对于x &#x3D; x++进行分析：</p>
<ul>
<li>第一步为将x的值放入操作数栈中，此时x为0，操作数栈中也为0</li>
<li>第二步将x的值加一，此时x为1</li>
<li>第三步进行赋值，将操作数栈中的值赋值给x</li>
<li>最终x为0（无论循环几次x最终都为0）</li>
</ul>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p><strong>cinit()V</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code_12_CinitTest</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        i = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        i = <span class="number">30</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(i); <span class="comment">// 30</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器会按从上至下的顺序，收集所有static静态代码块和静态成员赋值的代码，合并为一个特殊的方法cinit()V：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">stack=<span class="number">1</span>, locals=<span class="number">0</span>, args_size=<span class="number">0</span></span><br><span class="line">         <span class="number">0</span>: bipush        <span class="number">10</span></span><br><span class="line">         <span class="number">2</span>: putstatic     #<span class="number">3</span>                  // Field i:I</span><br><span class="line">         <span class="number">5</span>: bipush        <span class="number">20</span></span><br><span class="line">         <span class="number">7</span>: putstatic     #<span class="number">3</span>                  // Field i:I</span><br><span class="line">        <span class="number">10</span>: bipush        <span class="number">30</span></span><br><span class="line">        <span class="number">12</span>: putstatic     #<span class="number">3</span>                  // Field i:I</span><br><span class="line">        <span class="number">15</span>: return</span><br></pre></td></tr></table></figure>

<p><strong>init()V</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main1</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;s1&quot;</span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        b = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        a = <span class="string">&quot;s2&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Main1</span><span class="params">(String a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.a = a;</span><br><span class="line">        <span class="built_in">this</span>.b = b; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Main1</span> <span class="variable">main1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Main1</span>(<span class="string">&quot;s3&quot;</span>, <span class="number">30</span>);</span><br><span class="line">        System.out.println(main1.a);</span><br><span class="line">        System.out.println(main1.b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器会按照从上至下的顺序，收集所有{}代码块和成员变量赋值的代码，形成新的构造方法，但原始构造方法内的代码总是在后</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Code:</span></span><br><span class="line"><span class="function">     <span class="title">stack</span>=2, <span class="title">locals</span>=3, <span class="title">args_size</span>=3</span></span><br><span class="line"><span class="function">        0: <span class="title">aload_0</span></span></span><br><span class="line"><span class="function">        1: <span class="title">invokespecial</span> #1                  // <span class="title">Method</span> <span class="title">java</span>/<span class="title">lang</span>/<span class="title">Object</span>.&quot;&lt;<span class="title">init</span>&gt;&quot;:()<span class="title">V</span></span></span><br><span class="line"><span class="function">        4: <span class="title">aload_0</span></span></span><br><span class="line"><span class="function">        5: <span class="title">ldc</span>           #2                  // <span class="title">String</span> <span class="title">s1</span></span></span><br><span class="line"><span class="function">        7: <span class="title">putfield</span>      #3                  // <span class="title">Field</span> <span class="title">a:Ljava</span>/<span class="title">lang</span>/<span class="title">String</span>;</span></span><br><span class="line"><span class="function">       10: <span class="title">aload_0</span></span></span><br><span class="line"><span class="function">       11: <span class="title">bipush</span>        20</span></span><br><span class="line"><span class="function">       13: <span class="title">putfield</span>      #4                  // <span class="title">Field</span> <span class="title">b:I</span></span></span><br><span class="line"><span class="function">       16: <span class="title">aload_0</span></span></span><br><span class="line"><span class="function">       17: <span class="title">bipush</span>        10</span></span><br><span class="line"><span class="function">       19: <span class="title">putfield</span>      #4                  // <span class="title">Field</span> <span class="title">b:I</span></span></span><br><span class="line"><span class="function">       22: <span class="title">aload_0</span></span></span><br><span class="line"><span class="function">       23: <span class="title">ldc</span>           #5                  // <span class="title">String</span> <span class="title">s2</span></span></span><br><span class="line"><span class="function">       25: <span class="title">putfield</span>      #3                  // <span class="title">Field</span> <span class="title">a:Ljava</span>/<span class="title">lang</span>/<span class="title">String</span>;</span></span><br><span class="line"><span class="function">       // 原始构造方法在最后执行</span></span><br><span class="line"><span class="function">       28: <span class="title">aload_0</span></span></span><br><span class="line"><span class="function">       29: <span class="title">aload_1</span></span></span><br><span class="line"><span class="function">       30: <span class="title">putfield</span>      #3                  // <span class="title">Field</span> <span class="title">a:Ljava</span>/<span class="title">lang</span>/<span class="title">String</span>;</span></span><br><span class="line"><span class="function">       33: <span class="title">aload_0</span></span></span><br><span class="line"><span class="function">       34: <span class="title">iload_2</span></span></span><br><span class="line"><span class="function">       35: <span class="title">putfield</span>      #4                  // <span class="title">Field</span> <span class="title">b:I</span></span></span><br><span class="line"><span class="function">       38: <span class="title">return</span></span></span><br></pre></td></tr></table></figure>

<h2 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code_14_MethodTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Code_14_MethodTest</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Code_14_MethodTest</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Code_14_MethodTest</span>();</span><br><span class="line">        obj.test1();</span><br><span class="line">        obj.test2();</span><br><span class="line">        obj.test3();</span><br><span class="line">        Code_14_MethodTest.test4();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不同方法在调用时，对应的虚拟机指令有所区别</p>
<ul>
<li>私有、构造、被final修饰的方法，在调用时都使用invokespecial指令</li>
<li>普通成员方法在调用时，使用invokevirtual指令。因为编译期间无法确定该方法的内容，只有在运行期间才能确定</li>
<li>静态方法在调用时使用invokestatic指令</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">2</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: <span class="keyword">new</span>           #<span class="number">2</span>                  <span class="comment">//</span></span><br><span class="line">         <span class="number">3</span>: dup <span class="comment">// 复制一份对象地址压入操作数栈中</span></span><br><span class="line">         <span class="number">4</span>: invokespecial #<span class="number">3</span>                  <span class="comment">// Method &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">7</span>: astore_1</span><br><span class="line">         <span class="number">8</span>: aload_1</span><br><span class="line">         <span class="number">9</span>: invokespecial #<span class="number">4</span>                  <span class="comment">// Method test1:()V</span></span><br><span class="line">        <span class="number">12</span>: aload_1</span><br><span class="line">        <span class="number">13</span>: invokespecial #<span class="number">5</span>                  <span class="comment">// Method test2:()V</span></span><br><span class="line">        <span class="number">16</span>: aload_1</span><br><span class="line">        <span class="number">17</span>: invokevirtual #<span class="number">6</span>                  <span class="comment">// Method test3:()V</span></span><br><span class="line">        <span class="number">20</span>: invokestatic  #<span class="number">7</span>                  <span class="comment">// Method test4:()V</span></span><br><span class="line">        <span class="number">23</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<ul>
<li>new是创建【对象】，给对象分配堆空间，执行成功会将【对象引用】压入操作数栈</li>
<li>dup是赋值操作数栈栈顶的内容，本例即为【对象引用】，为什么许需要两份引用呢，一个是要配合invokespecial调用该对象的构造方法”init”:()V（会消耗栈顶一个引用），另一个要配合astore_1赋值给局部变量</li>
<li>终方法（final），私有方法（private），构造方法都是由invokespecial指令来调用，属于静态绑定</li>
<li>普通成员变量是由invokevirtual调用，属于动态绑定，即支持多态。成员方法与静态方法调用的另一个区别是，执行前是否需要【对象引用】</li>
</ul>
<h2 id="多态原理"><a href="#多态原理" class="headerlink" title="多态原理"></a>多态原理</h2><p>因为普通成员方法需要在运行时才能确定具体的内容，所以虚拟机需要调用invokevirtual指令</p>
<p>在执行invokevirtual指令时，经历了以下几个步骤：</p>
<ul>
<li>先通过栈帧中对象的引用找到对象</li>
<li>分析对象头，找到对象实际的Class</li>
<li>Class结构中有vtable，它在类加载的链接阶段就已经根据方法的重写规则生成好了</li>
<li>查询vtable（表）找到方法的具体地址</li>
<li>执行方法的字节码</li>
</ul>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p><strong>try-catch</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code_15_TryCatchTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            i = <span class="number">10</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            i = <span class="number">20</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应字节码指令：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Code:</span></span><br><span class="line"><span class="function"><span class="title">stack</span>=1, <span class="title">locals</span>=3, <span class="title">args_size</span>=1</span></span><br><span class="line"><span class="function">0: <span class="title">iconst_0</span></span></span><br><span class="line"><span class="function">1: <span class="title">istore_1</span></span></span><br><span class="line"><span class="function">2: <span class="title">bipush</span>        10</span></span><br><span class="line"><span class="function">4: <span class="title">istore_1</span></span></span><br><span class="line"><span class="function">5: <span class="title">goto</span>          12</span></span><br><span class="line"><span class="function">8: <span class="title">astore_2</span></span></span><br><span class="line"><span class="function">9: <span class="title">bipush</span>        20</span></span><br><span class="line"><span class="function">11: <span class="title">istore_1</span></span></span><br><span class="line"><span class="function">12: <span class="title">return</span></span></span><br><span class="line"><span class="function">//多出来一个异常表</span></span><br><span class="line"><span class="function"><span class="title">Exception</span> <span class="title">table</span>:</span></span><br><span class="line"><span class="function"><span class="title">from</span>    <span class="title">to</span>  <span class="title">target</span> <span class="title">type</span></span></span><br><span class="line"><span class="function">2       5     8   	<span class="title">Class</span> <span class="title">java</span>/<span class="title">lang</span>/<span class="title">Exception</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>可以看出来多出来一个Exception table的结构，[from, to)是前闭后开（也就是检测2~4行）的检测范围，一旦这个范围内的字节码执行出现异常，则通过type匹配异常类型，如果一致，进入target所指示行号</p>
</li>
<li><p>8行的字节码指令astore_2是将异常对象引用存入局部变量表的2号位置（e）</p>
</li>
</ul>
<p><strong>多个single-catch</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code_16_MultipleCatchTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            i = <span class="number">10</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">            i = <span class="number">20</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            i = <span class="number">30</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的字节码：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Code:</span></span><br><span class="line"><span class="function"><span class="title">stack</span>=1, <span class="title">locals</span>=3, <span class="title">args_size</span>=1</span></span><br><span class="line"><span class="function">0: <span class="title">iconst_0</span></span></span><br><span class="line"><span class="function">1: <span class="title">istore_1</span></span></span><br><span class="line"><span class="function">2: <span class="title">bipush</span>        10</span></span><br><span class="line"><span class="function">4: <span class="title">istore_1</span></span></span><br><span class="line"><span class="function">5: <span class="title">goto</span>          19</span></span><br><span class="line"><span class="function">8: <span class="title">astore_2</span></span></span><br><span class="line"><span class="function">9: <span class="title">bipush</span>        20</span></span><br><span class="line"><span class="function">11: <span class="title">istore_1</span></span></span><br><span class="line"><span class="function">12: <span class="title">goto</span>          19</span></span><br><span class="line"><span class="function">15: <span class="title">astore_2</span></span></span><br><span class="line"><span class="function">16: <span class="title">bipush</span>        30</span></span><br><span class="line"><span class="function">18: <span class="title">istore_1</span></span></span><br><span class="line"><span class="function">19: <span class="title">return</span></span></span><br><span class="line"><span class="function"><span class="title">Exception</span> <span class="title">table</span>:</span></span><br><span class="line"><span class="function"><span class="title">from</span>    <span class="title">to</span>  <span class="title">target</span> <span class="title">type</span></span></span><br><span class="line"><span class="function">2     	5     8   <span class="title">Class</span> <span class="title">java</span>/<span class="title">lang</span>/<span class="title">ArithmeticException</span></span></span><br><span class="line"><span class="function">2     	5    15   <span class="title">Class</span> <span class="title">java</span>/<span class="title">lang</span>/<span class="title">Exception</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>因为异常出现时，只能进入一个Exception table中一个分支，所以局部变量表slot 2位置被共用</li>
</ul>
<p><strong>finally</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code_17_FinallyTest</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            i = <span class="number">10</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            i = <span class="number">20</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            i = <span class="number">30</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应字节码：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Code:</span></span><br><span class="line"><span class="function"><span class="title">stack</span>=1, <span class="title">locals</span>=4, <span class="title">args_size</span>=1</span></span><br><span class="line"><span class="function">0: <span class="title">iconst_0</span></span></span><br><span class="line"><span class="function">1: <span class="title">istore_1</span></span></span><br><span class="line"><span class="function">// <span class="title">try</span>块</span></span><br><span class="line"><span class="function">2: <span class="title">bipush</span>        10</span></span><br><span class="line"><span class="function">4: <span class="title">istore_1</span></span></span><br><span class="line"><span class="function">// <span class="title">try</span>块执行完后，会执行<span class="title">finally</span>    </span></span><br><span class="line"><span class="function">5: <span class="title">bipush</span>        30</span></span><br><span class="line"><span class="function">7: <span class="title">istore_1</span></span></span><br><span class="line"><span class="function">8: <span class="title">goto</span>          27</span></span><br><span class="line"><span class="function">// <span class="title">catch</span>块     </span></span><br><span class="line"><span class="function">11: <span class="title">astore_2</span> // 异常信息放入局部变量表的2号槽位</span></span><br><span class="line"><span class="function">12: <span class="title">bipush</span>        20</span></span><br><span class="line"><span class="function">14: <span class="title">istore_1</span></span></span><br><span class="line"><span class="function">// <span class="title">catch</span>块执行完后，会执行<span class="title">finally</span>        </span></span><br><span class="line"><span class="function">15: <span class="title">bipush</span>        30</span></span><br><span class="line"><span class="function">17: <span class="title">istore_1</span></span></span><br><span class="line"><span class="function">18: <span class="title">goto</span>          27</span></span><br><span class="line"><span class="function">// 出现异常，但未被 <span class="title">Exception</span> 捕获，会抛出其他异常，这时也需要执行 <span class="title">finally</span> 块中的代码   </span></span><br><span class="line"><span class="function">21: <span class="title">astore_3</span></span></span><br><span class="line"><span class="function">22: <span class="title">bipush</span>        30</span></span><br><span class="line"><span class="function">24: <span class="title">istore_1</span></span></span><br><span class="line"><span class="function">25: <span class="title">aload_3</span></span></span><br><span class="line"><span class="function">26: <span class="title">athrow</span>  // 抛出异常</span></span><br><span class="line"><span class="function">27: <span class="title">return</span></span></span><br><span class="line"><span class="function"><span class="title">Exception</span> <span class="title">table</span>:</span></span><br><span class="line"><span class="function"><span class="title">from</span>    <span class="title">to</span>  <span class="title">target</span> 	<span class="title">type</span></span></span><br><span class="line"><span class="function">2     5    	11   	<span class="title">Class</span> <span class="title">java</span>/<span class="title">lang</span>/<span class="title">Exception</span></span></span><br><span class="line"><span class="function">2     5    	21   	<span class="title">any</span></span></span><br><span class="line"><span class="function">11    15    21   	<span class="title">any</span></span></span><br></pre></td></tr></table></figure>

<p>可以看到finally中的代码被复制了3份，分别放入try流程，catch流程以及catch剩余的异常类型流程</p>
<p>注意：虽然从字节码流程来看，每个块中都有finally块，但是finally块中的代码只会被执行一次</p>
<p><strong>finally中的return</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code_18_FinallyReturnTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> Code_18_FinallyReturnTest.test();</span><br><span class="line">        <span class="comment">// 结果为 20</span></span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            i = <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            i = <span class="number">20</span>;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应字节码：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Code:</span></span><br><span class="line"><span class="function"><span class="title">stack</span>=1, <span class="title">locals</span>=3, <span class="title">args_size</span>=0</span></span><br><span class="line"><span class="function">0: <span class="title">bipush</span>        10</span></span><br><span class="line"><span class="function">2: <span class="title">istore_0</span></span></span><br><span class="line"><span class="function">3: <span class="title">iload_0</span></span></span><br><span class="line"><span class="function">4: <span class="title">istore_1</span>  // 暂存返回值</span></span><br><span class="line"><span class="function">5: <span class="title">bipush</span>        20</span></span><br><span class="line"><span class="function">7: <span class="title">istore_0</span></span></span><br><span class="line"><span class="function">8: <span class="title">iload_0</span></span></span><br><span class="line"><span class="function">9: <span class="title">ireturn</span>	// <span class="title">ireturn</span> 会返回操作数栈顶的整型值 20</span></span><br><span class="line"><span class="function">// 如果出现异常，还是会执行<span class="title">finally</span> 块中的内容，没有抛出异常</span></span><br><span class="line"><span class="function">10: <span class="title">astore_2</span></span></span><br><span class="line"><span class="function">11: <span class="title">bipush</span>        20</span></span><br><span class="line"><span class="function">13: <span class="title">istore_0</span></span></span><br><span class="line"><span class="function">14: <span class="title">iload_0</span></span></span><br><span class="line"><span class="function">15: <span class="title">ireturn</span>	// 这里没有 <span class="title">athrow</span> 了，也就是如果在 <span class="title">finally</span> 块中如果有返回操作的话，且 <span class="title">try</span> 块中出现异常，会吞掉异常！</span></span><br><span class="line"><span class="function"><span class="title">Exception</span> <span class="title">table</span>:</span></span><br><span class="line"><span class="function"><span class="title">from</span>    <span class="title">to</span>  <span class="title">target</span> <span class="title">type</span></span></span><br><span class="line"><span class="function">0     5    10   <span class="title">any</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>由于finally中的ireturn被插入了所有可能的流程，因此返回结果肯定以finally的为准</li>
<li>至于字节码中第2行，似乎没啥用，且留个伏笔，看下个例子</li>
<li>跟上例中的finally相比，发现没有athrow了，这告诉我们：如果在finally中出现了return，会吞掉异常</li>
<li>所以不要在finally中进行返回操作</li>
</ul>
<p><strong>被吞掉的异常</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">int</span> i;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         i = <span class="number">10</span>;</span><br><span class="line">         <span class="comment">//  这里应该会抛出异常</span></span><br><span class="line">         i = i/<span class="number">0</span>;</span><br><span class="line">         <span class="keyword">return</span> i;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         i = <span class="number">20</span>;</span><br><span class="line">         <span class="keyword">return</span> i;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>会发现打印结果为20，并未抛出异常</p>
<p><strong>finally不带return</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			i = <span class="number">20</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>对应字节码：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Code:</span></span><br><span class="line"><span class="function"><span class="title">stack</span>=1, <span class="title">locals</span>=3, <span class="title">args_size</span>=0</span></span><br><span class="line"><span class="function">0: <span class="title">bipush</span>        10</span></span><br><span class="line"><span class="function">2: <span class="title">istore_0</span> // 赋值给<span class="title">i</span> 10</span></span><br><span class="line"><span class="function">3: <span class="title">iload_0</span>	// 加载到操作数栈顶</span></span><br><span class="line"><span class="function">4: <span class="title">istore_1</span> // 加载到局部变量表的1号位置</span></span><br><span class="line"><span class="function">5: <span class="title">bipush</span>        20</span></span><br><span class="line"><span class="function">7: <span class="title">istore_0</span> // 赋值给<span class="title">i</span> 20</span></span><br><span class="line"><span class="function">8: <span class="title">iload_1</span> // 加载局部变量表1号位置的数10到操作数栈</span></span><br><span class="line"><span class="function">9: <span class="title">ireturn</span> // 返回操作数栈顶元素 10</span></span><br><span class="line"><span class="function">10: <span class="title">astore_2</span></span></span><br><span class="line"><span class="function">11: <span class="title">bipush</span>        20</span></span><br><span class="line"><span class="function">13: <span class="title">istore_0</span></span></span><br><span class="line"><span class="function">14: <span class="title">aload_2</span> // 加载异常</span></span><br><span class="line"><span class="function">15: <span class="title">athrow</span> // 抛出异常</span></span><br><span class="line"><span class="function"><span class="title">Exception</span> <span class="title">table</span>:</span></span><br><span class="line"><span class="function"><span class="title">from</span>    <span class="title">to</span>  <span class="title">target</span> 	<span class="title">type</span></span></span><br><span class="line"><span class="function">3     	5    10   	<span class="title">any</span></span></span><br></pre></td></tr></table></figure>

<p>最后的返回结果是10</p>
<h2 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code_19_SyncTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对应字节码：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Code:</span></span><br><span class="line"><span class="function"><span class="title">stack</span>=2, <span class="title">locals</span>=4, <span class="title">args_size</span>=1</span></span><br><span class="line"><span class="function">0: <span class="title">new</span>           #2                  // <span class="title">class</span> <span class="title">java</span>/<span class="title">lang</span>/<span class="title">Object</span></span></span><br><span class="line"><span class="function">3: <span class="title">dup</span> // 复制一份栈顶，然后压入栈中。用于函数消耗</span></span><br><span class="line"><span class="function">4: <span class="title">invokespecial</span> #1                  // <span class="title">Method</span> <span class="title">java</span>/<span class="title">lang</span>/<span class="title">Object</span>.&quot;&lt;<span class="title">init</span>&gt;&quot;:()<span class="title">V</span></span></span><br><span class="line"><span class="function">7: <span class="title">astore_1</span> // 将栈顶的对象地址方法 局部变量表中 1 中</span></span><br><span class="line"><span class="function">8: <span class="title">aload_1</span> // 加载到操作数栈</span></span><br><span class="line"><span class="function">9: <span class="title">dup</span> // 复制一份，放到操作数栈，用于加锁时消耗</span></span><br><span class="line"><span class="function">10: <span class="title">astore_2</span> // 将操作数栈顶元素弹出，暂存到局部变量表的 2 号槽位。这时操作数栈中有一份对象的引用</span></span><br><span class="line"><span class="function">11: <span class="title">monitorenter</span> // 加锁</span></span><br><span class="line"><span class="function">12: <span class="title">getstatic</span>     #3                  // <span class="title">Field</span> <span class="title">java</span>/<span class="title">lang</span>/<span class="title">System.out:Ljava</span>/<span class="title">io</span>/<span class="title">PrintStream</span>;</span></span><br><span class="line"><span class="function">15: <span class="title">ldc</span>           #4                  // <span class="title">String</span> <span class="title">ok</span></span></span><br><span class="line"><span class="function">17: <span class="title">invokevirtual</span> #5                  // <span class="title">Method</span> <span class="title">java</span>/<span class="title">io</span>/<span class="title">PrintStream.println</span>:(<span class="title">Ljava</span>/<span class="title">lang</span>/<span class="title">String</span>;)<span class="title">V</span></span></span><br><span class="line"><span class="function">20: <span class="title">aload_2</span> // 加载对象到栈顶</span></span><br><span class="line"><span class="function">21: <span class="title">monitorexit</span> // 释放锁</span></span><br><span class="line"><span class="function">22: <span class="title">goto</span>          30</span></span><br><span class="line"><span class="function">// 异常情况的解决方案 释放锁！</span></span><br><span class="line"><span class="function">25: <span class="title">astore_3</span></span></span><br><span class="line"><span class="function">26: <span class="title">aload_2</span></span></span><br><span class="line"><span class="function">27: <span class="title">monitorexit</span></span></span><br><span class="line"><span class="function">28: <span class="title">aload_3</span></span></span><br><span class="line"><span class="function">29: <span class="title">athrow</span></span></span><br><span class="line"><span class="function">30: <span class="title">return</span></span></span><br><span class="line"><span class="function">// 异常表！</span></span><br><span class="line"><span class="function"><span class="title">Exception</span> <span class="title">table</span>:</span></span><br><span class="line"><span class="function"><span class="title">from</span>    <span class="title">to</span>  <span class="title">target</span> 	<span class="title">type</span></span></span><br><span class="line"><span class="function">12    	22    25   	<span class="title">any</span></span></span><br><span class="line"><span class="function">25    	28    25   	<span class="title">any</span></span></span><br></pre></td></tr></table></figure>

<h1 id="编译期处理"><a href="#编译期处理" class="headerlink" title="编译期处理"></a>编译期处理</h1><p>所谓的<strong>语法糖</strong>，其实就是指java编译器把.java源码编译为.class字节码的过程中，自动生成和转换的一些代码，主要是为了减轻程序员的负担，算是java编译器给我们的一个额外福利</p>
<p>注意，以下代码的解析，借助了javap工具，idea的反编译功能，idea差劲啊jclasslib等工具。另外，编译器转换的<strong>结果直接就是class字节码</strong>，只是为了方便阅读，给出了几乎等价的java源码方式，并不是编译器还会转换出中间的java源码，切记</p>
<h2 id="默认构造器"><a href="#默认构造器" class="headerlink" title="默认构造器"></a>默认构造器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Candy1</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过编译器优化后</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Candy1</span> &#123;</span><br><span class="line">   <span class="comment">// 这个无参构造器是java编译器帮我们加上的</span></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Candy1</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">// 即调用父类 Object 的无参构造方法，即调用 java/lang/Object.&quot; &lt;init&gt;&quot;:()V</span></span><br><span class="line">      <span class="built_in">super</span>();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自动拆装箱"><a href="#自动拆装箱" class="headerlink" title="自动拆装箱"></a>自动拆装箱</h2><p>这个特性是JDK 5开始加入的，代码片段1：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Candy2</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">      <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> x;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码在JDK 5之前是无法编译通过的，必须改写为代码片段2：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Candy2</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="comment">// 基本类型赋值给包装类型，称为装箱</span></span><br><span class="line">      <span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> Integer.valueOf(<span class="number">1</span>);</span><br><span class="line">      <span class="comment">// 包装类型赋值给基本类型，称谓拆箱</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> x.intValue();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="泛型集合取值"><a href="#泛型集合取值" class="headerlink" title="泛型集合取值"></a>泛型集合取值</h2><p>泛型也是在JDK 5开始加入的特性，但java在编译泛型代码后会执行泛型擦除的动作，即泛型信息在编译为字节码之后就丢失了，实际的类型都当作了Object类型来处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Candy3</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">      list.add(<span class="number">10</span>);</span><br><span class="line">      <span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> list.get(<span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应字节码：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Code:</span></span><br><span class="line"><span class="function"><span class="title">stack</span>=2, <span class="title">locals</span>=3, <span class="title">args_size</span>=1</span></span><br><span class="line"><span class="function">0: <span class="title">new</span>           #2                  // <span class="title">class</span> <span class="title">java</span>/<span class="title">util</span>/<span class="title">ArrayList</span></span></span><br><span class="line"><span class="function">3: <span class="title">dup</span></span></span><br><span class="line"><span class="function">4: <span class="title">invokespecial</span> #3                  // <span class="title">Method</span> <span class="title">java</span>/<span class="title">util</span>/<span class="title">ArrayList</span>.&quot;&lt;<span class="title">init</span>&gt;&quot;:()<span class="title">V</span></span></span><br><span class="line"><span class="function">7: <span class="title">astore_1</span></span></span><br><span class="line"><span class="function">8: <span class="title">aload_1</span></span></span><br><span class="line"><span class="function">9: <span class="title">bipush</span>        10</span></span><br><span class="line"><span class="function">11: <span class="title">invokestatic</span>  #4                  // <span class="title">Method</span> <span class="title">java</span>/<span class="title">lang</span>/<span class="title">Integer.valueOf</span>:(<span class="title">I</span>)<span class="title">Ljava</span>/<span class="title">lang</span>/<span class="title">Integer</span>;</span></span><br><span class="line"><span class="function">// 这里进行了泛型擦除，实际调用的是<span class="title">add</span>(<span class="title">Objcet</span> <span class="title">o</span>)</span></span><br><span class="line"><span class="function">14: <span class="title">invokeinterface</span> #5,  2            // <span class="title">InterfaceMethod</span> <span class="title">java</span>/<span class="title">util</span>/<span class="title">List.add</span>:(<span class="title">Ljava</span>/<span class="title">lang</span>/<span class="title">Object</span>;)<span class="title">Z</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">19: <span class="title">pop</span></span></span><br><span class="line"><span class="function">20: <span class="title">aload_1</span></span></span><br><span class="line"><span class="function">21: <span class="title">iconst_0</span></span></span><br><span class="line"><span class="function">// 这里也进行了泛型擦除，实际调用的是<span class="title">get</span>(<span class="title">Object</span> <span class="title">o</span>)   </span></span><br><span class="line"><span class="function">22: <span class="title">invokeinterface</span> #6,  2            // <span class="title">InterfaceMethod</span> <span class="title">java</span>/<span class="title">util</span>/<span class="title">List.get</span>:(<span class="title">I</span>)<span class="title">Ljava</span>/<span class="title">lang</span>/<span class="title">Object</span>;</span></span><br><span class="line"><span class="function">// 这里进行了类型转换，将 <span class="title">Object</span> 转换成了 <span class="title">Integer</span></span></span><br><span class="line"><span class="function">27: <span class="title">checkcast</span>     #7                  // <span class="title">class</span> <span class="title">java</span>/<span class="title">lang</span>/<span class="title">Integer</span></span></span><br><span class="line"><span class="function">30: <span class="title">astore_2</span></span></span><br><span class="line"><span class="function">31: <span class="title">return</span></span></span><br></pre></td></tr></table></figure>

<p>所以调用get函数取值时，有一个类型转换的操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> (Integer) list.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>如果想要将返回结果赋值给一个int类型的变量，则还有自动拆箱的操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> (Integer) list.get(<span class="number">0</span>).intValue();</span><br></pre></td></tr></table></figure>

<p>使用反射可以得到参数的类型以及泛型类型。泛型反射代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException &#123;</span><br><span class="line">    <span class="comment">// 1. 拿到方法</span></span><br><span class="line">    <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> Code_20_ReflectTest.class.getMethod(<span class="string">&quot;test&quot;</span>, List.class, Map.class);</span><br><span class="line">    <span class="comment">// 2. 得到泛型参数的类型信息</span></span><br><span class="line">    Type[] types = method.getGenericParameterTypes();</span><br><span class="line">    <span class="keyword">for</span>(Type type : types) &#123;</span><br><span class="line">        <span class="comment">// 3. 判断参数类型是否，带泛型的类型。</span></span><br><span class="line">        <span class="keyword">if</span>(type <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">            <span class="type">ParameterizedType</span> <span class="variable">parameterizedType</span> <span class="operator">=</span> (ParameterizedType) type;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4. 得到原始类型</span></span><br><span class="line">            System.out.println(<span class="string">&quot;原始类型 - &quot;</span> + parameterizedType.getRawType());</span><br><span class="line">            <span class="comment">// 5. 拿到泛型类型</span></span><br><span class="line">            Type[] arguments = parameterizedType.getActualTypeArguments();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arguments.length; i++) &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;泛型参数[%d] - %s\n&quot;</span>, i, arguments[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Set&lt;Integer&gt; <span class="title function_">test</span><span class="params">(List&lt;String&gt; list, Map&lt;Integer, Object&gt; map)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">原始类型 - interface java.util.List</span><br><span class="line">泛型参数[<span class="number">0</span>] - class java.lang.String</span><br><span class="line">原始类型 - interface java.util.Map</span><br><span class="line">泛型参数[<span class="number">0</span>] - class java.lang.Integer</span><br><span class="line">泛型参数[<span class="number">1</span>] - class java.lang.Object</span><br></pre></td></tr></table></figure>

<h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><p>可变参数也是JDK 5开始加入的特性，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Candy4</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(String... args)</span> &#123;</span><br><span class="line">      <span class="comment">// 将 args 赋值给 arr ，可以看出 String... 实际就是 String[]  </span></span><br><span class="line">      String[] arr = args;</span><br><span class="line">      System.out.println(arr);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      foo(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可变参数String… args其实是一个String[] args，从代码中的赋值语句中就可以看出来。同样java编译器会在编译期间将上述代码变换为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Candy4</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      String[] arr = args;</span><br><span class="line">      System.out.println(arr);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      foo(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>&#125;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：如果调用的是foo()，即未传递参数时，等价代码为foo(new String[])，创建了一个空数组，而不是直接传递的null</p>
<h2 id="foreach循环"><a href="#foreach循环" class="headerlink" title="foreach循环"></a>foreach循环</h2><p>仍是JDK 5开始引入的语法糖，数组的循环：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Candy5</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 数组赋初值的简化写法也是一种语法糖。</span></span><br><span class="line">		<span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> x : arr) &#123;</span><br><span class="line">			System.out.println(x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器帮我们进行转换：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Candy5</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Candy5</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; ++i) &#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> arr[i];</span><br><span class="line">			System.out.println(x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是集合使用foreach</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Candy5</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">      <span class="keyword">for</span> (Integer x : list) &#123;</span><br><span class="line">         System.out.println(x);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>集合要使用foreach，需要该集合类实现了Iterable接口，因为集合的遍历需要使用到<strong>迭代器</strong>Iterator</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Candy5</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Candy5</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">      <span class="comment">// 获得该集合的迭代器</span></span><br><span class="line">      Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class="line">      <span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">         <span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">         System.out.println(x);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="switch字符串"><a href="#switch字符串" class="headerlink" title="switch字符串"></a>switch字符串</h2><p>从JDK 7开始，switch可以作用于字符串和枚举类，这个功能其实也是语法糖，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cnady6</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">      <span class="keyword">switch</span> (str) &#123;</span><br><span class="line">         <span class="keyword">case</span> <span class="string">&quot;hello&quot;</span> :</span><br><span class="line">            System.out.println(<span class="string">&quot;h&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="string">&quot;world&quot;</span> :</span><br><span class="line">            System.out.println(<span class="string">&quot;w&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在编译器中执行的操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Candy6</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Candy6</span><span class="params">()</span> &#123;</span><br><span class="line">      </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">      <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">      <span class="comment">// 通过字符串的 hashCode + value 来判断是否匹配</span></span><br><span class="line">      <span class="keyword">switch</span> (str.hashCode()) &#123;</span><br><span class="line">         <span class="comment">// hello 的 hashCode</span></span><br><span class="line">         <span class="keyword">case</span> <span class="number">99162322</span> :</span><br><span class="line">            <span class="comment">// 再次比较，因为字符串的 hashCode 有可能相等</span></span><br><span class="line">            <span class="keyword">if</span>(str.equals(<span class="string">&quot;hello&quot;</span>)) &#123;</span><br><span class="line">               x = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="comment">// world 的 hashCode</span></span><br><span class="line">         <span class="keyword">case</span> <span class="number">11331880</span> :</span><br><span class="line">            <span class="keyword">if</span>(str.equals(<span class="string">&quot;world&quot;</span>)) &#123;</span><br><span class="line">               x = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 用第二个 switch 在进行输出判断</span></span><br><span class="line">      <span class="keyword">switch</span> (x) &#123;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;h&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;w&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>过程说明：</p>
<ul>
<li>编译期间，单个的switch被分成了两个<ul>
<li>第一个用来匹配字符串，并给x赋值<ul>
<li>字符串的匹配用到了字符串的hashCode，还用到了equals方法</li>
<li>使用hashCode是为了提高比较效率，使用equals是防止有hashCode冲突（如BM和C.）</li>
</ul>
</li>
<li>第二个用来根据x的值来决定输出语句</li>
</ul>
</li>
</ul>
<h2 id="switch枚举"><a href="#switch枚举" class="headerlink" title="switch枚举"></a>switch枚举</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">SEX</span> &#123;</span><br><span class="line">   MALE, FEMALE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Candy7</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">SEX</span> <span class="variable">sex</span> <span class="operator">=</span> SEX.MALE;</span><br><span class="line">      <span class="keyword">switch</span> (sex) &#123;</span><br><span class="line">         <span class="keyword">case</span> MALE:</span><br><span class="line">            System.out.println(<span class="string">&quot;man&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> FEMALE:</span><br><span class="line">            System.out.println(<span class="string">&quot;woman&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器中执行的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">SEX</span> &#123;</span><br><span class="line">   MALE, FEMALE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Candy7</span> &#123;</span><br><span class="line">   <span class="comment">/**     </span></span><br><span class="line"><span class="comment">    * 定义一个合成类（仅 jvm 使用，对我们不可见）     </span></span><br><span class="line"><span class="comment">    * 用来映射枚举的 ordinal 与数组元素的关系     </span></span><br><span class="line"><span class="comment">    * 枚举的 ordinal 表示枚举对象的序号，从 0 开始     </span></span><br><span class="line"><span class="comment">    * 即 MALE 的 ordinal()=0，FEMALE 的 ordinal()=1     </span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">$MAP</span> &#123;</span><br><span class="line">      <span class="comment">// 数组大小即为枚举元素个数，里面存放了 case 用于比较的数字</span></span><br><span class="line">      <span class="keyword">static</span> <span class="type">int</span>[] map = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">      <span class="keyword">static</span> &#123;</span><br><span class="line">         <span class="comment">// ordinal 即枚举元素对应所在的位置，MALE 为 0 ，FEMALE 为 1</span></span><br><span class="line">         map[SEX.MALE.ordinal()] = <span class="number">1</span>;</span><br><span class="line">         map[SEX.FEMALE.ordinal()] = <span class="number">2</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">SEX</span> <span class="variable">sex</span> <span class="operator">=</span> SEX.MALE;</span><br><span class="line">      <span class="comment">// 将对应位置枚举元素的值赋给 x ，用于 case 操作</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> $MAP.map[sex.ordinal()];</span><br><span class="line">      <span class="keyword">switch</span> (x) &#123;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;man&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;woman&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h2><p>JDK 7新增了枚举类，以前面的性别枚举为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">SEX</span> &#123;</span><br><span class="line">   MALE, FEMALE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转换后的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Sex</span> <span class="keyword">extends</span> <span class="title class_">Enum</span>&lt;Sex&gt; &#123;   </span><br><span class="line">   <span class="comment">// 对应枚举类中的元素</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Sex MALE;    </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Sex FEMALE;    </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Sex[] $VALUES;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">static</span> &#123;       </span><br><span class="line">    	<span class="comment">// 调用构造函数，传入枚举元素的值及 ordinal</span></span><br><span class="line">    	MALE = <span class="keyword">new</span> <span class="title class_">Sex</span>(<span class="string">&quot;MALE&quot;</span>, <span class="number">0</span>);    </span><br><span class="line">        FEMALE = <span class="keyword">new</span> <span class="title class_">Sex</span>(<span class="string">&quot;FEMALE&quot;</span>, <span class="number">1</span>);   </span><br><span class="line">        $VALUES = <span class="keyword">new</span> <span class="title class_">Sex</span>[]&#123;MALE, FEMALE&#125;; </span><br><span class="line">   &#125;</span><br><span class="line"> 	</span><br><span class="line">   <span class="comment">// 调用父类中的方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Sex</span><span class="params">(String name, <span class="type">int</span> ordinal)</span> &#123;     </span><br><span class="line">        <span class="built_in">super</span>(name, ordinal);    </span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Sex[] values() &#123;  </span><br><span class="line">        <span class="keyword">return</span> $VALUES.clone();  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Sex <span class="title function_">valueOf</span><span class="params">(String name)</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> Enum.valueOf(Sex.class, name);  </span><br><span class="line">    &#125; </span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="try-with-resources"><a href="#try-with-resources" class="headerlink" title="try-with-resources"></a>try-with-resources</h2><p>JDK 7开始新增了对需要关闭的资源处理的特殊语法，’try-with-resources’</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>(资源变量 = 创建资源对象) &#123;</span><br><span class="line">	</span><br><span class="line">&#125; <span class="keyword">catch</span>() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中资源对象需要实现AutoCloseable接口，例如InputStream、OutputStream、Connection、Statement、ResultSet等接口都实现了AutoCloseable，使用try-with-resources可以不用写finally语句块，编译器会帮助生成关闭资源代码，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Candy9</span> &#123; </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="keyword">try</span>(<span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;d:\\1.txt&quot;</span>))&#123;	</span><br><span class="line">			System.out.println(is); </span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123; </span><br><span class="line">			e.printStackTrace(); </span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会被转化成为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Candy9</span> &#123; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Candy9</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;d:\\1.txt&quot;</span>);</span><br><span class="line">            <span class="type">Throwable</span> <span class="variable">t</span> <span class="operator">=</span> <span class="literal">null</span>; </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(is); </span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e1) &#123; </span><br><span class="line">                <span class="comment">// t 是我们代码出现的异常 </span></span><br><span class="line">                t = e1; </span><br><span class="line">                <span class="keyword">throw</span> e1; </span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 判断了资源不为空 </span></span><br><span class="line">                <span class="keyword">if</span> (is != <span class="literal">null</span>) &#123; </span><br><span class="line">                    <span class="comment">// 如果我们代码有异常</span></span><br><span class="line">                    <span class="keyword">if</span> (t != <span class="literal">null</span>) &#123; </span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            is.close(); </span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Throwable e2) &#123; </span><br><span class="line">                            <span class="comment">// 如果 close 出现异常，作为被压制异常添加</span></span><br><span class="line">                            t.addSuppressed(e2); </span><br><span class="line">                        &#125; </span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">                        <span class="comment">// 如果我们代码没有异常，close 出现的异常就是最后 catch 块中的 e </span></span><br><span class="line">                        is.close(); </span><br><span class="line">                    &#125; </span><br><span class="line">                &#125; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace(); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么要设计一个addSuppressed(Throwable e)（添加被压制异常）的方法呢？是为了防止异常信息的丢失（想想try-with-resources生成的finally中如果抛出了异常）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test6</span> &#123; </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line">		<span class="keyword">try</span> (<span class="type">MyResource</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyResource</span>()) &#123; </span><br><span class="line">			<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>/<span class="number">0</span>; </span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123; </span><br><span class="line">			e.printStackTrace(); </span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyResource</span> <span class="keyword">implements</span> <span class="title class_">AutoCloseable</span> &#123; </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123; </span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;close 异常&quot;</span>); </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java.lang.ArithmeticException: / by zero </span><br><span class="line">	at test.Test6.main(Test6.java:<span class="number">7</span>) </span><br><span class="line">	Suppressed: java.lang.Exception: close 异常 </span><br><span class="line">		at test.MyResource.close(Test6.java:<span class="number">18</span>) </span><br><span class="line">		at test.Test6.main(Test6.java:<span class="number">6</span>)</span><br></pre></td></tr></table></figure>

<p>如以上代码所示，两个异常信息都不会丢失</p>
<h2 id="方法重写时的桥接方法"><a href="#方法重写时的桥接方法" class="headerlink" title="方法重写时的桥接方法"></a>方法重写时的桥接方法</h2><p>我们都知道，方法重写时返回值分为两种情况：</p>
<ul>
<li>父子类的返回值完全一致</li>
<li>子类返回值可以是父类返回值的子类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; </span><br><span class="line">	<span class="keyword">public</span> Number <span class="title function_">m</span><span class="params">()</span> &#123; </span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123; </span><br><span class="line">	<span class="meta">@Override</span> </span><br><span class="line">	<span class="comment">// 子类 m 方法的返回值是 Integer 是父类 m 方法返回值 Number 的子类 	</span></span><br><span class="line">	<span class="keyword">public</span> Integer <span class="title function_">m</span><span class="params">()</span> &#123; </span><br><span class="line">		<span class="keyword">return</span> <span class="number">2</span>; </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于子类，java编译器会做如下处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123; </span><br><span class="line">	<span class="keyword">public</span> Integer <span class="title function_">m</span><span class="params">()</span> &#123; </span><br><span class="line">		<span class="keyword">return</span> <span class="number">2</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 此方法才是真正重写了父类 public Number m() 方法 </span></span><br><span class="line">	<span class="keyword">public</span> synthetic bridge Number <span class="title function_">m</span><span class="params">()</span> &#123; </span><br><span class="line">		<span class="comment">// 调用 public Integer m() </span></span><br><span class="line">		<span class="keyword">return</span> m(); </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中桥接方法比较特殊，仅对java虚拟机可见，并且与原来的public Integer m()没有命名冲突，可以用下面反射代码来验证：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(Method m : B.class.getDeclaredMethods()) &#123;</span><br><span class="line">            System.out.println(m);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> java.lang.Integer cn.ali.jvm.test.B.m()</span><br><span class="line"><span class="keyword">public</span> java.lang.Number cn.ali.jvm.test.B.m()</span><br></pre></td></tr></table></figure>

<h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Candy10</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;running...&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转换后的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Candy10</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="comment">// 用额外创建的类来创建匿名内部类对象</span></span><br><span class="line">      <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Candy10$1</span>();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建了一个额外的类，实现了 Runnable 接口</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Candy10$1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> Demo10$<span class="number">1</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;running...&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>引用局部变量的匿名内部类，源代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Candy11</span> &#123; </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> x)</span> &#123; </span><br><span class="line">		<span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123; </span><br><span class="line">			<span class="meta">@Override</span> </span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123; 	</span><br><span class="line">				System.out.println(<span class="string">&quot;ok:&quot;</span> + x); </span><br><span class="line">			&#125; </span><br><span class="line">		&#125;; </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转换后代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 额外生成的类 </span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Candy11$1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123; </span><br><span class="line">	<span class="type">int</span> val$x; </span><br><span class="line">	Candy11$<span class="number">1</span>(<span class="type">int</span> x) &#123; </span><br><span class="line">		<span class="built_in">this</span>.val$x = x; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123; </span><br><span class="line">		System.out.println(<span class="string">&quot;ok:&quot;</span> + <span class="built_in">this</span>.val$x); </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Candy11</span> &#123; </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> x)</span> &#123; </span><br><span class="line">		<span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Candy11$1</span>(x); </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：这同时解释了为什么匿名内部类引用局部变量时，局部变量必须是final的：因为在创建Candy11$1对象时，将x的值赋值给了Candy11$1对象的值后，如果不是final生命的x值发生了改变，匿名内部类则值不一致</p>
<h1 id="类加载阶段"><a href="#类加载阶段" class="headerlink" title="类加载阶段"></a>类加载阶段</h1><h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><ul>
<li>将类的字节码载入方法区（1.8以后为元空间，在本地内存中），内部采用C++的instaanceKlass描述java类，它的重要field有：<ul>
<li>_java_mirror即java的类镜像，例如对String来说，它的镜像类就是String.class，作用是把klass暴露给java使用</li>
<li>_super即父类</li>
<li>_fields即成员变量</li>
<li>_methods即方法</li>
<li>_constants即常量池</li>
<li>_class_loader即类加载器</li>
<li>_vtable虚方法表</li>
<li>_itable接口方法</li>
</ul>
</li>
<li>如果这个类还有父类没有加载，先加载父类</li>
<li>加载和链接可能是交替运行的</li>
</ul>
<p><img src="/../images/JVM/62.png" alt="类加载"></p>
<ul>
<li>instanceKlass保存在方法区。JDK 8以后，方法区位于元空间中，而元空间又位于本地内存中</li>
<li>_java_mirror则是保存在堆内存中</li>
<li>instanceKlass和*.class（JAVA镜像类）互相保存了对方的地址</li>
<li>类的对象在对象头中保存了*.class的地址。让对象可以通过其找到方法区中的instanceKlass，从而获取类的各种信息</li>
</ul>
<p><strong>注意</strong></p>
<ul>
<li>instanceKlass这样的【元数据】是存储在方法区（1.8后的元空间内），但_java_mirror是存储在堆中</li>
<li>可以通过前面介绍的HSDB工具查看</li>
</ul>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><strong>验证</strong></p>
<p>验证类是否符合JAVA规范，安全性检查</p>
<p>用UE等支持二进制的编辑器修改HelloWorld.class的魔数，在控制台运行</p>
<p><strong>准备</strong></p>
<p>为static变量分配空间，设置默认值</p>
<ul>
<li>static变量在JDK7之前存储于instanceKlass末尾，从JDK 7开始，存储于_java_mirror末尾</li>
<li>static变量分配空间和赋值是两个步骤，分配空间在准备阶段完成，赋值在初始化阶段完成</li>
<li>如果static变量是final的基本类型，以及字符串常量，那么编译阶段值就确定了，赋值在准备阶段完成</li>
<li>如果static变量是final的，但属于引用类型，那么赋值阶段也会在初始化阶段完成。</li>
</ul>
<p><strong>解析</strong></p>
<p>将常量池中的符号引用解析为直接引用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code_22_AnalysisTest</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, IOException &#123;</span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> Code_22_AnalysisTest.class.getClassLoader();</span><br><span class="line">        Class&lt;?&gt; c = classLoader.loadClass(<span class="string">&quot;cn.ali.jvm.test.C&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// new C();</span></span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">    <span class="type">D</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">D</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解析阶段是虚拟机将常量池的【符号引用】直接替换为【直接引用】的过程。符号引用是以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用的时候可以无歧义地定位到目标即可。直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄，直接引用是和虚拟机实现的内存布局相关的。如果有了直接引用，那引用的目标必定已经在内存中了</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p><strong><cinit>()v方法</strong></p>
<p>初始化即调用<cinit>()V，虚拟机会保证这个类的【构造方法】的线程安全</p>
<p><strong>发生的时机</strong></p>
<p>概括地说，类初始化是【懒惰的】</p>
<ul>
<li>main方法所在的类，总会被首先初始化</li>
<li>首次访问这个类的静态变量或静态方法时</li>
<li>子类初始化，如果父类还没初始化，会引发</li>
<li>子类访问父类的静态变量，只会触发父类的初始化</li>
<li>Class.forName</li>
<li>new会导致初始化</li>
</ul>
<p><strong>不会导致类初始化的情况</strong></p>
<ul>
<li>访问类的static final静态常量（基本类型和字符串）不会触发初始化</li>
<li>类对象.class不会触发初始化</li>
<li>创建该类的数组不会触发初始化</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Load1</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">// 1. 静态常量（基本类型和字符串）不会触发初始化</span></span><br><span class="line"><span class="comment">//         System.out.println(B.b);</span></span><br><span class="line">        <span class="comment">// 2. 类对象.class 不会触发初始化</span></span><br><span class="line"><span class="comment">//         System.out.println(B.class);</span></span><br><span class="line">        <span class="comment">// 3. 创建该类的数组不会触发初始化</span></span><br><span class="line"><span class="comment">//         System.out.println(new B[0]);</span></span><br><span class="line">        <span class="comment">// 4. 不会初始化类 B，但会加载 B、A</span></span><br><span class="line"><span class="comment">//         ClassLoader cl = Thread.currentThread().getContextClassLoader();</span></span><br><span class="line"><span class="comment">//         cl.loadClass(&quot;cn.ali.jvm.test.classload.B&quot;);</span></span><br><span class="line">        <span class="comment">// 5. 不会初始化类 B，但会加载 B、A</span></span><br><span class="line"><span class="comment">//         ClassLoader c2 = Thread.currentThread().getContextClassLoader();</span></span><br><span class="line"><span class="comment">//         Class.forName(&quot;cn.ali.jvm.test.classload.B&quot;, false, c2);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 首次访问这个类的静态变量或静态方法时</span></span><br><span class="line"><span class="comment">//         System.out.println(A.a);</span></span><br><span class="line">        <span class="comment">// 2. 子类初始化，如果父类还没初始化，会引发父类初始化</span></span><br><span class="line"><span class="comment">//         System.out.println(B.c);</span></span><br><span class="line">        <span class="comment">// 3. 子类访问父类静态变量，只触发父类初始化</span></span><br><span class="line"><span class="comment">//         System.out.println(B.a);</span></span><br><span class="line">        <span class="comment">// 4. 会初始化类 B，并先初始化类 A</span></span><br><span class="line"><span class="comment">//         Class.forName(&quot;cn.ali.jvm.test.classload.B&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;a init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">double</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">5.0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">c</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;b init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>练习</strong></p>
<p>从字节码角分析，使用a、b、c这三个常量是否会导致E初始化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Load2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(E.a);</span><br><span class="line">        System.out.println(E.b);</span><br><span class="line">        <span class="comment">// 会导致 E 类初始化，因为 Integer 是包装类</span></span><br><span class="line">        System.out.println(E.c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">E</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;E cinit&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>典型应用-完成懒惰初始化单例模式</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123; &#125; </span><br><span class="line">    <span class="comment">// 内部类中保存单例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">LazyHolder</span> &#123; </span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>(); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第一次调用 getInstance 方法，才会导致内部类加载和初始化其静态成员 </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> LazyHolder.INSTANCE; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上的实现特点是：</p>
<ul>
<li>懒惰实例化</li>
<li>初始化时的线程安全是有保障的</li>
</ul>
<h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><p>类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远超类加载阶段对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性，每个类加载器，都拥有一个独立的类名称空间。这句话可以表达得更通俗一些：比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载得前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个Java虚拟机加载，只要加载它们得类加载器不同，那这两个类就必定不相等</p>
<p>以JDK 8为例：</p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">加载的类</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Bootstrap ClassLoader(启动类加载器)</td>
<td align="center">JAVA_HOME&#x2F;jre&#x2F;lib</td>
<td align="center">无法直接访问</td>
</tr>
<tr>
<td align="center">Extension ClassLoader(拓展类加载器)</td>
<td align="center">JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;ext</td>
<td align="center">上级为Bootstrap，显示为null</td>
</tr>
<tr>
<td align="center">Application ClassLoader(应用程序类加载器)</td>
<td align="center">classpath</td>
<td align="center">上级为Extension</td>
</tr>
<tr>
<td align="center">自定义类加载器</td>
<td align="center">自定义</td>
<td align="center">上级为Application</td>
</tr>
</tbody></table>
<h2 id="启动类的加载器"><a href="#启动类的加载器" class="headerlink" title="启动类的加载器"></a>启动类的加载器</h2><p>给出F类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.jvm.t3.load;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">F</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">F</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;bootstrap F init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在控制台执行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Load5_1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Load5_1</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        Class&lt;?&gt; aClass = Class.forName(<span class="string">&quot;cn.itcast.jvm.t3.load.F&quot;</span>);</span><br><span class="line">        System.out.println(aClass.getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在控制台输出命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PS E:\learning\jvm\out\production\jvm&gt; java -Xbootclasspath/a:. cn.itcast.jvm.t3.load.Load5_1</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bootstrap F init</span><br><span class="line">null</span><br></pre></td></tr></table></figure>

<ul>
<li>-Xbootclasspath表示设置bootclasspath</li>
<li>其中&#x2F;a:.表示将当前目录追加至bootclasspath之后</li>
<li>可以用这个办法替换核心类<ul>
<li>java -Xbootclasspath:<new bootclasspath></li>
<li>java -Xbootclasspath&#x2F;a:&lt;追加路径&gt;</li>
<li>java -Xbootclasspath&#x2F;p:&lt;追加路径&gt;</li>
</ul>
</li>
</ul>
<h2 id="扩展类的加载器"><a href="#扩展类的加载器" class="headerlink" title="扩展类的加载器"></a>扩展类的加载器</h2><p>如果classpath和JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;ext下有同名类，加载时会使用拓展类加载器加载。当引用程序类加载器发现拓展加载器已经将同名类加载过了，则不会再次加载</p>
<h2 id="双亲委派模式"><a href="#双亲委派模式" class="headerlink" title="双亲委派模式"></a>双亲委派模式</h2><p>双亲委派模式，即调用类加载器ClassLoader的loadClass方法时，查找类的规则</p>
<p>loadCClass源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// 首先查找该类是否已经被该类加载器加载过了</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="comment">// 如果没有被加载过</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">t0</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 有上级的话，委派上级loadClass</span></span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                    c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果没有上级了（ExtClassLoader），则委派BootstrapClassLoader</span></span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                <span class="comment">//捕获异常，但不做任何处理</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                <span class="comment">//每一层都没有找不到，调用findClass方法（每个类加载器自己扩展）来扩加载</span></span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 记录时间</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h2><p><strong>使用场景</strong></p>
<ul>
<li>想加载非classpath随意路径中的类文件</li>
<li>通过接口来使用实现，希望解耦时，常用在框架设计</li>
<li>这些类希望予以隔离，不同应用的同类名都可以加载，不冲突，常见于tomcat容器</li>
</ul>
<p><strong>步骤</strong></p>
<ul>
<li>继承ClassLoader父类</li>
<li>要遵从双亲委派机制，重写findClass方法<ul>
<li>不是重写loadClass方法，否则不会走双亲委派机制</li>
</ul>
</li>
<li>读取类文件的字节码</li>
<li>调用父类的defineClass方法来加载类</li>
<li>使用者调用该类加载器的loadClass方法</li>
</ul>
<p><strong>破坏双亲委派模式</strong></p>
<ul>
<li>双亲委派模式的第一次“被破坏”其实发生在双亲委派模型出现之前——即JDK1.2面世以前的“远古”时代<ul>
<li>建议用户重写findClass()方法，在类加载器中的loadClass()方法中也会调用该方法</li>
</ul>
</li>
<li>双亲委派模式的第二次“被破坏”是由这个模型自身的缺陷导致<ul>
<li>如果有基础类型又要调用回用户的代码，此时也会破坏双亲委派模式</li>
</ul>
</li>
<li>双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的<ul>
<li>这里所说的“动态性”指的是一些非常“热门”的名词：代码热替换（Hot Swap）、模块热部署（Hot Deployment）等</li>
</ul>
</li>
</ul>
<h1 id="运行期优化"><a href="#运行期优化" class="headerlink" title="运行期优化"></a>运行期优化</h1><h2 id="即时编译"><a href="#即时编译" class="headerlink" title="即时编译"></a>即时编译</h2><h3 id="分层编译"><a href="#分层编译" class="headerlink" title="分层编译"></a>分层编译</h3><p>JVM将执行状态分成了五个层次：</p>
<ul>
<li>0层：解释执行，用解释器将字节码翻译为机器码</li>
<li>1层：使用C1即时编译器编译执行（不带profiling）</li>
<li>2层：使用C1即时编译器编译执行（带基本的profiling）</li>
<li>3层：使用C1即时编译器编译执行（带完全的profiling）</li>
<li>4层：使用C2即使编译器编译执行</li>
</ul>
<p>profiling是指在运行过程中收集一些程序执行状态的数据，例如【方法的调用次数】，【循环的回边次数】等</p>
<p>即时编译器（JIT）与解释器的区别</p>
<ul>
<li>解释器<ul>
<li>将字节码解释为机器码，下次即使遇到相同的字节码，仍会执行重复的解释</li>
<li>是将字节码解释为针对所有平台都通用的机器码</li>
</ul>
</li>
<li>即时编译器<ul>
<li>将一些字节码编译为机器码，并存入Code Cache，下次遇到相同的代码，直接执行，无需再编译</li>
<li>根据平台类型，生成平台特定的机器码</li>
</ul>
</li>
</ul>
<p>对于大部分的不常用的代码，我们无需耗费时间将其编译为机器码，而是采用解释器执行的方式运行；另一方面，对于仅占小部分的热点代码，我们则可以将其编译成机器码，以达到理想的运行速度。执行效率上简单比较一下Interpreter &lt; C1 &lt; C2，总的目标是发现热点代码（hotspot名称的由来），并优化这些代码</p>
<p><strong>逃逸分析</strong></p>
<p>逃逸分析简单来讲就是，Java Hotspot虚拟机可以分析新创建对象的使用范围，并决定是否在Java堆上分配内存的一项技术</p>
<p>逃逸分析的JVM参数如下：</p>
<ul>
<li>开启逃逸分析：-XX:+DoEscapeAnalysis</li>
<li>关闭逃逸分析：-XX:-DoEscapeAnalysis</li>
<li>显示分析结果：-XX:+PrintEscapeAnalysis</li>
</ul>
<p>逃逸分析技术在 Java SE 6u23+ 开始支持，并默认设置为启用状态，可以不用额外加这个参数</p>
<h3 id="方法内联"><a href="#方法内联" class="headerlink" title="方法内联"></a>方法内联</h3><p>内联函数就是在程序编译时，编译器将程序中出现的内联函数的调用表达式用内联函数的函数体来直接进行替换</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">square</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> i * i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(square(<span class="number">9</span>))</span><br></pre></td></tr></table></figure>

<p>如果发现square是热点方法，并且长度不太长时，会进行内联，所谓的内联就是把方法内代码拷贝到、粘贴到调用者的位置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="number">9</span> * <span class="number">9</span>)</span><br></pre></td></tr></table></figure>

<p>还能够进行常量折叠（constant folding）的优化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="number">81</span>)</span><br></pre></td></tr></table></figure>

<p>进行内联后的函数执行速度会显著加快</p>
<h2 id="反射优化"><a href="#反射优化" class="headerlink" title="反射优化"></a>反射优化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Reflect1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;foo...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123;</span><br><span class="line">        <span class="type">Method</span> <span class="variable">foo</span> <span class="operator">=</span> Demo3.class.getMethod(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;=<span class="number">16</span>; i++) &#123;</span><br><span class="line">            foo.invoke(<span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>foo.invoke前面0~15次调用使用的是MethodAccessor 的NativeMethodAccessorImpl 实现的invoke方法源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object obj, Object... args)</span></span><br><span class="line">    <span class="keyword">throws</span> IllegalAccessException, IllegalArgumentException,</span><br><span class="line">InvocationTargetException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!override) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123;</span><br><span class="line">            Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">            checkAccess(caller, clazz, obj, modifiers);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//MethodAccessor是一个接口，有3个实现类，其中有一个是抽象类</span></span><br><span class="line">    <span class="type">MethodAccessor</span> <span class="variable">ma</span> <span class="operator">=</span> methodAccessor;             <span class="comment">// read volatile</span></span><br><span class="line">    <span class="keyword">if</span> (ma == <span class="literal">null</span>) &#123;</span><br><span class="line">        ma = acquireMethodAccessor();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ma.invoke(obj, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../images/JVM/63.png" alt="调用invoke"></p>
<p>会默认使用DelagatingMethodAccessorImpl去调用 NativeMethodAccessorImpl源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NativeMethodAccessorImpl</span> <span class="keyword">extends</span> <span class="title class_">MethodAccessorImpl</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Method method;</span><br><span class="line">    <span class="keyword">private</span> DelegatingMethodAccessorImpl parent;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> numInvocations;</span><br><span class="line"></span><br><span class="line">    NativeMethodAccessorImpl(Method var1) &#123;</span><br><span class="line">        <span class="built_in">this</span>.method = var1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//每次进行反射调用，会让numInvocation与ReflectionFactory.inflationThreshold的值（15）进行比较，并使使得numInvocation的值加一</span></span><br><span class="line">    <span class="comment">//如果numInvocation&gt;ReflectionFactory.inflationThreshold，则会调用本地方法invoke0方法</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object var1, Object[] var2)</span> <span class="keyword">throws</span> IllegalArgumentException, InvocationTargetException &#123;</span><br><span class="line">        <span class="keyword">if</span> (++<span class="built_in">this</span>.numInvocations &gt; ReflectionFactory.inflationThreshold() &amp;&amp; !ReflectUtil.isVMAnonymousClass(<span class="built_in">this</span>.method.getDeclaringClass())) &#123;</span><br><span class="line">            <span class="type">MethodAccessorImpl</span> <span class="variable">var3</span> <span class="operator">=</span> (MethodAccessorImpl)(<span class="keyword">new</span> <span class="title class_">MethodAccessorGenerator</span>()).generateMethod(<span class="built_in">this</span>.method.getDeclaringClass(), <span class="built_in">this</span>.method.getName(), <span class="built_in">this</span>.method.getParameterTypes(), <span class="built_in">this</span>.method.getReturnType(), <span class="built_in">this</span>.method.getExceptionTypes(), <span class="built_in">this</span>.method.getModifiers());</span><br><span class="line">            <span class="built_in">this</span>.parent.setDelegate(var3);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> invoke0(<span class="built_in">this</span>.method, var1, var2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setParent</span><span class="params">(DelegatingMethodAccessorImpl var1)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.parent = var1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> Object <span class="title function_">invoke0</span><span class="params">(Method var0, Object var1, Object[] var2)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ReflectionFactory.inflationThreshold()方法的返回值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">inflationThreshold</span> <span class="operator">=</span> <span class="number">15</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>一开始if条件不满足，就会调用本地方法invoke()</li>
<li>随着numInvocation的增大，当它大于ReflectionFactory.inflationThreshold的值16时，就会本地方法访问器替换为一个运行时动态生成的访问器，来提高效率</li>
<li>这时会从反射调用变为正常调用，即直接调用Reflect.foo()</li>
</ul>
<p><img src="/../images/JVM/64.png" alt="反射优化"></p>
<h1 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h1><h2 id="java内存模型"><a href="#java内存模型" class="headerlink" title="java内存模型"></a>java内存模型</h2><p>【java内存模型】是Java Memory Model（JMM）的意思</p>
<p>简单的说，JMM定义了一套在多线程读写共享数据时（成员变量、数组）时，对数据的可见性、有序性和原子性的规则和保障</p>
<h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p><strong>问题提出</strong></p>
<p>问题提出，两个线程对初始值为0的静态变量一个做自增，一个做自减，各做5000次，结果是0吗？</p>
<p><strong>问题分析</strong></p>
<p>以上的结果可能是正数、负数、零。为什么呢？因为Java中对静态变量的自增，自减不是原子操作</p>
<p>例如仅对于i++而言（i为静态变量），实际会产生如下的JVM字节码指令：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getstatic	i 	//获取静态变量i的值</span><br><span class="line">iconst_1		//准备常量<span class="number">1</span></span><br><span class="line">iadd			//加法</span><br><span class="line">putstatic	i	//将修改后的值存入静态变量i</span><br></pre></td></tr></table></figure>

<p>而对应的i–也是类似：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getstatic	i 	//获取静态变量i的值</span><br><span class="line">iconst_1		//准备常量<span class="number">1</span></span><br><span class="line">isub			//减法</span><br><span class="line">putstatic	i	//将修改后的值存入静态变量i</span><br></pre></td></tr></table></figure>

<p>而java的内存模型如下，完成静态变量的自增、自减需要在主存和线程内存中进行数据交换：</p>
<p><img src="/../images/JVM/65.png" alt="java内存模型"></p>
<p>如果是单线程执行以上八行代码不会出错（顺序执行）：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//假设i的初始值为<span class="number">0</span></span><br><span class="line">getstatic	i	//线程<span class="number">1</span>-获取静态变量i的值线程内i=<span class="number">01</span></span><br><span class="line">iconst_1		//线程<span class="number">1</span>-准备常量<span class="number">1</span></span><br><span class="line">iadd			//线程<span class="number">1</span>-自增线程内i=<span class="number">1</span></span><br><span class="line">putstatic	i	//线程<span class="number">1</span>-将修改后的值存入静态变量i静态变量i=<span class="number">1</span></span><br><span class="line">getstatic	i	//线程<span class="number">1</span>-获取静态变量i的值线程内i=<span class="number">1</span></span><br><span class="line">iconst_1		//线程<span class="number">1</span>-准备常量<span class="number">1</span></span><br><span class="line">isub			//线程<span class="number">1</span>-自减线程内i=<span class="number">0</span></span><br><span class="line">putstatic	i	//线程<span class="number">1</span>-将修改后的值存入静态变量i静态变量i=<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>但是很多线程下这八行代码可能交错运行（为什么会交错）：</p>
<p>出现负数的情况：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//假设i的初始值为<span class="number">0</span></span><br><span class="line">getstatic	i	//线程<span class="number">1</span>-获取静态变量i的值线程内i=<span class="number">0</span></span><br><span class="line">getstatic	i	//线程<span class="number">2</span>-获取静态变量i的值线程内i=<span class="number">0</span></span><br><span class="line">iconst_1		//线程<span class="number">1</span>-准备常量<span class="number">1</span></span><br><span class="line">iadd			//线程<span class="number">1</span>-自增线程内i=<span class="number">1</span></span><br><span class="line">putstatic	i	//线程<span class="number">1</span>-将修改后的值存入静态变量i静态变量i=<span class="number">1</span></span><br><span class="line">iconst_1		//线程<span class="number">2</span>-准备常量<span class="number">1</span></span><br><span class="line">isub			//线程<span class="number">2</span>-自减线程内i=-<span class="number">1</span></span><br><span class="line">putstatic	i	//线程<span class="number">2</span>-将修改后的值存入静态变量i静态变量i=-<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>出现正数的情况：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//假设i的初始值为<span class="number">0</span></span><br><span class="line">getstatic	i	//线程<span class="number">1</span>-获取静态变量i的值线程内i=<span class="number">0</span></span><br><span class="line">getstatic	i	//线程<span class="number">2</span>-获取静态变量i的值线程内i=<span class="number">0</span></span><br><span class="line">iconst_1		//线程<span class="number">1</span>-准备常量<span class="number">1</span></span><br><span class="line">iadd			//线程<span class="number">1</span>-自增 线程内i=<span class="number">1</span></span><br><span class="line">iconst_1		//线程<span class="number">2</span>-准备常量<span class="number">1</span></span><br><span class="line">isub			//线程<span class="number">2</span>-自减线程内i=-<span class="number">1</span></span><br><span class="line">putstatic	i	//线程<span class="number">2</span>-将修改后的值存入静态变量i静态变量i=-<span class="number">1</span></span><br><span class="line">putstatic	i	//线程<span class="number">1</span>-将修改后的值存入静态变量i静态变量i=<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>解决方法</strong></p>
<p>synchronized（同步关键字）</p>
<p>语法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(对象)&#123;</span><br><span class="line">    要作为原子操作代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用synchronized解决并发问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo4_1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">50000</span>; j++) &#123;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">50000</span>; j++) &#123;</span><br><span class="line">                    i--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如何理解呢：你可以把obj想象成一个房间，线程t1、t2想象成两个人</p>
<p>当线程t1执行到synchronized(obj)时就好比t1进入了这个房间，并反手锁住了门，在门内执行count++代码</p>
<p>这时候如果t2也运行到了synchronized(obj)时，它发现门被锁住了，只能在门外等待</p>
<p>当t1执行完synchronized(obj)块内的代码时，这时候才会解开门上的锁，从obg房间出来。t2线程这时才可以进入obj房间，反锁住门，执行它的count++代码</p>
<h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p><strong>退不出的循环</strong></p>
<p>先来看一个现象，main线程对run变量的修改对于t线程不可见，导致线程t无法停止：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo4_2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">run</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span>(run)&#123;</span><br><span class="line">                <span class="comment">// ....</span></span><br><span class="line">                System.out.println(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        run = <span class="literal">false</span>; <span class="comment">// 线程t不会如预想的停下来</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么呢？分析一下：</p>
<ol>
<li>初始状态，t线程刚开始从主内存读取了run的值到工作内存中</li>
</ol>
<p><img src="/../images/JVM/66.png" alt="读取"></p>
<ol start="2">
<li>因为t线程要频繁从主内存中读取run的值，JIT编译器会将run的值缓存至自己工作内存中的高速缓存中，减少对主存中run的访问，调高效率</li>
</ol>
<p><img src="/../images/JVM/67.png" alt="高速缓存"></p>
<ol start="3">
<li>一秒之后，main线程修改了run的值，并同步至主存中，而t是从自己工作内存中的高速缓存中读取这个变量的结果，结果永远是旧值</li>
</ol>
<p><img src="/../images/JVM/68.png" alt="旧值"></p>
<p><strong>解决办法</strong></p>
<p>volatile（易变关键字）</p>
<p>它可以用来修饰成员变量和静态成员变量，它可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作volatile变量都是直接操作内存</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">run</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<p><strong>可见性</strong></p>
<p>前面例子体现的实际就是可见性，它保证的是在多个线程之间，一个线程对volatile变量的修改对另一个线程可见，不能保证原子性（i++i–），仅用在一个写线程，多个读线程的情况</p>
<p>synchronized语句块既可以保证代码块的原子性，也同时保证代码块内变量的可见性。但缺点就是synchronized是属于重量级操作，性能相对较低</p>
<h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Outcome(id = &#123;&quot;1&quot;, &quot;4&quot;&#125;, expect = Expect.ACCEPTABLE, desc = &quot;ok&quot;)</span></span><br><span class="line"><span class="meta">@Outcome(id = &quot;0&quot;, expect = Expect.ACCEPTABLE_INTERESTING, desc = &quot;!!!!&quot;)</span></span><br><span class="line"><span class="meta">@State</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcurrencyTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">ready</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Actor</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor1</span><span class="params">(I_Result r)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ready) &#123;</span><br><span class="line">            r.r1 = num + num;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r.r1 = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Actor</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor2</span><span class="params">(I_Result r)</span> &#123;</span><br><span class="line">        num = <span class="number">2</span>;</span><br><span class="line">        ready = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在执行上述代码时，r.r1最终的值也可能为0，那是因为出线了指令重排</p>
<p>指令重排，是JIT编译器在运行时的一些优化</p>
<p>当使用jcstress进行压测的时候，虽然0的情况出现较少，但是也会出现0</p>
<p><strong>解决办法</strong></p>
<p>使用volatile修饰的变量，可以禁用指令重排</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Outcome(id = &#123;&quot;1&quot;, &quot;4&quot;&#125;, expect = Expect.ACCEPTABLE, desc = &quot;ok&quot;)</span></span><br><span class="line"><span class="meta">@Outcome(id = &quot;0&quot;, expect = Expect.ACCEPTABLE_INTERESTING, desc = &quot;!!!!&quot;)</span></span><br><span class="line"><span class="meta">@State</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcurrencyTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">ready</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Actor</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor1</span><span class="params">(I_Result r)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ready) &#123;</span><br><span class="line">            r.r1 = num + num;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r.r1 = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Actor</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor2</span><span class="params">(I_Result r)</span> &#123;</span><br><span class="line">        num = <span class="number">2</span>;</span><br><span class="line">        ready = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行过后发现没有0的情况</p>
<p><img src="/../images/JVM/69.png" alt="测试"></p>
<p><strong>有序性理解</strong></p>
<p>同一个线程内，JVM在不会影响正确性的前提下，可以调整语句的执行顺序，思考下面代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> i;</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> j;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在某个线程内执行如下赋值操作</span></span><br><span class="line">i = ...;<span class="comment">//较为耗时的操作</span></span><br><span class="line">j = ...;</span><br></pre></td></tr></table></figure>

<p>可以看到，至于是i先执行还是j先执行，都不会对最终结果产生影响。所以执行有两种情况，i先执行；i后执行</p>
<p>这种特性称为【指令重排】，多线程下【指令重排】会影响正确性，例如著名的double-checked locking模式实现的单例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//实例没创建，才会进入内部的synchronized代码块</span></span><br><span class="line">        <span class="keyword">if</span>(INSTANCE == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class)&#123;</span><br><span class="line">                <span class="comment">//也许有其它线程已经创建实例，所以再判断一次</span></span><br><span class="line">                <span class="keyword">if</span>(INSTANCE == <span class="literal">null</span>)&#123;</span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上的实现特点是：</p>
<ul>
<li>懒惰实例化</li>
<li>首次使用getInstance()才使用synchronized加锁，后续使用时无需加锁</li>
</ul>
<p>但是在多线程环境下，上面的代码是有问题的，Instance &#x3D; new Singleton()对应的字节码为：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:new			#<span class="number">2</span>			//class cn/itcast/jvm/t4/Singleton</span><br><span class="line"><span class="number">3</span>:dup</span><br><span class="line"><span class="number">4</span>:invokespecial #<span class="number">3</span>			//Method&quot;&lt;init&gt;&quot;:（)V</span><br><span class="line"><span class="number">7</span>:putstatic		#<span class="number">4</span>			//Field INSTANCE:Lcn/itcast/jvm/t4/Singleton;</span><br></pre></td></tr></table></figure>

<p>其中4和7两步的顺序是不固定的，也许是jvm优化：先将引用地址赋值给INSTANCE变量后，在执行构造方法，如果两个线程t1、t2按如下时间序列执行：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">时间<span class="number">1</span>		t1	线程执行到	INSTANCE=newSingleton(）;</span><br><span class="line">时间<span class="number">2</span>		t1	线程分配空间，为Singleton对象生成了引用地址（<span class="number">0</span>处）</span><br><span class="line">时间<span class="number">3</span>		t1	线程将引I用地址赋值给INSTANCE，这时INSTANCE！=nu11（<span class="number">7</span>处）</span><br><span class="line">时间<span class="number">4</span>		t2	线程进入getInstance（）方法，发现INSTANCE！=nul1（synchronized块外），直接返回</span><br><span class="line">INSTANCE</span><br><span class="line">时间<span class="number">5</span>		t1	线程执行Singleton的构造方法（<span class="number">4</span>处）</span><br></pre></td></tr></table></figure>

<p>这时t1还未完全将构造方法执行完毕时，如果在构造方法中要执行很多初始化操作，那么t2拿到的将是一个未初始化完毕的单例</p>
<p>对INSTANCE使用volatile修饰即可，可以禁用指令重排，但是要注意在JDK 5以上的版本的volatile才会真正有效</p>
<h2 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h2><p>happens-before规定了哪些写操作对其它线程的读操作可见，它是可见性与有序性的一套规则总结</p>
<ul>
<li>线程对volatile变量的写，对接下来其它线程对该变量的读可见</li>
<li>线程解锁m之前对变量的写，对于接下来对m加锁的其它线程对该变量的读可见</li>
<li>线程结束前对变量的写，对其他线程得知它结束后的读可见（比如其它线程调用t1.isAlive()或t1.join()等待它结束）</li>
<li>对变量默认值（0，false，null）的写，对其它线程对该变量的读可见</li>
</ul>
<h1 id="CAS与原子类"><a href="#CAS与原子类" class="headerlink" title="CAS与原子类"></a>CAS与原子类</h1><h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p>CAS即Compare and Swap，它体现的是一种乐观锁的思想，比如有多个线程要对一个共享的整型变量执行+1操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//需要不断尝试</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>）&#123;</span><br><span class="line">   	 	<span class="type">int</span>	旧值=共享变量；<span class="comment">//比如拿到了当前值0</span></span><br><span class="line">        <span class="type">int</span>	结果=旧值+<span class="number">1</span>；<span class="comment">//在旧值0的基础上增加1，正确结果是1</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        这时候如果别的线程把共享变量改成了5，本线程的正确结果1就作废了，这时候</span></span><br><span class="line"><span class="comment">        compareAndSwap返回false，重新尝试，直到：</span></span><br><span class="line"><span class="comment">        compareAndSwap返回true，表示我本线程做修改的同时，别的线程没有干扰</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span>(compareAndSwap(旧值，结果)&#123;</span><br><span class="line">        <span class="comment">//成功，退出循环</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取共享变量的时，为了保证该变量的可见性，需要使用volatile修饰。结合CAS和volatile可以实现无锁并发，适用于竞争不激烈、多核CPU的场景下。</p>
<ul>
<li>因为没有使用synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一</li>
<li>但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响</li>
</ul>
<p>CAS底层依赖于一个Unsafe类来直接调用操作系统底层的CAS指令</p>
<h2 id="乐观锁与悲观锁"><a href="#乐观锁与悲观锁" class="headerlink" title="乐观锁与悲观锁"></a>乐观锁与悲观锁</h2><ul>
<li>CAS是基于乐观锁的思想：最乐观的估计，不怕别的线程来修改共享变量，就算修改了也没关系，我吃亏点在进行重试</li>
<li>synchronized是基于悲观锁的思想：最悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想改，我改完了解开锁，你们才有机会</li>
</ul>
<h2 id="原子操作类"><a href="#原子操作类" class="headerlink" title="原子操作类"></a>原子操作类</h2><p>juc（java.util.concurrent）中提供了原子操作类，可以提供线程安全的操作，例如：AtomicInteger、AtomicBoolean等，它们底层就是采用CAS技术+volatile来实现的</p>
<p>可以使用AtomicInteger改写之前的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo4_4</span> &#123;</span><br><span class="line">    <span class="comment">// 创建原子整数对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">5000</span>; j++) &#123;</span><br><span class="line">                i.getAndIncrement();  <span class="comment">// 获取并且自增  i++</span></span><br><span class="line">                <span class="comment">//i.incrementAndGet();  // 自增并且获取  ++i</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">5000</span>; j++) &#123;</span><br><span class="line">                i.getAndDecrement(); <span class="comment">// 获取并且自减  i--</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="synchronized优化"><a href="#synchronized优化" class="headerlink" title="synchronized优化"></a>synchronized优化</h1><p>Java HotSpot虚拟机中，每个对象都有对象头（包括class指针和Mark Word）。Mark Word平时存储这个对象的<code>哈希码、分代年龄</code>，当加锁时，这些信息就根据情况被替换为<code>标记位、线程锁记录指针、重量级锁指针、线程ID</code>等内容</p>
<h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><p>如果一个线程虽然有很多线程访问，但多线程访问的时间是错开的（也就是没有竞争），那么可以使用轻量级锁来优化</p>
<p>每个线程的栈帧都会包含一个锁记录的结构，内部可以存储锁定对象的Mark Word</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line">        <span class="comment">//同步块A</span></span><br><span class="line">        method2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line">        <span class="comment">//同步块B</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th align="center">线程1</th>
<th align="center">对象Mark Word</th>
<th align="center">线程2</th>
</tr>
</thead>
<tbody><tr>
<td align="center">访问同步块A，把Mark复制到线程1的锁记录</td>
<td align="center">01（无锁）</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">CAS修改Mark为线程1锁记录地址</td>
<td align="center">01（无锁）</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">成功（加锁）</td>
<td align="center">00（轻量锁）线程1锁记录地址</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">执行同步块A</td>
<td align="center">00（轻量锁）线程1锁记录地址</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">访问同步块B，把Mark复制到线程1的锁记录</td>
<td align="center">00（轻量锁）线程1锁记录地址</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">CAS修改Mark为线程1锁记录地址</td>
<td align="center">00（轻量锁）线程1锁记录地址</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">失败（发现是自己的锁）</td>
<td align="center">00（轻量锁）线程1锁记录地址</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">锁重入</td>
<td align="center">00（轻量锁）线程1锁记录地址</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">执行同步块B</td>
<td align="center">00（轻量锁）线程1锁记录地址</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">同步块B执行完毕</td>
<td align="center">00（轻量锁）线程1锁记录地址</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">同步块A执行完毕</td>
<td align="center">00（轻量锁）线程1锁记录地址</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">成功（解锁）</td>
<td align="center">01（无锁）</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">01（无锁）</td>
<td align="center">访问同步块A，把Mark复制到线程2的锁记录</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">01（无锁）</td>
<td align="center">CAS修改Mark为线程2锁记录</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">00（轻量锁）线程2锁记录地址</td>
<td align="center">成功（加锁）</td>
</tr>
<tr>
<td align="center">。。。</td>
<td align="center">。。。</td>
<td align="center">。。。</td>
</tr>
</tbody></table>
<h2 id="锁膨胀"><a href="#锁膨胀" class="headerlink" title="锁膨胀"></a>锁膨胀</h2><p> 如果在尝试加轻量级锁的过程中，CAS操作无法成功，这时一种情况就是有其它线程为此对象加上了轻量级锁（有竞争），这时需要进行锁膨胀，将轻量级锁变为重量级锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line">        <span class="comment">//同步块</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">线程1</th>
<th align="center">对象Mark</th>
<th align="center">线程2</th>
</tr>
</thead>
<tbody><tr>
<td align="center">访问同步块，把Mark复制到线程1的锁记录</td>
<td align="center">01（无锁）</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">CAS修改Mark为线程1锁记录地址</td>
<td align="center">01（无锁）</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">成功（加锁）</td>
<td align="center">00（轻量锁）线程1锁记录地址</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">执行同步块</td>
<td align="center">00（轻量锁）线程1锁记录地址</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">执行同步块</td>
<td align="center">00（轻量锁）线程1锁记录地址</td>
<td align="center">访问同步块，把Mark复制到线程2</td>
</tr>
<tr>
<td align="center">执行同步块</td>
<td align="center">00（轻量锁）线程1锁记录地址</td>
<td align="center">CAS修改Mark为线程2锁记录地址</td>
</tr>
<tr>
<td align="center">执行同步块</td>
<td align="center">00（轻量锁）线程1锁记录地址</td>
<td align="center">失败（发现别人已经占了锁）</td>
</tr>
<tr>
<td align="center">执行同步块</td>
<td align="center">00（轻量锁）线程1锁记录地址</td>
<td align="center">CAS修改Mark为重量锁</td>
</tr>
<tr>
<td align="center">执行同步块</td>
<td align="center">10（重量锁）重量锁指针</td>
<td align="center">阻塞中</td>
</tr>
<tr>
<td align="center">执行完毕</td>
<td align="center">10（重量锁）重量锁指针</td>
<td align="center">阻塞中</td>
</tr>
<tr>
<td align="center">失败（解锁）</td>
<td align="center">10（重量锁）重量锁指针</td>
<td align="center">阻塞中</td>
</tr>
<tr>
<td align="center">释放重量锁，唤起阻塞线程竞争</td>
<td align="center">10（重量锁）</td>
<td align="center">阻塞中</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">10（重量锁）</td>
<td align="center">竞争重量锁</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">10（重量锁）</td>
<td align="center">成功（加锁）</td>
</tr>
<tr>
<td align="center">。。。</td>
<td align="center">。。。</td>
<td align="center">。。。</td>
</tr>
</tbody></table>
<h2 id="重量锁"><a href="#重量锁" class="headerlink" title="重量锁"></a>重量锁</h2><p>重量级锁竞争的时候，还可以使用自旋来进行优化，如果当前线程自旋成功（即这时候持锁线程已经退出了同步块，释放了锁），这时当前线程就可以避免阻塞</p>
<p>在Java6之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次；反之，就少自旋甚至不自旋，总之，比较智能</p>
<ul>
<li>自旋会占用CPU时间，单核CPU自旋就是浪费，多核CPU自旋才能发挥优势</li>
<li>java7之后不能控制是否开启自旋功能</li>
</ul>
<p>自旋重试成功的情况：</p>
<table>
<thead>
<tr>
<th align="center">线程1（cpu1上）</th>
<th align="center">对象Mark</th>
<th align="center">线程2（cpu2上）</th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center">10（重量锁）</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">访问同步块，获取monitor</td>
<td align="center">10（重量锁）重量锁指针</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">成功（加锁）</td>
<td align="center">10（重量锁）重量锁指针</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">执行同步块</td>
<td align="center">10（重量锁）重量锁指针</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">执行同步块</td>
<td align="center">10（重量锁）重量锁指针</td>
<td align="center">访问同步块，获取monitor</td>
</tr>
<tr>
<td align="center">执行同步块</td>
<td align="center">10（重量锁）重量锁指针</td>
<td align="center">自旋重试</td>
</tr>
<tr>
<td align="center">执行完毕</td>
<td align="center">10（重量锁）重量锁指针</td>
<td align="center">自旋重试</td>
</tr>
<tr>
<td align="center">成功（解锁）</td>
<td align="center">01（无锁）</td>
<td align="center">自旋重试</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">10（重量锁）重量锁指针</td>
<td align="center">成功（加锁）</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">10（重量锁）重量锁指针</td>
<td align="center">执行同步块</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">。。。</td>
<td align="center">。。。</td>
</tr>
</tbody></table>
<p>自旋重试失败的情况：</p>
<table>
<thead>
<tr>
<th align="center">线程1（cpu1上）</th>
<th align="center">对象Mark</th>
<th align="center">线程2（cpu2上）</th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center">10（重量锁）</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">访问同步块，获取monitor</td>
<td align="center">10（重量锁）重量锁指针</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">成功（加锁）</td>
<td align="center">10（重量锁）重量锁指针</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">执行同步块</td>
<td align="center">10（重量锁）重量锁指针</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">执行同步块</td>
<td align="center">10（重量锁）重量锁指针</td>
<td align="center">访问同步块，获取monitor</td>
</tr>
<tr>
<td align="center">执行同步块</td>
<td align="center">10（重量锁）重量锁指针</td>
<td align="center">自旋重试</td>
</tr>
<tr>
<td align="center">执行同步块</td>
<td align="center">10（重量锁）重量锁指针</td>
<td align="center">自旋重试</td>
</tr>
<tr>
<td align="center">执行同步块</td>
<td align="center">10（重量锁）重量锁指针</td>
<td align="center">自旋重试</td>
</tr>
<tr>
<td align="center">执行同步块</td>
<td align="center">10（重量锁）重量锁指针</td>
<td align="center">阻塞</td>
</tr>
</tbody></table>
<h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><p>轻量级锁在没有竞争时（就自己这个线程），每次重入仍然需要执行CAS操作。Java6中引入了偏向锁来做进一步优化：只有第一次使用CAS将线程ID设置到对象的Mark Word头，之后发现这个线程ID是自己的就表示没有竞争，不用重新CAS</p>
<ul>
<li>撤销偏向需要将持锁线程升级为轻量级锁，这个过程中所有线程需要暂停（STW）</li>
<li>访问这个对象的hashCode也会撤销偏向锁</li>
<li>如果对象虽然被多个线程访问，但没有竞争，这是偏向了线程T1的对象仍有机会重新偏向T2，重偏向会重置对象的ThreadID</li>
<li>撤销偏向和重偏向都是批量进行的，以类为单位</li>
<li>如果撤销偏向到达某个阈值，整个类的所有对象都会变为不可偏向</li>
<li>可以主动使用-XX:-UseBiasedLocking禁用偏向锁</li>
</ul>
<h2 id="其它优化"><a href="#其它优化" class="headerlink" title="其它优化"></a>其它优化</h2><ol>
<li><strong>减少上锁时间</strong></li>
</ol>
<p>同步代码块中尽量短</p>
<ol start="2">
<li><strong>减少锁的粒度</strong></li>
</ol>
<p>将一个锁拆分为多个锁提高并发度，例如：</p>
<ul>
<li>ConcurrentHashMap</li>
<li>LongAdder分为base和cells两部分。没有并发争用的时候或者是cells数组正在初始化的时候，会使用CAS来累加值到base，有并发争用，会初始化cells数组，数组中有多少个cell，就允许有多少个线程并行修改，最后将数组中每个cell累加，再加上base就是最终的值</li>
<li>LinkedBlockingQueue入队和出队使用不同的锁，相对于LinkedBlockingArray只有一个锁效率高</li>
</ul>
<ol start="3">
<li><strong>锁粗化</strong></li>
</ol>
<p>多次循环进入同步块不如同步块内多次循环</p>
<p>另外JVM可能会做如下优化，把多次append的加锁操作粗化为一次（因为都是对同一个对象加锁，没必要重入多次）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">StringBuffer</span>().append(<span class="string">&quot;a&quot;</span>).append(<span class="string">&quot;b&quot;</span>).append(<span class="string">&quot;c&quot;</span>)</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><strong>锁消除</strong></li>
</ol>
<p>JVM会进行代码的逃逸分析，例如某个加锁对象是方法内局部变量，不会被其它线程所访问到，这时候就会被即时编译器忽略掉所有同步操作</p>
<ol start="5">
<li><strong>读写分离</strong></li>
</ol>
<p>CopyOnWriteArrayList</p>
<p>CopyOnWriteSet</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="http://example.com">John Doe</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="http://example.com/2025/03/19/JVM/">http://example.com/2025/03/19/JVM/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/04/18/Java-NIO-Netty/" title="Java NIO Netty"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Previous</div><div class="prev_info">Java NIO Netty</div></div></a></div><div class="next-post pull-right"><a href="/2025/03/09/%E9%9D%A2%E8%AF%95%E9%A2%98/" title="面试题"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Next</div><div class="next_info">面试题</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">John Doe</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">12</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text">内存结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-number">2.1.</span> <span class="toc-text">程序计数器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88"><span class="toc-number">2.2.</span> <span class="toc-text">虚拟机栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88"><span class="toc-number">2.3.</span> <span class="toc-text">本地方法栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86"><span class="toc-number">2.4.</span> <span class="toc-text">堆</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="toc-number">2.5.</span> <span class="toc-text">方法区</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="toc-number">2.5.1.</span> <span class="toc-text">运行时常量池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#StringTable"><span class="toc-number">2.5.2.</span> <span class="toc-text">StringTable</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#StringTable%E7%89%B9%E6%80%A7"><span class="toc-number">2.5.3.</span> <span class="toc-text">StringTable特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-8"><span class="toc-number">2.5.3.1.</span> <span class="toc-text">1.8</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-6"><span class="toc-number">2.5.3.2.</span> <span class="toc-text">1.6</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#StringTable%E4%BD%8D%E7%BD%AE"><span class="toc-number">2.5.4.</span> <span class="toc-text">StringTable位置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-8-1"><span class="toc-number">2.5.4.1.</span> <span class="toc-text">1.8</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-6-1"><span class="toc-number">2.5.4.2.</span> <span class="toc-text">1.6</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#StringTable%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">2.5.5.</span> <span class="toc-text">StringTable垃圾回收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#StringTable%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98"><span class="toc-number">2.5.6.</span> <span class="toc-text">StringTable性能调优</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98"><span class="toc-number">2.6.</span> <span class="toc-text">直接内存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA"><span class="toc-number">2.6.1.</span> <span class="toc-text">直接内存溢出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E9%85%8D%E5%92%8C%E5%9B%9E%E6%94%B6%E5%8E%9F%E7%90%86"><span class="toc-number">2.6.2.</span> <span class="toc-text">分配和回收原理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">3.</span> <span class="toc-text">垃圾回收</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E5%8F%AF%E4%BB%A5%E5%9B%9E%E6%94%B6"><span class="toc-number">3.1.</span> <span class="toc-text">如何判断对象可以回收</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95"><span class="toc-number">3.1.1.</span> <span class="toc-text">引用计数法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95"><span class="toc-number">3.1.2.</span> <span class="toc-text">可达性分析算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8"><span class="toc-number">3.1.3.</span> <span class="toc-text">四种引用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E5%BC%95%E7%94%A8%E5%BA%94%E7%94%A8"><span class="toc-number">3.1.3.1.</span> <span class="toc-text">软引用应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%B1%E5%BC%95%E7%94%A8%E5%BA%94%E7%94%A8"><span class="toc-number">3.1.3.2.</span> <span class="toc-text">弱引用应用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="toc-number">3.2.</span> <span class="toc-text">垃圾回收算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4"><span class="toc-number">3.2.1.</span> <span class="toc-text">标记清除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86"><span class="toc-number">3.2.2.</span> <span class="toc-text">标记整理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6"><span class="toc-number">3.2.3.</span> <span class="toc-text">复制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E4%BB%A3%E5%9B%9E%E6%94%B6"><span class="toc-number">3.3.</span> <span class="toc-text">分代回收</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#GC%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90"><span class="toc-number">3.3.1.</span> <span class="toc-text">GC案例分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-number">3.4.</span> <span class="toc-text">垃圾回收器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B2%E8%A1%8C"><span class="toc-number">3.4.1.</span> <span class="toc-text">串行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%9E%E5%90%90%E9%87%8F%E4%BC%98%E5%85%88"><span class="toc-number">3.4.2.</span> <span class="toc-text">吞吐量优先</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88"><span class="toc-number">3.4.3.</span> <span class="toc-text">响应时间优先</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#G1"><span class="toc-number">3.4.4.</span> <span class="toc-text">G1</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E9%98%B6%E6%AE%B5"><span class="toc-number">3.4.4.1.</span> <span class="toc-text">垃圾回收阶段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Young-Collection"><span class="toc-number">3.4.4.2.</span> <span class="toc-text">Young Collection</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Young-Collection%E8%B7%A8%E4%BB%A3%E5%BC%95%E7%94%A8"><span class="toc-number">3.4.4.3.</span> <span class="toc-text">Young Collection跨代引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Young-Collection-CM"><span class="toc-number">3.4.4.4.</span> <span class="toc-text">Young Collection+CM</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Remark-SATB"><span class="toc-number">3.4.4.5.</span> <span class="toc-text">Remark-SATB</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Mixed-Collection"><span class="toc-number">3.4.4.6.</span> <span class="toc-text">Mixed Collection</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Full-GC"><span class="toc-number">3.4.4.7.</span> <span class="toc-text">Full GC</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E4%BC%98%E5%8C%96"><span class="toc-number">3.4.5.</span> <span class="toc-text">G1垃圾回收优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK-8u20%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%BB%E9%87%8D"><span class="toc-number">3.4.5.1.</span> <span class="toc-text">JDK 8u20字符串去重</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK-8u40%E5%B9%B6%E5%8F%91%E5%8D%B8%E8%BD%BD"><span class="toc-number">3.4.5.2.</span> <span class="toc-text">JDK 8u40并发卸载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK-8u60%E5%9B%9E%E6%94%B6%E5%B7%A8%E5%9E%8B%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.4.5.3.</span> <span class="toc-text">JDK 8u60回收巨型对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK-9%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0%E8%B5%B7%E5%A7%8B%E6%97%B6%E9%97%B4%E7%9A%84%E8%B0%83%E6%95%B4"><span class="toc-number">3.4.5.4.</span> <span class="toc-text">JDK 9并发标记起始时间的调整</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E8%B0%83%E4%BC%98"><span class="toc-number">3.4.6.</span> <span class="toc-text">垃圾回收调优</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AE%E8%AE%A4%E7%9B%AE%E6%A0%87"><span class="toc-number">3.4.6.1.</span> <span class="toc-text">确认目标</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%BF%AB%E7%9A%84GC%E6%98%AF%E4%B8%8D%E5%8F%91%E7%94%9FGC"><span class="toc-number">3.4.6.2.</span> <span class="toc-text">最快的GC是不发生GC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B0%E7%94%9F%E4%BB%A3%E8%B0%83%E4%BC%98"><span class="toc-number">3.4.6.3.</span> <span class="toc-text">新生代调优</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B0%E7%94%9F%E4%BB%A3%E5%86%85%E5%AD%98%E8%B6%8A%E5%A4%A7%E8%B6%8A%E5%A5%BD%E5%90%97%EF%BC%9F"><span class="toc-number">3.4.6.4.</span> <span class="toc-text">新生代内存越大越好吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%80%81%E5%B9%B4%E4%BB%A3%E8%B0%83%E4%BC%98"><span class="toc-number">3.4.6.5.</span> <span class="toc-text">老年代调优</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GC%E8%B0%83%E4%BC%98%E6%A1%88%E4%BE%8B"><span class="toc-number">3.4.6.6.</span> <span class="toc-text">GC调优案例</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%AD%97%E8%8A%82%E7%A0%81%E6%8A%80%E6%9C%AF"><span class="toc-number">4.</span> <span class="toc-text">类加载与字节码技术</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-number">4.1.</span> <span class="toc-text">类文件结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E8%A7%A3%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">4.2.</span> <span class="toc-text">图解方法执行流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0-%E5%88%86%E6%9E%90i"><span class="toc-number">4.3.</span> <span class="toc-text">练习-分析i++</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E5%88%86%E6%9E%90%E9%97%AE%E9%A2%98"><span class="toc-number">4.4.</span> <span class="toc-text">通过字节码指令分析问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">4.5.</span> <span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8"><span class="toc-number">4.6.</span> <span class="toc-text">方法调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E5%8E%9F%E7%90%86"><span class="toc-number">4.7.</span> <span class="toc-text">多态原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">4.8.</span> <span class="toc-text">异常处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Synchronized"><span class="toc-number">4.9.</span> <span class="toc-text">Synchronized</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E6%9C%9F%E5%A4%84%E7%90%86"><span class="toc-number">5.</span> <span class="toc-text">编译期处理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">5.1.</span> <span class="toc-text">默认构造器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1"><span class="toc-number">5.2.</span> <span class="toc-text">自动拆装箱</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E9%9B%86%E5%90%88%E5%8F%96%E5%80%BC"><span class="toc-number">5.3.</span> <span class="toc-text">泛型集合取值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0"><span class="toc-number">5.4.</span> <span class="toc-text">可变参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#foreach%E5%BE%AA%E7%8E%AF"><span class="toc-number">5.5.</span> <span class="toc-text">foreach循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#switch%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">5.6.</span> <span class="toc-text">switch字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#switch%E6%9E%9A%E4%B8%BE"><span class="toc-number">5.7.</span> <span class="toc-text">switch枚举</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB"><span class="toc-number">5.8.</span> <span class="toc-text">枚举类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#try-with-resources"><span class="toc-number">5.9.</span> <span class="toc-text">try-with-resources</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99%E6%97%B6%E7%9A%84%E6%A1%A5%E6%8E%A5%E6%96%B9%E6%B3%95"><span class="toc-number">5.10.</span> <span class="toc-text">方法重写时的桥接方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">5.11.</span> <span class="toc-text">匿名内部类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E9%98%B6%E6%AE%B5"><span class="toc-number">6.</span> <span class="toc-text">类加载阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD"><span class="toc-number">6.1.</span> <span class="toc-text">加载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5"><span class="toc-number">6.2.</span> <span class="toc-text">链接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">6.3.</span> <span class="toc-text">初始化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">7.</span> <span class="toc-text">类加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">7.1.</span> <span class="toc-text">启动类的加载器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">7.2.</span> <span class="toc-text">扩展类的加载器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%BC%8F"><span class="toc-number">7.3.</span> <span class="toc-text">双亲委派模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">7.4.</span> <span class="toc-text">自定义类加载器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%9C%9F%E4%BC%98%E5%8C%96"><span class="toc-number">8.</span> <span class="toc-text">运行期优化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91"><span class="toc-number">8.1.</span> <span class="toc-text">即时编译</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B1%82%E7%BC%96%E8%AF%91"><span class="toc-number">8.1.1.</span> <span class="toc-text">分层编译</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%86%85%E8%81%94"><span class="toc-number">8.1.2.</span> <span class="toc-text">方法内联</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E4%BC%98%E5%8C%96"><span class="toc-number">8.2.</span> <span class="toc-text">反射优化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-number">9.</span> <span class="toc-text">内存模型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-number">9.1.</span> <span class="toc-text">java内存模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-number">9.2.</span> <span class="toc-text">原子性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-number">9.3.</span> <span class="toc-text">可见性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E6%80%A7"><span class="toc-number">9.4.</span> <span class="toc-text">有序性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#happens-before"><span class="toc-number">9.5.</span> <span class="toc-text">happens-before</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CAS%E4%B8%8E%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="toc-number">10.</span> <span class="toc-text">CAS与原子类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#CAS"><span class="toc-number">10.1.</span> <span class="toc-text">CAS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%E4%B8%8E%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-number">10.2.</span> <span class="toc-text">乐观锁与悲观锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BB"><span class="toc-number">10.3.</span> <span class="toc-text">原子操作类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#synchronized%E4%BC%98%E5%8C%96"><span class="toc-number">11.</span> <span class="toc-text">synchronized优化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81"><span class="toc-number">11.1.</span> <span class="toc-text">轻量级锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E8%86%A8%E8%83%80"><span class="toc-number">11.2.</span> <span class="toc-text">锁膨胀</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E9%87%8F%E9%94%81"><span class="toc-number">11.3.</span> <span class="toc-text">重量锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%81%8F%E5%90%91%E9%94%81"><span class="toc-number">11.4.</span> <span class="toc-text">偏向锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E5%AE%83%E4%BC%98%E5%8C%96"><span class="toc-number">11.5.</span> <span class="toc-text">其它优化</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/18/Java-NIO-Netty/" title="Java NIO Netty">Java NIO Netty</a><time datetime="2025-04-18T03:43:38.000Z" title="Created 2025-04-18 11:43:38">2025-04-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/19/JVM/" title="JVM">JVM</a><time datetime="2025-03-19T08:33:04.000Z" title="Created 2025-03-19 16:33:04">2025-03-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/09/%E9%9D%A2%E8%AF%95%E9%A2%98/" title="面试题">面试题</a><time datetime="2025-03-09T12:34:53.000Z" title="Created 2025-03-09 20:34:53">2025-03-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/03/Docker/" title="Docker">Docker</a><time datetime="2025-02-03T05:36:13.000Z" title="Created 2025-02-03 13:36:13">2025-02-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/21/RabbitMQ/" title="RabbitMQ">RabbitMQ</a><time datetime="2025-01-21T01:55:08.000Z" title="Created 2025-01-21 09:55:08">2025-01-21</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By John Doe</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>