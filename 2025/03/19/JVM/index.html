<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>JVM | Hexo</title><meta name="author" content="John Doe"><meta name="copyright" content="John Doe"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="概念定义：Java Virtual Machine - java程序运行环境（java二进制字节码的运行环境） 好处：  一次编写，到处运行 自动内存管理，垃圾回收功能 数组下标越界检查 多态  JVM JRE JDK三者关系：  内存结构程序计数器Program Counter Register程序计数器（寄存器） 作用 记住下一条jvm指令的执行地址，解释器读取二进制字节码转换为机器码 特点">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM">
<meta property="og:url" content="http://example.com/2025/03/19/JVM/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="概念定义：Java Virtual Machine - java程序运行环境（java二进制字节码的运行环境） 好处：  一次编写，到处运行 自动内存管理，垃圾回收功能 数组下标越界检查 多态  JVM JRE JDK三者关系：  内存结构程序计数器Program Counter Register程序计数器（寄存器） 作用 记住下一条jvm指令的执行地址，解释器读取二进制字节码转换为机器码 特点">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2025-03-19T08:33:04.000Z">
<meta property="article:modified_time" content="2025-03-29T03:52:44.643Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2025/03/19/JVM/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Error',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JVM',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-03-29 11:52:44'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><hr class="custom-hr"/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Hexo"><span class="site-name">Hexo</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">JVM</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2025-03-19T08:33:04.000Z" title="Created 2025-03-19 16:33:04">2025-03-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-03-29T03:52:44.643Z" title="Updated 2025-03-29 11:52:44">2025-03-29</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="JVM"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>定义：Java Virtual Machine - java程序运行环境（java二进制字节码的运行环境）</p>
<p>好处：</p>
<ul>
<li>一次编写，到处运行</li>
<li>自动内存管理，垃圾回收功能</li>
<li>数组下标越界检查</li>
<li>多态</li>
</ul>
<p>JVM JRE JDK三者关系：</p>
<p><img src="/../images/JVM/1.png" alt="三者关系"></p>
<h1 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h1><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>Program Counter Register程序计数器（寄存器）</p>
<p><strong>作用</strong></p>
<p>记住下一条jvm指令的执行地址，解释器读取二进制字节码转换为机器码</p>
<p><strong>特点</strong></p>
<ul>
<li>线程私有的，属于单个线程</li>
<li>不会存在内存溢出</li>
</ul>
<h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><p>栈：线程运行需要的内存空间</p>
<p>栈帧：每个方法运行时需要的内存（参数、局部变量、返回地址）</p>
<p>Java Virtual Machine Stacks（Java虚拟机栈）</p>
<ul>
<li>每个线程运行时所需要的内存，称为虚拟机栈</li>
<li>每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存</li>
<li>每个线程只能有一个活动栈帧，对应着当前正在执行的哪个方法</li>
</ul>
<ol>
<li>垃圾回收是否涉及栈内存？</li>
</ol>
<p>不涉及</p>
<ol start="2">
<li>栈内存分配越大越好吗？</li>
</ol>
<p>不是，物理地址大小一定，当栈内存越大会导致单个线程内存变大，从而导致线程数目变少，影响并发执行效率</p>
<ol start="3">
<li>方法内的局部变量是否是线程安全？</li>
</ol>
<ul>
<li>如果方法内局部变量没有逃离方法的作用范围，它是线程安全的</li>
<li>如果是局部变量引用了对象，并逃离方法的作用范围，需要考虑线程安全</li>
</ul>
<p><strong>栈内存溢出</strong></p>
<ul>
<li><p>栈帧过多导致栈内存溢出</p>
</li>
<li><p>栈帧过大导致栈内存溢出</p>
</li>
</ul>
<p>运行报错：java.lang.StackOverflowError栈内存溢出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1_2</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            method1();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">        method1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行报错，原因是出现类似于循环依赖问题（打印部门，部门里有员工，员工里有部门），解决方法，加上@JsonIgnore注解在Emp员工类上的dept属性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1_19</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> JsonProcessingException &#123;</span><br><span class="line">        <span class="type">Dept</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dept</span>();</span><br><span class="line">        d.setName(<span class="string">&quot;Market&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Emp</span> <span class="variable">e1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Emp</span>();</span><br><span class="line">        e1.setName(<span class="string">&quot;zhang&quot;</span>);</span><br><span class="line">        e1.setDept(d);</span><br><span class="line"></span><br><span class="line">        <span class="type">Emp</span> <span class="variable">e2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Emp</span>();</span><br><span class="line">        e2.setName(<span class="string">&quot;li&quot;</span>);</span><br><span class="line">        e2.setDept(d);</span><br><span class="line"></span><br><span class="line">        d.setEmps(Arrays.asList(e1, e2));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// &#123; name: &#x27;Market&#x27;, emps: [&#123; name:&#x27;zhang&#x27;, dept:&#123; name:&#x27;&#x27;, emps: [ &#123;&#125;]&#125; &#125;,] &#125;</span></span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        System.out.println(mapper.writeValueAsString(d));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Emp</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="keyword">private</span> Dept dept;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Dept <span class="title function_">getDept</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dept;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDept</span><span class="params">(Dept dept)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.dept = dept;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dept</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Emp&gt; emps;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Emp&gt; <span class="title function_">getEmps</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> emps;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setEmps</span><span class="params">(List&lt;Emp&gt; emps)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.emps = emps;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>线程运行诊断</strong></p>
<p>案例一：cpu占用过多</p>
<p>定位：</p>
<ul>
<li><p>用top定位哪个进程对cpu的占用过高</p>
</li>
<li><pre><code class="shell">#用ps命令进一步定位是哪个线程引起的cpu占用过高
ps H -eo pid,tid,%cpu | grep 进程id
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```shell</span><br><span class="line">  jstack 进程id</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>可以根据线程id找到有问题的线程，进一步定位到问题代码的源码行号</p>
</li>
</ul>
<p>案例二：程序运行很长时间没有结果</p>
<p>也可以利用jstack 进程id去排查问题</p>
<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>Native Method Stacks（本地方法栈）</p>
<p>由c&#x2F;c++实现的本地方法，java可以通过这些方法与底层操作系统进行交互。本地方法栈就是为本地方法的调用提供内存空间</p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>Heap（堆）</p>
<ul>
<li>通过new关键字，创建对象都会使用堆内存</li>
</ul>
<p>特点</p>
<ul>
<li>它是线程共享的，堆中对象都需要考虑线程安全的问题</li>
<li>有垃圾回收机制</li>
</ul>
<p><strong>堆内存溢出</strong></p>
<p>运行报错：java.lang.OutOfMemoryError: Java heap space（堆内存溢出）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1_5</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                list.add(a); <span class="comment">// hello, hellohello, hellohellohellohello ...</span></span><br><span class="line">                a = a + a;  <span class="comment">// hellohellohellohello</span></span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>堆内存诊断</strong></p>
<ol>
<li>jps工具（查看当前系统中有哪些java进程）</li>
<li>jmap工具（查看堆内存占用情况）</li>
</ol>
<ul>
<li><pre><code class="shell">jmap -heap 进程id
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3. jconsole工具（图形界面的，多功能的监测工具，可以连续监测）</span><br><span class="line"></span><br><span class="line">案例：垃圾回收后，内存占用仍然很高</span><br><span class="line"></span><br><span class="line">使用jvisualvm工具进行分析</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public class Demo1_13 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        List&lt;Student&gt; students = new ArrayList&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; 200; i++) &#123;</span><br><span class="line">            students.add(new Student());</span><br><span class="line">            //Student student = new Student();</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(1000000000L);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Student &#123;</span><br><span class="line">    private byte[] big = new byte[1024*1024];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p><strong>定义</strong></p>
<p>方法区是所有线程共享的内存，在java8以前是放在JVM内存中的，由永久代实现，受JVM内存大小参数的限制，在java8中移除了永久代的内容，方法区由元空间(Meta Space)实现，并直接放到了本地内存中，不受JVM参数的限制（当然，如果物理内存被占满了，方法区也会报OOM），并且将原来放在方法区的字符串常量池和静态变量都转移到了Java堆中</p>
<p><strong>组成</strong></p>
<p><strong>类元信息：</strong></p>
<ul>
<li>类元信息在类编译期间放入方法区，里面放置了类的基本信息，包括类的版本、字段、方法、接口以及常量池表（Constant Pool Table）</li>
<li>常量池表（Constant Pool Table）存储了类在编译期间生成的字面量、符号引用(什么是字面量？什么是符号引用？)，这些信息在类加载完后会被解析到运行时常量池中</li>
</ul>
<p> <strong>运行时常量池：</strong></p>
<ul>
<li>运行时常量池主要存放在类加载后被解析的字面量与符号引用，但不止这些</li>
<li>运行时常量池具备动态性，可以添加数据，比较多的使用就是String类的intern()方法</li>
</ul>
<p><strong>方法区内存溢出</strong></p>
<ul>
<li>1.8以前会导致永久代内存溢出（java.lang.OutOfMemoryError:PermGen space）</li>
<li>1.8以后会导致元空间内存溢出（java.lang.OutOfMemoryError:Metaspace）</li>
</ul>
<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><ul>
<li>常量池：就是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息</li>
<li>运行时常量池，常量池是*.class文件中的，当该类被加载，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址</li>
</ul>
<h3 id="StringTable"><a href="#StringTable" class="headerlink" title="StringTable"></a>StringTable</h3><p>面试题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s1 + s2;</span><br><span class="line"><span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s6</span> <span class="operator">=</span> s4.intern();</span><br><span class="line"></span><br><span class="line"><span class="comment">//问</span></span><br><span class="line">System.out.println(s3 == s4);</span><br><span class="line">System.out.println(s3 == s5);</span><br><span class="line">System.out.println(s3 == s6);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">x2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;c&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;d&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">x1</span> <span class="operator">=</span> <span class="string">&quot;cd&quot;</span>;</span><br><span class="line">x2.intern();</span><br><span class="line"></span><br><span class="line"><span class="comment">//问，如果调换了【最后两行代码】的位置呢，如果是jdk1.6呢</span></span><br><span class="line">System.out.println(x1 == x2);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StringTable [ &quot;a&quot;, &quot;b&quot; ,&quot;ab&quot; ]  hashtable 结构，不能扩容</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1_22</span> &#123;</span><br><span class="line">    <span class="comment">// 常量池中的信息，都会被加载到运行时常量池中， 这时 a b ab 都是常量池中的符号，还没有变为 java 字符串对象</span></span><br><span class="line">    <span class="comment">// ldc #2 会把 a 符号变为 &quot;a&quot; 字符串对象</span></span><br><span class="line">    <span class="comment">// ldc #3 会把 b 符号变为 &quot;b&quot; 字符串对象</span></span><br><span class="line">    <span class="comment">// ldc #4 会把 ab 符号变为 &quot;ab&quot; 字符串对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>; <span class="comment">// 懒惰的</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s1 + s2; <span class="comment">// new StringBuilder().append(&quot;a&quot;).append(&quot;b&quot;).toString()  new String(&quot;ab&quot;)</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span>;  <span class="comment">// javac 在编译期间的优化，结果已经在编译期确定为ab</span></span><br><span class="line"></span><br><span class="line">        System.out.println(s3 == s4);</span><br><span class="line">        System.out.println(s3 == s5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一个为false，第二个为true</p>
<p>s4为新生成的一个String对象，s5引用的是s3所指向对象的值</p>
<p>使用&#x3D;&#x3D;进行比较，比较的是指向对象的地址，所以第一个为false，第二个为true</p>
<p>而如果使用equals进行比较的话，两个都为true（原因是String对equals方法进行了重写，比较的是所指向对象的值）</p>
<p>而如果没有对equals方法进行重写的话比较的还是指向对象的内存地址（equals不能用于基本数据类型）</p>
<p>&#x3D;&#x3D;用于基本数据类型比较的是值，而用于引用数据类型比较的是两个对象的内存地址</p>
<h3 id="StringTable特性"><a href="#StringTable特性" class="headerlink" title="StringTable特性"></a>StringTable特性</h3><ul>
<li>常量池中的字符串仅是符号，第一次用到时才变对象</li>
<li>利用串池的机制，来避免重复创建字符串对象</li>
<li>字符串变量拼接的原理是StringBuilder（1.8）</li>
<li>字符串常量拼接的原理是编译器优化</li>
<li>可以使用intern方法，主动将串池中还没有的字符串对象放入串池<ul>
<li>1.8将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有则放入串池，会把串池中的对象返回</li>
<li>1.6将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有会把此对象复制一份，放入串池，会把串池中的对象返回</li>
</ul>
</li>
</ul>
<h4 id="1-8"><a href="#1-8" class="headerlink" title="1.8"></a>1.8</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1_23</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  [&quot;ab&quot;, &quot;a&quot;, &quot;b&quot;]</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">x</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="comment">//堆  new String(&quot;a&quot;)   new String(&quot;b&quot;) new String(&quot;ab&quot;)</span></span><br><span class="line">        <span class="comment">//将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有则放入串池，会把串池中的对象返回</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s.intern(); </span><br><span class="line"></span><br><span class="line">        System.out.println( s2 == x);</span><br><span class="line">        System.out.println( s == x );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会输出true，false</p>
<p>因为执行s.intern时此时串池中已经有了”ab”，所以不会放入，而是将串池中的”ab”返回给s2；这时s还是新创建的”ab”对象</p>
<p>s2的内存地址与x相同，而s的内存地址和x不相同</p>
<p>而如果是下面代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1_23</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  [&quot;a&quot;, &quot;b&quot;]</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="comment">//堆  new String(&quot;a&quot;)   new String(&quot;b&quot;) new String(&quot;ab&quot;)</span></span><br><span class="line">        <span class="comment">//将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有则放入串池，会把串池中的对象返回</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s.intern(); </span><br><span class="line"></span><br><span class="line">        System.out.println( s2 == <span class="string">&quot;ab&quot;</span>);</span><br><span class="line">        System.out.println( s == <span class="string">&quot;ab&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为true，true</p>
<p>因为原来串池中没有”ab”，这时候执行s.intern会将”ab”放入串池，这时候s与s2指向的都为串池中的”ab”内存地址</p>
<h4 id="1-6"><a href="#1-6" class="headerlink" title="1.6"></a>1.6</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1_23</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  [&quot;a&quot;, &quot;b&quot;]</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="comment">//堆  new String(&quot;a&quot;)   new String(&quot;b&quot;) new String(&quot;ab&quot;)</span></span><br><span class="line">        <span class="comment">//将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有会把此对象复制一份，放入串池，会把串池中的对象返回</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s.intern(); </span><br><span class="line"></span><br><span class="line">        System.out.println( s2 == <span class="string">&quot;ab&quot;</span>);</span><br><span class="line">        System.out.println( s == <span class="string">&quot;ab&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会输出true，false</p>
<p>因为1.6中在执行s.intern时如果串池没有则会将对象复制一份然后放入串池，将串池的对象返回。</p>
<p>执行s.intern，将s对象复制放入串池，这时s2指向的串池中的”ab”，而s还是新创建的”ab”对象，内存地址不同</p>
<p><strong>面试题</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1_21</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span>; <span class="comment">// ab</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s1 + s2;   <span class="comment">// new String(&quot;ab&quot;)</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s6</span> <span class="operator">=</span> s4.intern();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 问</span></span><br><span class="line">        System.out.println(s3 == s4);</span><br><span class="line">        System.out.println(s3 == s5);</span><br><span class="line">        System.out.println(s3 == s6);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">x2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;c&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;d&quot;</span>); <span class="comment">// new String(&quot;cd&quot;)</span></span><br><span class="line">        x2.intern();</span><br><span class="line">        <span class="type">String</span> <span class="variable">x1</span> <span class="operator">=</span> <span class="string">&quot;cd&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        System.out.println(x1 == x2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为false true true true</p>
<p>如果为1.6，则为false true true false</p>
<h3 id="StringTable位置"><a href="#StringTable位置" class="headerlink" title="StringTable位置"></a>StringTable位置</h3><h4 id="1-8-1"><a href="#1-8-1" class="headerlink" title="1.8"></a>1.8</h4><p>配置参数-Xmx10m -XX:-UseGCOverheadLimit</p>
<p>运行时报错：java.lang.OutOfMemoryError: Java heap space（堆内存溢出）</p>
<p>可以看出在1.8中StringTable在堆内存中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1_6</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">260000</span>; j++) &#123;</span><br><span class="line">                list.add(String.valueOf(j).intern());</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-6-1"><a href="#1-6-1" class="headerlink" title="1.6"></a>1.6</h4><p>配置参数-XX:MaxPermSize&#x3D;10m</p>
<p>运行时报错：java.lang.OutOfMemoryError:PermGen space（永久代内存溢出）</p>
<p>可以看出在1.6中StringTable在永久代内存中</p>
<h3 id="StringTable垃圾回收"><a href="#StringTable垃圾回收" class="headerlink" title="StringTable垃圾回收"></a>StringTable垃圾回收</h3><p>许多大规模的Java应用的瓶颈在于内存，测试表明，在这些类型的应用里面，Java堆中存活的数据集合差不多25%是String对象。更进一步，这里面差不多一半string对象是重复的，重复的意思是说： <code>stringl.equals(string2)= true</code>。堆上存在重复的String对象必然是一种内存的浪费。这个项目将在G1垃圾收集器中实现自动持续对重复的string对象进行去重，这样就能避免浪费内存。</p>
<p>注意这里说的重复，指的是在堆中的数据，而不是常量池中的，因为常量池中的本身就不会重复</p>
<h3 id="StringTable性能调优"><a href="#StringTable性能调优" class="headerlink" title="StringTable性能调优"></a>StringTable性能调优</h3><p>StringTable是靠我们的HashTable来实现的。即当我们的空间足够大的时候，我们的数据就会比较分散，查询的效率也会因此降低，反之，当我们的空间比较小的时候，我们的数据就会比较集中，查询的效率也会因此提高。<strong>当然了，StringTable的空间大小并不是越小越好，太小了，一直进行垃圾回收，导致经常要删除老数据，添加新的数据等问题也很难受。要是那些个老数据刚删掉没多久就要用到了呢</strong></p>
<p>如果程序涉及到的字符串足够多的情况下，那么可以适当调大StringTable的桶的大小，优化性能</p>
<p>当我们的系统数据会出现重复字符串的情况下，我们可以让我们对应的字符串对象入池，来减少内存的占用</p>
<h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><p>Direct Memory</p>
<ul>
<li>常见于NIO操作时，用于数据缓冲区</li>
<li>分配回收成本较高，但读写性能好</li>
<li>不受JVM内存回收管理</li>
</ul>
<p>传统IO读取，先读到系统缓冲区，在读到Java缓冲区（造成不必要的资源复制）</p>
<p><img src="/../images/JVM/2.png" alt="传统IO"></p>
<p>加入直接内存，java可以直接访问直接内存区域，省去了中间的系统内存缓冲区向java缓存区文件的复制操作，读写速度得到提升 </p>
<p><img src="/../images/JVM/3.png" alt="直接内存"></p>
<h3 id="直接内存溢出"><a href="#直接内存溢出" class="headerlink" title="直接内存溢出"></a>直接内存溢出</h3><p>运行以下代码报错：java.lang.OutOfMemoryError: Direct buffer memory</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1_10</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">_100Mb</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;ByteBuffer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocateDirect(_100Mb);</span><br><span class="line">                list.add(byteBuffer);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接内存对象如果不清空没办法被jvm垃圾回收，所以释放它需要其它函数</p>
<h3 id="分配和回收原理"><a href="#分配和回收原理" class="headerlink" title="分配和回收原理"></a>分配和回收原理</h3><ul>
<li><p>使用了Unsafe对象完成直接内存的分配回收，并且利用回收需要主动调用freeMemory方法</p>
</li>
<li><p>ByteBuffer的实现类内存，使用了Cleaner（虚引用）来监测ByteBuffer对象，一旦ByteBuffer对象被垃圾回收，那么就会由ReferenceHandler线程通过Cleaner的clean方法调用freeMemory来释放直接内存</p>
</li>
</ul>
<p><strong>禁用显示回收对直接内存的影响</strong></p>
<p>代码中的<strong>System.gc是显示垃圾回收</strong>，是一次Full GC 比较<strong>耗时，影响程序执行</strong>；可以使用命令<strong>禁用显示回收，</strong>但是会造成ByteBuffer对象存活，<strong>直接内存无法释放，造成长时间得不到释放的问题。</strong></p>
<p>解决方法：直接使用<strong>Unsafe调用FreeMemory手动释放</strong> UNSAFE.freeMemory(address);</p>
<h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><h2 id="如何判断对象可以回收"><a href="#如何判断对象可以回收" class="headerlink" title="如何判断对象可以回收"></a>如何判断对象可以回收</h2><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a><strong>引用计数法</strong></h3><p>只要一个对象被其他变量所引用，就让该对象的计数+1，如果引用了两次，计数就+2，如果某一个变量不再引用，计数-1，当该对象引用计数为0时，表明该对象未被引用，就可以当作垃圾回收</p>
<p>存在弊端：</p>
<p><img src="/../images/JVM/4.png" alt="弊端"></p>
<p>A对象引用B对象，B对象的引用计数为1，B对象反过来也引用A对象，A对象的引用计数也为1，造成<strong>循环依赖</strong>，两者一直相互引用，内存无法得到释放，从而导致<strong>内存泄漏</strong></p>
<h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>Java虚拟机中的垃圾回收器采用可达性分析来探索所有存活的对象</p>
<ul>
<li>首先要确定一系列根对象：肯定不能当成垃圾被回收的对象（GC Root对象）</li>
<li>在垃圾回收之前，要对堆内存中的所有对象进行一遍扫描，看哪些对象被根对象直接或间接引用，这些对象不能被回收，反之没有被根对象直接或间接引用，就可以作为垃圾，将来被回收（扫描堆中的对象，看是否能够沿着GC Root对象为起点的引用链找到该对象，找不到，表示可以回收）</li>
</ul>
<p>哪些对象可以作为GC Root？</p>
<p><img src="/../images/JVM/5.png" alt="弊端"></p>
<p>上图分为四个类：</p>
<ul>
<li>系统类：由启动类加载器加载的类，核心的类，在运行期间肯定会用到的类（Object，HashMap）</li>
<li>本地方法栈：Java虚拟机在执行方法时，必须调用操作系统方法，操作系统方法所引用的Java方法</li>
<li>活动线程：运行线程的栈帧中所引用的对象</li>
<li>正在加锁的对象：synchronized关键字对一个对象加了锁，被加锁的对象不能被回收</li>
</ul>
<h3 id="四种引用"><a href="#四种引用" class="headerlink" title="四种引用"></a>四种引用</h3><p>强引用 &gt; 软引用 &gt; 弱引用 &gt; 虚引用</p>
<p><img src="/../images/JVM/6.png" alt="四种引用"></p>
<ol>
<li>强引用：Java中默认的就是强引用，new了一个Object对象，并将其赋值给obj，这个obj就是new Object()的强引用</li>
</ol>
<p>无论任何情况下，只要强引用关系还存在，垃圾回收器永远不会回收被引用的对象</p>
<ol start="2">
<li>软引用：软引用是用于描述一些有用但非必须的引用</li>
</ol>
<ul>
<li><p>仅有软引用引用该对象时，只有在内存不足的情况下，并且没有其他强引用被引用的对象时才会被回收，内存够是不会被回收的</p>
</li>
<li><p>当软引用所引用对象被回收时，软引用会进入引用队列，对软引用自身所占内存进行释放（配合引用队列释放软引用自身）</p>
</li>
</ul>
<ol start="3">
<li>弱引用：也是用来描述些非必须对象，但是强度比软引用更弱一些</li>
</ol>
<ul>
<li>弱引用引用的对象且没有被其他强引用被引用，只要垃圾回收执行，就会被回收，不管是否内存不足</li>
<li>弱引用的回收也可以配合引用队列来释放弱引用自身</li>
</ul>
<p><img src="/../images/JVM/7.png" alt="软弱引用"></p>
<ol start="4">
<li>虚引用：最弱的一种引用关系</li>
</ol>
<ul>
<li>必须配合引用队列使用，主要配合ByteBuffer使用，被引用对象回收时，会将虚引用入队，由Reference Handler线程调用虚引用相关方法释放直接内存</li>
</ul>
<p><img src="/../images/JVM/8.png" alt="虚引用"></p>
<ol start="5">
<li>终结器引用</li>
</ol>
<ul>
<li>无需手动编码，但其内部配合引用队列使用，在垃圾回收时，终结器引用入队（被引用对象暂时没有被回收），再由Finalizer线程通过终结器引用找到被引用对象并调用它的finalize方法，第二次GC时才能回收被引用对象</li>
</ul>
<p><img src="/../images/JVM/9.png" alt="终结器引用"></p>
<h4 id="软引用应用"><a href="#软引用应用" class="headerlink" title="软引用应用"></a>软引用应用</h4><p>设置堆内存最大值为20m，打印GC详细信息</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xmx20m -XX:+PrintGCDetails -verbose:gc</span><br></pre></td></tr></table></figure>

<p>运行会造成堆内存溢出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        List&lt;<span class="type">byte</span>[]&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">byte</span>[_4MB]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>运行，由GC信息可知，在第五次添加的时候，内存已经不够，在一次完全的垃圾回收后，内存空间仍然不足，又触发了一次新的内存回收，将软引用的内存回收</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">soft</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// list --&gt; SoftReference --&gt; byte[]</span></span><br><span class="line">    List&lt;SoftReference&lt;<span class="type">byte</span>[]&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        SoftReference&lt;<span class="type">byte</span>[]&gt; ref = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">byte</span>[_4MB]);</span><br><span class="line">        System.out.println(ref.get());</span><br><span class="line">        list.add(ref);</span><br><span class="line">        System.out.println(list.size());</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;循环结束：&quot;</span> + list.size());</span><br><span class="line">    <span class="keyword">for</span> (SoftReference&lt;<span class="type">byte</span>[]&gt; ref : list) &#123;</span><br><span class="line">        System.out.println(ref.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../images/JVM/10.png" alt="软引用回收"></p>
<p><strong>软引用配合引用队列，将软引用对象清理掉</strong>（注意：这个软引用对象和上面的软引用内存不一样，软引用对象是对应的软引用本身，而软引用内存是指指向的对象）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo2_4</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_4MB</span> <span class="operator">=</span> <span class="number">4</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;SoftReference&lt;<span class="type">byte</span>[]&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 引用队列</span></span><br><span class="line">        ReferenceQueue&lt;<span class="type">byte</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 关联了引用队列， 当软引用所关联的 byte[]被回收时，软引用自己会加入到 queue 中去</span></span><br><span class="line">            SoftReference&lt;<span class="type">byte</span>[]&gt; ref = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">byte</span>[_4MB], queue);</span><br><span class="line">            System.out.println(ref.get());</span><br><span class="line">            list.add(ref);</span><br><span class="line">            System.out.println(list.size());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从队列中获取无用的 软引用对象，并移除</span></span><br><span class="line">        Reference&lt;? <span class="keyword">extends</span> <span class="title class_">byte</span>[]&gt; poll = queue.poll();</span><br><span class="line">        <span class="keyword">while</span> (poll != <span class="literal">null</span>) &#123;</span><br><span class="line">            list.remove(poll);</span><br><span class="line">            poll = queue.poll();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;===========================&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (SoftReference&lt;<span class="type">byte</span>[]&gt; reference : list) &#123;</span><br><span class="line">            System.out.println(reference.get());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../images/JVM/11.png" alt="软引用回收"></p>
<h4 id="弱引用应用"><a href="#弱引用应用" class="headerlink" title="弱引用应用"></a>弱引用应用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo2_5</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_4MB</span> <span class="operator">=</span> <span class="number">4</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//  list --&gt; WeakReference --&gt; byte[]</span></span><br><span class="line">        List&lt;WeakReference&lt;<span class="type">byte</span>[]&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            WeakReference&lt;<span class="type">byte</span>[]&gt; ref = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">byte</span>[_4MB]);</span><br><span class="line">            list.add(ref);</span><br><span class="line">            <span class="keyword">for</span> (WeakReference&lt;<span class="type">byte</span>[]&gt; w : list) &#123;</span><br><span class="line">                System.out.print(w.get()+<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;循环结束：&quot;</span> + list.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现，在第五次添加的时候，内存不够了，回收掉了第四个，才能添加第五个，。。第10次是因为弱引用本身也占用内存，放不下时，进行了Full GC，将弱引用内存全部清空</p>
<p><img src="/../images/JVM/12.png" alt="弱引用"></p>
<h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><h3 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h3><p><img src="/../images/JVM/13.png" alt="标记清除"></p>
<p>标记清除算法分为“标记”和“清除”两个阶段，首先通过可达性分析算法，标记出所有需要回收的对象，然后统一回收所以被标记的对象</p>
<ul>
<li>优点：不需要做额外的处理，清除速度快</li>
<li>缺点：会造成内存碎片，后续可能发生大对象找不到可利用空间的问题</li>
</ul>
<h3 id="标记整理"><a href="#标记整理" class="headerlink" title="标记整理"></a>标记整理</h3><p>标记整理算法的“标记”过程与标记清除算法的“标记”过程一致，但标记之后不会直接清理。而是将所有存活对象都移动到内存的一端。移动结束后直接清理掉剩余部分</p>
<p><img src="/../images/JVM/14.png" alt="标记整理"></p>
<p>优点：没有内存碎片</p>
<p>缺点：效率低、速度慢</p>
<h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><p>将内存分成两块，每次申请内存时都使用其中的一块，当内存不够时，将这一块中所有存活的复制到另一块上。然后再把原来块的内存全部清空</p>
<p><img src="/../images/JVM/15.png" alt="复制"></p>
<p><img src="/../images/JVM/16.png" alt="复制"></p>
<p>优点：没有内存碎片</p>
<p>缺点：需要占用双倍内存空间</p>
<h2 id="分代回收"><a href="#分代回收" class="headerlink" title="分代回收"></a>分代回收</h2><p>长时间使用的对象放在老年代中，用完可以丢弃的对象放在新生代中。老年代的垃圾回收很久发生一次，新生代的垃圾回收发生的比较频繁</p>
<ul>
<li>新的对象默认分配再伊甸园区域，不断添加新的对象，当伊甸园内存不足时，触发minor gc垃圾回收</li>
<li>minor gc会引发stop the world，暂停其它用户的线程，等垃圾回收结束后，用户线程才恢复运行</li>
</ul>
<p><img src="/../images/JVM/17.png" alt="新生代"></p>
<ul>
<li>通过可达性分析沿着GC Root引用链，看是否可以作为垃圾，采用标记复制算法，将伊甸园和幸村区from存活的对象复制到幸村区To，存活的对象寿命加一，回收掉伊甸园和from标记为垃圾的对象，并且交换幸村区from和to</li>
</ul>
<p><img src="/../images/JVM/18.png" alt="回收"></p>
<p><img src="/../images/JVM/19.png" alt="回收"></p>
<ul>
<li>当新的对象再次将伊甸园填满时，触发第二次垃圾回收，找到伊甸园中存活的对象放入幸存区To中，寿命+1，将幸存区from中存活的对象放入幸村区To中，寿命也+1，不要的对象回收掉，交换幸村区from和to</li>
</ul>
<p><img src="/../images/JVM/20.png" alt="再回收"></p>
<p><img src="/../images/JVM/23.png" alt="再回收"></p>
<ul>
<li>当寿命超过了阈值（默认是15），说明对象经常被使用，将垃圾晋升到老年代</li>
<li>当老年代空间不足，会先尝试触发minor GC，如果之后空间仍不足，那么促发full gc（整个清理）stop the world时间更长</li>
</ul>
<p><strong>相关JVM参数</strong></p>
<p><img src="/../images/JVM/24.png" alt="JVM参数"></p>
<h3 id="GC案例分析"><a href="#GC案例分析" class="headerlink" title="GC案例分析"></a>GC案例分析</h3><p>设置参数：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc</span><br></pre></td></tr></table></figure>

<p>运行代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo2_1</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_512KB</span> <span class="operator">=</span> <span class="number">512</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_1MB</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_6MB</span> <span class="operator">=</span> <span class="number">6</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_7MB</span> <span class="operator">=</span> <span class="number">7</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_8MB</span> <span class="operator">=</span> <span class="number">8</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../images/JVM/25.png" alt="运行"></p>
<p>执行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo2_1</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_512KB</span> <span class="operator">=</span> <span class="number">512</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_1MB</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_6MB</span> <span class="operator">=</span> <span class="number">6</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_7MB</span> <span class="operator">=</span> <span class="number">7</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_8MB</span> <span class="operator">=</span> <span class="number">8</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        ArrayList&lt;Object&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">byte</span>[_7MB]);</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">byte</span>[_512KB]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../images/JVM/26.png" alt="运行"></p>
<p>执行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo2_1</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_512KB</span> <span class="operator">=</span> <span class="number">512</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_1MB</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_6MB</span> <span class="operator">=</span> <span class="number">6</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_7MB</span> <span class="operator">=</span> <span class="number">7</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_8MB</span> <span class="operator">=</span> <span class="number">8</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        ArrayList&lt;Object&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">byte</span>[_7MB]);</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">byte</span>[_512KB]);</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">byte</span>[_512KB]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../images/JVM/27.png" alt="运行"></p>
<p>执行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo2_1</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_512KB</span> <span class="operator">=</span> <span class="number">512</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_1MB</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_6MB</span> <span class="operator">=</span> <span class="number">6</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_7MB</span> <span class="operator">=</span> <span class="number">7</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_8MB</span> <span class="operator">=</span> <span class="number">8</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        ArrayList&lt;Object&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">byte</span>[_8MB]);</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">byte</span>[_8MB]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../images/JVM/28.png" alt="运行"></p>
<p>运行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo2_1</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_512KB</span> <span class="operator">=</span> <span class="number">512</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_1MB</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_6MB</span> <span class="operator">=</span> <span class="number">6</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_7MB</span> <span class="operator">=</span> <span class="number">7</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_8MB</span> <span class="operator">=</span> <span class="number">8</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            ArrayList&lt;Object&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">byte</span>[_8MB]);</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">byte</span>[_8MB]);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        System.out.println(<span class="string">&quot;sleep...&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个线程的OutOfMemoryError，不会导致Java进程结束</p>
<p><img src="/../images/JVM/29.png" alt="运行"></p>
<h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h2><h3 id="串行"><a href="#串行" class="headerlink" title="串行"></a>串行</h3><p>单线程的收集器，说明它只会使用一个CPU或一条收集线程区完成垃圾收集工作，并且再它进行垃圾收集时，必须暂停其它所有的工作线程，直到它收集结束</p>
<p>优势：简单而又高效（与其它收集器的单线程相比）对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集，自然可以获得最高的单线程收集效率</p>
<p>场景：适合堆内存较小，个人电脑</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UserSerialGC =Serial +SerialOld 指定年轻代和老年代都使用串行收集器</span><br><span class="line">等价于新生代使用Serial GC（复制算法），老年代使用Serial Old GC（标记+整理算法）</span><br></pre></td></tr></table></figure>

<p>用户工作的线程，再安全点停下来</p>
<p><img src="/../images/JVM/30.png" alt="串行"></p>
<h3 id="吞吐量优先"><a href="#吞吐量优先" class="headerlink" title="吞吐量优先"></a>吞吐量优先</h3><p>多线程的收集器，主要让单位时间内，STW（垃圾收集器最大停顿时间）的时间最短（0.2+0.2 &#x3D; 0.4），可以高效利用CPU时间，尽快完成线程的运算任务（垃圾回收时间占比最低，这样就称吞吐量高）</p>
<p>场景：堆内存较大，多核CPU来支持（单核，也是多个线程轮流争抢单核CPU的时间片，效率更低），适合再后台运算而不许需要太多交互的任务。parallel并行执行，指多个垃圾回收器可以并行的运行，占用不同的cpu。但是在此期间，用户线程是被暂停的，只有垃圾回收线程在运行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseParallelGC 手动指定年轻代使用Parallel并行收集器执行内存回收任务(复制算法）</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseParallelOldGC 手动指定老年代使用并行回收收集器(标记+整理算法)</span><br><span class="line">jdk8默认是开启的.上面两个参数,默认开启一个,另一个也会被开启(互相激活)</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseAdaptiveSizePolicy：自适应调整新生代大小(新生代占比和晋升阈值大小)</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:ParallelGCThreads：设置年轻代并行收集器的线程数，</span><br><span class="line">最好与CPU数量相等，以避免过多的线程数影响垃圾收集性能,在默认情况下，CPU数量小于8， ParallelGCThreads的值等于CPU数量，当CPU数量大于8,ParallelGCThreads的值等于3+(5*CPU_COUNT/8)</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:GCTimeRatio：垃圾收集时间占总时间的比例(=1/(N+1))，用于衡量吞吐量的大小</span><br><span class="line">取值范围(0,100),默认99,也就是垃圾回收时间不超过1%，很难达到，一般设置为19，即100分钟只允许5分钟垃圾回收</span><br><span class="line">与-XX:MaxGCPauseMillis参数有一定矛盾性,暂停时间越长,Radio参数就越容易超过设定的比例</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:MaxGCPauseMillis 设置垃圾收集器最大停顿时间(即STW的时间)单位是毫秒(该参数使用需谨慎)</span><br><span class="line">为了尽可能地把停顿时间控制在MaxGCPauseMillis以内,收集器在工作时会调整Java堆大小或者其他一些参数</span><br><span class="line">对于用户来讲,停顿时间越短体验越好,但是在服务器端,我们注重高并发,整体的吞吐量,所以服务器端适合Parallel，进行控制</span><br></pre></td></tr></table></figure>

<p><img src="/../images/JVM/31.png" alt="吞吐量优先"></p>
<h3 id="响应时间优先"><a href="#响应时间优先" class="headerlink" title="响应时间优先"></a>响应时间优先</h3><p>多线程</p>
<p>场景：堆内存较大，多核CPU</p>
<p>尽可能让单词STW的时间最短0.1+0.1+0.1+0.1+0.1 &#x3D; 0.5</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseConcMarkSweepGC(老年代，标记清除算法) ~ -XX:+UseParNewGC ~ SerialOld (新生代，复制算法)</span><br><span class="line">concurrent 并发(垃圾回收器进行垃圾回收时，其他用户线程也可以并发进行，与垃圾回收线程抢占cpu)mark标记，sweep清除()</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:ParallelGCThreads=n 并行的垃圾回收线程数，一般跟cpu数目相等</span><br><span class="line">-XX:ConcGCTreads=threads 并发的垃圾回收线程数目，</span><br><span class="line">一般是ParallelGCThreads的 1/4，即一个cpu做垃圾回收，剩下3个cpu留给人家用户线程。</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:CMSInitiatingOccupancyFraction=percent，开始执行CMS垃圾回收时的内存占比，</span><br><span class="line">早期默认65，即只要老年代内存占用率达到65％的时候就要开始清理，留下35％的空间给新产生的浮动垃圾。</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+CMSScavengeBeforeRemark 在重新标记之前，对新生代做一次垃圾回收</span><br></pre></td></tr></table></figure>

<p><img src="/../images/JVM/32.png" alt="响应时间优先"></p>
<p>CMS回收器发生并行失败时，CMS回收器会退化成SerialOld的单线程的基于标记整理的垃圾回收器</p>
<p><strong>CMS老年代回收过程</strong></p>
<ul>
<li>当老年代空间不足时，所有进程运行到安全点暂停，垃圾回收的线程进行初始化标记，初始化标记比较快，只是标记空间对象。此过程会Stop The World，阻塞其它用户线程</li>
<li>初始标记完成后，达到下一个安全点，其它用户线程也可以继续运行了，此时垃圾回收线程进行并发标记，即可以根其它用户线程并发工作，将其它垃圾标记出来。此过程不会STW，响应时间很短几乎不影响用户线程工作</li>
<li>达到下一个安全点之后，进行重新标记，因为上一个并发标记时，其它用户线程也在并发执行，有可能会产生新对象引用，对垃圾回收线程造成了干扰，需要重新标记。此过程会STW</li>
<li>到下一个安全点之后，其它用户线程恢复，垃圾回收线程开始并发的清理垃圾，恢复运行</li>
</ul>
<p>整个工作阶段只会在初始标记和重新标记的时候STW，其它阶段并发执行，响应时间特别短</p>
<p><strong>CMS垃圾回收器</strong></p>
<ul>
<li>CMS垃圾回收器对cpu的占用率并不高，但是用户工作线程也在运行，垃圾回收线程占用用户线程的工作线程，整个应用程序的吞吐量变小了</li>
<li>CMS在执行最后一步并发清理的时候，由于其它线程还在运行，就会产生新的垃圾，而新的垃圾只有等到下次垃圾回收才能清理。这些垃圾被称为浮动垃圾，所以要预留一些空间来存放浮动垃圾</li>
<li>重新标记阶段，新生代的对象可能会引用老年代的对象，重新标记时需要扫描整个堆，做可达性分析时，只要新生代的引用存在，不管有没有必要，都会通过新生代引用找到老年代，对性能影响有些大。因为新生代对象很多，且很多要作为垃圾被回收。可达性分析又会通过新生代引用去找老年代，但是就算找到了老年代，这些新生代还是要被回收，也就是说没有必要查找老年代。所以需要在重新标记之前，先回收新生代(-XX:+CMSScavengeBeforeRemark参数设置)，就不会存在新生代引用老年代，然后去查找老年代了。新生代的垃圾回收(通过-XX:+UseParNewGC)之后，新生代对象少了，重新标记的压力就轻了。</li>
<li>因为CMS基于标记清除算法，有可能会产生比较多的内存碎片。这样会造成将来给对象分配空间时minorGC后内存空间不足，老年代的空间也不足，会造成并发失败。CMS就会退化成SerialOld串行地垃圾回收，通过标记整理碎片来得到空间。但是会导致垃圾回收的时间变得很长（要整理），给用户造成不好的体验。</li>
</ul>
<h3 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h3><p>2017 JDK9 默认，取代CMS垃圾回收器</p>
<p>使用场景：</p>
<ul>
<li>同时注重吞入量和低延迟，默认的暂停目标是200ms，在用户线程工作的同时，垃圾回收线程也在并发的执行</li>
<li>超大堆内存，会将堆划分为多个大小相等的Region（区域，1248M）</li>
<li>整体上是 标记+整理 算法，两个区域之间是 复制 算法</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseG1GC 显示启动G1</span><br><span class="line">-XX:G1HeapRegionSize=size 设置区域大小</span><br><span class="line">-XX:MaxGCPauseMillis=time 设置暂停目标</span><br></pre></td></tr></table></figure>

<h4 id="垃圾回收阶段"><a href="#垃圾回收阶段" class="headerlink" title="垃圾回收阶段"></a>垃圾回收阶段</h4><p><img src="/../images/JVM/33.png" alt="G1垃圾回收"></p>
<p>新生代垃圾收集：发生时机就是伊甸园满的时候</p>
<p>新生代垃圾收集+并发标记：当老年代内存超过阈值时，在新生代垃圾回收的同时，并发标记</p>
<p>混合收集：不只清理年轻代，还会将老年代的一部分区域进行清理</p>
<h4 id="Young-Collection"><a href="#Young-Collection" class="headerlink" title="Young Collection"></a>Young Collection</h4><p>Young GC主要是对伊甸园进行GC，他在Eden空间耗尽时会被触发。在这种情况下，Eden空间的数据移动到Survivor空间中，如果Survivor空间不够，Eden空间的部分数据会直接晋升到老年代空间。Survivor区的数据移动到新的Survivor区中，也有部分数据晋升到老年代空间中。最终Eden空间的数据为空，GC停止工作，应用线程极速执行</p>
<p><img src="/../images/JVM/34.png" alt="Young Collection"></p>
<h4 id="Young-Collection跨代引用"><a href="#Young-Collection跨代引用" class="headerlink" title="Young Collection跨代引用"></a>Young Collection跨代引用</h4><p>新生代垃圾回收时，先找到GC Root对象，进行可达性分析算法，找到存活对象，存活对象复制到幸村区。</p>
<p>那如何找到所有的根对象呢？根对象有一部分来自于老年代，老年代存活的对象特别多，如果遍历一遍老年代去寻找根对象，那这样扫描下来会耗费大量的时间。G1引进了RSet的概念。它的全称是Remembered Set，作用是跟踪指向某个heap区内的对象引用。</p>
<p>老年代维护采用card table技术，将老年代区域再细分为card（下图右侧橙色区域），每个card大约为512k，如果老年代，如果老年代对象引用了新生代，对应的card标记为dirty card（粉丝区域），在做Gc Root遍历时，不需要找整个老年代，只需要关注dirty card区域，减少扫描范围，提过搜索效率</p>
<p>当堆新生代进行回收时，通过Remembered Set记录找到对应的dirty card，然后在dirty card区域遍历Region的Gc Root</p>
<p><img src="/../images/JVM/37.png" alt="Young Collection跨代引用"></p>
<h4 id="Young-Collection-CM"><a href="#Young-Collection-CM" class="headerlink" title="Young Collection+CM"></a>Young Collection+CM</h4><ul>
<li>当堆空间的内存占用达到阈值（-XX:InitiatingHeapOccupancyPercent，默认45%）就开始老年代的并发标记过程。</li>
<li>初始标记阶段：标记GC Roots直接可达的对象，也就是直接引用关系对象，会发生STW（由于是直接可达的对象的标记，所以暂停时间很短），并且会触发一次Young GC。</li>
<li>根区域的扫描（Root Region Scanning）：G1扫描Survivor区直接可达的老年代区域对象，并标记被引用的对象。这一个过程必须在Young GC之前完成（因为Young GC会操作Survivor区中的对象）。</li>
<li>并发标记（Concurrent Marking）：在整个堆中进行并发标记（与程序线程并发执行），此过程可能会被Young GC打断，在并发标记阶段中，若发现某些region中所有对象都是垃圾，那这个region就会被立即回收，同时并发标记过程中，会计算每个region的对象活性（该region存活对象的比例，G1垃圾回收的时候并不是所有region都会参与回收的，根据回收的价值高低来优先回收价值较高的region）。</li>
<li>再次标记：由于并发标记阶段是收集器的标记线程和程序线程并发执行的，需要进行再次标记，修正上一次的标记结果，可以理解为增量补偿标记。会出现STW（暂停时间较短）。G1采用的是比CMS跟快的初始快照算法：snapshot-at-the-beginning（SATB）。</li>
<li>独占清理：计算各个region的存活对象和GC回收比例，并进行排序（回收价值高低排序），识别可以混合回收的区域。为下阶段做铺垫，会发生STW。需要注意的是这个阶段实际上并不会做垃圾的回收。</li>
<li>并发清理阶段：识别并清理完成空闲的区域。</li>
</ul>
<p><img src="/../images/JVM/35.png" alt="Young Collection+CM"></p>
<h4 id="Remark-SATB"><a href="#Remark-SATB" class="headerlink" title="Remark-SATB"></a>Remark-SATB</h4><p>SATB是GC开始时活着的对象的一个快照。它是通过Root   Tracing得到的，作用是维持并发GC的正确性。对象存在三种状态，白：对象没有被标记到，标记阶段结束后，会被当做垃圾回收掉。灰：对象被标记了，但是它的field还没有被标记或标记完。黑：对象被标记了，且它的所有field也被标记完了</p>
<p><img src="/../images/JVM/38.png" alt="对象三种状态"></p>
<p>SATB利用写屏障，将所有即将被删除的引用关系的旧引用记录下来（加入到队列中），标记为灰色，最后这些旧引用为根Stop The World地重新扫描一遍即可避免漏标问题。</p>
<p><img src="/../images/JVM/39.png" alt="加入队列中"></p>
<p>因此G1 Remark阶段Stop The World与CMS的remark有一个本质的区别，那就是这个暂停只需要扫描所有的队列中对象即可，而CMS的remark需要重新扫描整个根集合，因而CMS remark有可能会非常慢</p>
<h4 id="Mixed-Collection"><a href="#Mixed-Collection" class="headerlink" title="Mixed Collection"></a>Mixed Collection</h4><p>混合式垃圾回收，每次- 收集既可能只收集年轻代分区(年轻代收集)，也可能在收集年轻代的同时，包含部分老年代分区(混合- 收集)，这样即使堆内存很大时，也可以限制收集范围，从而降低停顿。</p>
<p>G1有一个参数：“-XX：InitiatingHeapOccupancyPercent”,默认值是45%，当老年代的大小占据了堆内存的45%的Region时，此时就会触发一个新生代和老年代的混合回收阶段，对E S 0 H进行全面回收。</p>
<p>该阶段一旦触发会导致系统进入STW，同时进行最后一个标记：</p>
<ul>
<li>最终标记阶段：会根据并发标记阶段记录的对象修改，最终标记哪些对象是存活，哪些对象是垃圾</li>
</ul>
<p>此时老年代也是根据标记-复制算法来进行回收的，会将标记存活的对象拷贝到新的Region中作为老年代区域：</p>
<ul>
<li>标记完成后马上开始垃圾的回收。对于一个混合的回收过程，G1从老年代移动存活的对象到空闲区域，这些空闲的区域变成了老年代region。当越来越多的对象晋升到老年代region的时候，为了避免堆内存被耗尽，就会触发混合垃圾收集Mixed GC，该算法并不是一个Old GC也不是Full GC，除了回收整个Young region之外，还会回收一部分Old region，部分的region垃圾回收设计可以对垃圾回收的耗时进行控制。</li>
<li>在并发标记结束之后，老年代中能够完全确认为垃圾的region中的内存分段被回收了，部分为垃圾的region中内存分段也被计算出来了，默认情况下，这些老年代的内存分段会被分为8次回收（可以通过-XX:G1MixedGCCountTarget设置）。</li>
<li>混合回收的回收集包括1&#x2F;8的老年代的内存分段，Eden区内存分段，Survivor内存分段，混合回收的算法和年轻代回收的算法完全一致。</li>
<li>混合回收并不一定要进行8次，有一个阈值设置：-XX:G1HeapWastePercent，默认值10%，代表允许整个堆内存中有10%的内存可以被浪费，意味着如果发现可以回收的垃圾占对内存的比例低于10%，则不进行混合回收，因为GC花费的时间相对于较少的垃圾回收来说得不偿失。</li>
<li>由于老年代的内存分段默认分为8次回收，G1会优先回收垃圾多的内存分段，<strong>垃圾占内存分段比例越高的会优先被回收</strong>。并且有一个阈值决定内存分段是否被回收：-XX:G1MixedGCLiveThresholdPercent，默认为65%，代表垃圾占内存分段比例要达到65%来回被回收，如果垃圾占比太低，意味着存活的对象多，复制算法就会花费更多的时间区复制存活的对象。</li>
<li>必要的情况下（对象分配速度远大于回收速度），Full GC仍然会触发（Full GC的成本较高，单线程，性能差，STW时间长）</li>
<li>堆内存太小、对象分配速度远大于回收速度等原因都可以导致G1在复制存活对象的时候没有空闲的内存分段可用，最终造成Full GC的触发。</li>
</ul>
<p><img src="/../images/JVM/36.png" alt="Mixed Collection"></p>
<h4 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h4><p><strong>SerialGC</strong></p>
<p>新生代内存不足发生的垃圾收集 -minor gc</p>
<p>老年代内存不足发生的垃圾收集 -full gc</p>
<p><strong>ParallelGC</strong></p>
<p>新生代内存不足发生的垃圾收集 -minor gc</p>
<p>老年代内存不足发生的垃圾收集 -full gc</p>
<p><strong>CMS</strong></p>
<p>新生代内存不足发生的垃圾收集 -minor gc</p>
<p>老年代内存不足时，垃圾回收速度低于产生速度时候，并发失败，退化为单线程SerialGC串行执行，为fullGC，否则不是</p>
<p><strong>G1</strong></p>
<p>新生代内存不足发生的垃圾收集 -minor gc</p>
<p>老年代内存不足：超过阈值时先并发标记再混合收集，当回收速度高于新的用于线程产生垃圾的速度，处于并发垃圾收集。当垃圾回收速度低于新产生的垃圾速度，退化为full GC，响应时间较长</p>
<h3 id="G1垃圾回收优化"><a href="#G1垃圾回收优化" class="headerlink" title="G1垃圾回收优化"></a>G1垃圾回收优化</h3><h4 id="JDK-8u20字符串去重"><a href="#JDK-8u20字符串去重" class="headerlink" title="JDK 8u20字符串去重"></a>JDK 8u20字符串去重</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseStringDeduplication 开启字符串去重功能，默认打开</span><br></pre></td></tr></table></figure>

<p><img src="/../images/JVM/40.png" alt="字符串去重"></p>
<p>会将所有新分配的字符串放入一个队列中，当新生代回收时，G1并发检查是否有字符串去重，如果它们值一样，让它们引用同一个char[]。s1和s2引用的是堆中两个不同的对象，只不过那两个对象都指向同一个字符串而已，所以s1!&#x3D;s2</p>
<p>优点：节省大量内存</p>
<p>缺点：略微占用太多了cpu时间，新生代回收时间略微增加</p>
<p><strong>注意：</strong>与String.intern()不一样，String.intern()关注的是字符串对象，而字符串去重关注的是char[]，在JVM内部，使用了不同的字符串表</p>
<h4 id="JDK-8u40并发卸载"><a href="#JDK-8u40并发卸载" class="headerlink" title="JDK 8u40并发卸载"></a>JDK 8u40并发卸载</h4><p>之前jdk版本中，一般是不卸载的，类加载之后，会一直占用内存</p>
<p>在所有对象都经过并发标记后，就能知道哪些类不在使用，当一个类加载器的所有类都不在使用则卸载它所加载的所有类</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+ClassUnloadingWithConcurrentMark 默认启用</span><br></pre></td></tr></table></figure>

<p><strong>卸载条件：</strong></p>
<p>类的实例都被回收掉</p>
<p>类所在的类加载器其中的所有类都不在使用</p>
<h4 id="JDK-8u60回收巨型对象"><a href="#JDK-8u60回收巨型对象" class="headerlink" title="JDK 8u60回收巨型对象"></a>JDK 8u60回收巨型对象</h4><p>当一个对象大于region的一半时，称之为巨型对象</p>
<p>G1一般不会对巨型对象进行拷贝，回收时被优先考虑</p>
<p>G1会跟踪老年代所有incoming引用，这样老年代incoming引用为0的巨型对象就可以在新生代垃圾回收时处理掉</p>
<p><img src="/../images/JVM/41.png" alt="巨型对象"></p>
<h4 id="JDK-9并发标记起始时间的调整"><a href="#JDK-9并发标记起始时间的调整" class="headerlink" title="JDK 9并发标记起始时间的调整"></a>JDK 9并发标记起始时间的调整</h4><p>为了减少Full GC，可以提前让并发标记，混合收集提前开始</p>
<p>JDK9之前需要使用 -XX:InitiatingHeapOccupancyPercent 老年代在整个堆内存的占比的阈值，超过时，并发垃圾回收开始，默认是45%</p>
<p>JDK 9可以动态调整-XX:InitiatingHeapOccupancyPercent 用来设置初始值，在垃圾回收过程中，进行数据采样并动态调整阈值，会添加一个安全的空挡空间，减少Full GC产生几率</p>
<h3 id="垃圾回收调优"><a href="#垃圾回收调优" class="headerlink" title="垃圾回收调优"></a>垃圾回收调优</h3><p>查看虚拟机运行参数（本地虚拟机与GC相关参数）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+PrintFlagsFinal -version | findstr “GC”</span><br></pre></td></tr></table></figure>

<p><img src="/../images/JVM/42.png" alt="相关参数"></p>
<p>掌握相关工具：jmap、jconsole、jstat查看GC相关状态</p>
<p>调优不仅仅从内存GC，还应该考虑线程堆锁的竞争，CPU的占用，以及IO的调用，网络延迟，软硬件的考虑</p>
<h4 id="确认目标"><a href="#确认目标" class="headerlink" title="确认目标"></a>确认目标</h4><p>对于GC调优来说，首先就要清楚调优的目标是什么？要清楚自己的应用程序是做什么的，如果是做科学运算的，就要关注高吞吐量，如果是互联网项目，就要追求低延迟，提高用户体验</p>
<ul>
<li>高吞吐量：ParallelGC</li>
<li>低延迟：CMS（不推荐），G1，ZGC（java12）</li>
</ul>
<p>GC调优从性能的角度看，通常关注三个方面：内存占用，延时和吞吐量</p>
<p>大多数情况下调优会侧重于一个或者两个方面的目标，很少有情况可以兼顾三个不同的角度。也可能需要考虑其它GC相关的场景，例如，OOM也可能与不合理的GC相关参数有关；或者，应用启动速度方面的需求，GC也会是个考虑的方面</p>
<h4 id="最快的GC是不发生GC"><a href="#最快的GC是不发生GC" class="headerlink" title="最快的GC是不发生GC"></a>最快的GC是不发生GC</h4><p>查看Full GC前后的内存占用，考虑下面几个问题</p>
<ul>
<li>数据是不是太多？<ul>
<li>“select * from 大表”会将所有数据从mysql中查出来读入java内存</li>
<li>“select * from 大表 limit n”限制数量</li>
</ul>
</li>
<li>数据表示是否太过臃肿？<ul>
<li>对象图，一次性取出对象相关联不用的数据</li>
<li>对象大小对内存占用，Java中最小的Object占用16字节（Integer 16 int 4）</li>
</ul>
</li>
<li>是否存在内存泄漏？<ul>
<li>static Map map &#x3D; …不断地往静态地map对象中存放对象，会造成内存溢出</li>
<li>长时间存活的对象推荐使用，软&#x2F;弱引用</li>
<li>不推荐Java实现缓存，建议第三方缓存实现redis&#x2F;memorycache</li>
</ul>
</li>
</ul>
<h4 id="新生代调优"><a href="#新生代调优" class="headerlink" title="新生代调优"></a>新生代调优</h4><p><strong>新生代特点：</strong></p>
<ul>
<li>new对象首先在伊甸园中分配，分配速度特别快<ul>
<li>每个线程都会在内存中分配一块私有区域（TLAB），当new一个对象时，首先检查TLAB中有没有可用内存，有的话，优先在TLAB中进行对象分配，可以避免多个线程同时创建对象时对内存占用的干扰</li>
</ul>
</li>
<li>死亡对象的回收代价是零<ul>
<li>新生代发生垃圾回收时，采用复制算法（伊甸园+幸存区from -&gt; 幸存区to），复制完后，伊甸园和幸存区from的内存都被释放掉</li>
</ul>
</li>
<li>大部分对象用过即死</li>
<li>Minor GC 的时间远远低于Full GC</li>
</ul>
<h4 id="新生代内存越大越好吗？"><a href="#新生代内存越大越好吗？" class="headerlink" title="新生代内存越大越好吗？"></a>新生代内存越大越好吗？</h4><p>设置新生代的初始大小和最大大小（以字节为单位）。GC是在该区域比在其它区域更频繁地执行。如果年轻一代太小，则会执行触发多次minor GC。如果尺寸太大，仅执行新生代的垃圾收集，可能需要很长时间。建议新生代保持占堆的25%~50%</p>
<p>新生区大小建议：</p>
<ul>
<li>新生代能容纳所有（并发量+（请求+响应））的数据</li>
<li>幸存区大到能保留（当前活跃对象+需要晋升对象）<ul>
<li>晋升阈值配置得当，让长时间存活对象尽快晋升（不然会耗费幸村区的内存，而且不断的重复复制）</li>
</ul>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:MaxTenuringThreshold=threshold 调整最大晋升阈值</span><br><span class="line">-XX:+PrintTenuringDistribution 打印晋升区的存活对象</span><br></pre></td></tr></table></figure>

<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Desired survivor size <span class="number">48286924</span> bytes, new threshold <span class="number">10</span> (max <span class="number">10</span>)</span><br><span class="line">- age <span class="number">1</span>: <span class="number">28992024</span> bytes, <span class="number">28992024</span> total</span><br><span class="line">- age <span class="number">2</span>: <span class="number">1366864</span> bytes, <span class="number">30358888</span> total</span><br><span class="line">- age <span class="number">3</span>: <span class="number">1425912</span> bytes, <span class="number">31784800</span> total</span><br></pre></td></tr></table></figure>



</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="http://example.com">John Doe</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="http://example.com/2025/03/19/JVM/">http://example.com/2025/03/19/JVM/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2025/03/09/%E9%9D%A2%E8%AF%95%E9%A2%98/" title="面试题"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Next</div><div class="next_info">面试题</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">John Doe</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text">内存结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-number">2.1.</span> <span class="toc-text">程序计数器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88"><span class="toc-number">2.2.</span> <span class="toc-text">虚拟机栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88"><span class="toc-number">2.3.</span> <span class="toc-text">本地方法栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86"><span class="toc-number">2.4.</span> <span class="toc-text">堆</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="toc-number">2.5.</span> <span class="toc-text">方法区</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="toc-number">2.5.1.</span> <span class="toc-text">运行时常量池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#StringTable"><span class="toc-number">2.5.2.</span> <span class="toc-text">StringTable</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#StringTable%E7%89%B9%E6%80%A7"><span class="toc-number">2.5.3.</span> <span class="toc-text">StringTable特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-8"><span class="toc-number">2.5.3.1.</span> <span class="toc-text">1.8</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-6"><span class="toc-number">2.5.3.2.</span> <span class="toc-text">1.6</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#StringTable%E4%BD%8D%E7%BD%AE"><span class="toc-number">2.5.4.</span> <span class="toc-text">StringTable位置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-8-1"><span class="toc-number">2.5.4.1.</span> <span class="toc-text">1.8</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-6-1"><span class="toc-number">2.5.4.2.</span> <span class="toc-text">1.6</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#StringTable%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">2.5.5.</span> <span class="toc-text">StringTable垃圾回收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#StringTable%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98"><span class="toc-number">2.5.6.</span> <span class="toc-text">StringTable性能调优</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98"><span class="toc-number">2.6.</span> <span class="toc-text">直接内存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA"><span class="toc-number">2.6.1.</span> <span class="toc-text">直接内存溢出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E9%85%8D%E5%92%8C%E5%9B%9E%E6%94%B6%E5%8E%9F%E7%90%86"><span class="toc-number">2.6.2.</span> <span class="toc-text">分配和回收原理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">3.</span> <span class="toc-text">垃圾回收</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E5%8F%AF%E4%BB%A5%E5%9B%9E%E6%94%B6"><span class="toc-number">3.1.</span> <span class="toc-text">如何判断对象可以回收</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95"><span class="toc-number">3.1.1.</span> <span class="toc-text">引用计数法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95"><span class="toc-number">3.1.2.</span> <span class="toc-text">可达性分析算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8"><span class="toc-number">3.1.3.</span> <span class="toc-text">四种引用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E5%BC%95%E7%94%A8%E5%BA%94%E7%94%A8"><span class="toc-number">3.1.3.1.</span> <span class="toc-text">软引用应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%B1%E5%BC%95%E7%94%A8%E5%BA%94%E7%94%A8"><span class="toc-number">3.1.3.2.</span> <span class="toc-text">弱引用应用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="toc-number">3.2.</span> <span class="toc-text">垃圾回收算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4"><span class="toc-number">3.2.1.</span> <span class="toc-text">标记清除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86"><span class="toc-number">3.2.2.</span> <span class="toc-text">标记整理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6"><span class="toc-number">3.2.3.</span> <span class="toc-text">复制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E4%BB%A3%E5%9B%9E%E6%94%B6"><span class="toc-number">3.3.</span> <span class="toc-text">分代回收</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#GC%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90"><span class="toc-number">3.3.1.</span> <span class="toc-text">GC案例分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-number">3.4.</span> <span class="toc-text">垃圾回收器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B2%E8%A1%8C"><span class="toc-number">3.4.1.</span> <span class="toc-text">串行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%9E%E5%90%90%E9%87%8F%E4%BC%98%E5%85%88"><span class="toc-number">3.4.2.</span> <span class="toc-text">吞吐量优先</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88"><span class="toc-number">3.4.3.</span> <span class="toc-text">响应时间优先</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#G1"><span class="toc-number">3.4.4.</span> <span class="toc-text">G1</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E9%98%B6%E6%AE%B5"><span class="toc-number">3.4.4.1.</span> <span class="toc-text">垃圾回收阶段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Young-Collection"><span class="toc-number">3.4.4.2.</span> <span class="toc-text">Young Collection</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Young-Collection%E8%B7%A8%E4%BB%A3%E5%BC%95%E7%94%A8"><span class="toc-number">3.4.4.3.</span> <span class="toc-text">Young Collection跨代引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Young-Collection-CM"><span class="toc-number">3.4.4.4.</span> <span class="toc-text">Young Collection+CM</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Remark-SATB"><span class="toc-number">3.4.4.5.</span> <span class="toc-text">Remark-SATB</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Mixed-Collection"><span class="toc-number">3.4.4.6.</span> <span class="toc-text">Mixed Collection</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Full-GC"><span class="toc-number">3.4.4.7.</span> <span class="toc-text">Full GC</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E4%BC%98%E5%8C%96"><span class="toc-number">3.4.5.</span> <span class="toc-text">G1垃圾回收优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK-8u20%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%BB%E9%87%8D"><span class="toc-number">3.4.5.1.</span> <span class="toc-text">JDK 8u20字符串去重</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK-8u40%E5%B9%B6%E5%8F%91%E5%8D%B8%E8%BD%BD"><span class="toc-number">3.4.5.2.</span> <span class="toc-text">JDK 8u40并发卸载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK-8u60%E5%9B%9E%E6%94%B6%E5%B7%A8%E5%9E%8B%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.4.5.3.</span> <span class="toc-text">JDK 8u60回收巨型对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK-9%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0%E8%B5%B7%E5%A7%8B%E6%97%B6%E9%97%B4%E7%9A%84%E8%B0%83%E6%95%B4"><span class="toc-number">3.4.5.4.</span> <span class="toc-text">JDK 9并发标记起始时间的调整</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E8%B0%83%E4%BC%98"><span class="toc-number">3.4.6.</span> <span class="toc-text">垃圾回收调优</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AE%E8%AE%A4%E7%9B%AE%E6%A0%87"><span class="toc-number">3.4.6.1.</span> <span class="toc-text">确认目标</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%BF%AB%E7%9A%84GC%E6%98%AF%E4%B8%8D%E5%8F%91%E7%94%9FGC"><span class="toc-number">3.4.6.2.</span> <span class="toc-text">最快的GC是不发生GC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B0%E7%94%9F%E4%BB%A3%E8%B0%83%E4%BC%98"><span class="toc-number">3.4.6.3.</span> <span class="toc-text">新生代调优</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B0%E7%94%9F%E4%BB%A3%E5%86%85%E5%AD%98%E8%B6%8A%E5%A4%A7%E8%B6%8A%E5%A5%BD%E5%90%97%EF%BC%9F"><span class="toc-number">3.4.6.4.</span> <span class="toc-text">新生代内存越大越好吗？</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/19/JVM/" title="JVM">JVM</a><time datetime="2025-03-19T08:33:04.000Z" title="Created 2025-03-19 16:33:04">2025-03-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/09/%E9%9D%A2%E8%AF%95%E9%A2%98/" title="面试题">面试题</a><time datetime="2025-03-09T12:34:53.000Z" title="Created 2025-03-09 20:34:53">2025-03-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/03/Docker/" title="Docker">Docker</a><time datetime="2025-02-03T05:36:13.000Z" title="Created 2025-02-03 13:36:13">2025-02-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/21/RabbitMQ/" title="RabbitMQ">RabbitMQ</a><time datetime="2025-01-21T01:55:08.000Z" title="Created 2025-01-21 09:55:08">2025-01-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/28/ES/" title="ES">ES</a><time datetime="2024-12-28T02:58:47.000Z" title="Created 2024-12-28 10:58:47">2024-12-28</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By John Doe</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>