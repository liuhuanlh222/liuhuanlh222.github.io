<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>面试题 | Hexo</title><meta name="author" content="HERAO"><meta name="copyright" content="HERAO"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="答题技巧总：当前问题回答的是哪些具体的点 分：以1，2，3，4，5的方式分细节描述相关的知识点，如果有哪些点不清楚，直接忽略过去 突出一些技术名词（核心概念，接口，类，关键方法） 避重就轻：没有重点 当面试官问到一个你熟悉的点的时候，一定要尽量拖时间 Spring面试题谈谈Spring IOC的理解，原理与实现？总： 控制反转：理论思想，原来的对象是由使用者进行控制，有了spring之后，可以把整">
<meta property="og:type" content="article">
<meta property="og:title" content="面试题">
<meta property="og:url" content="http://example.com/2025/03/09/%E9%9D%A2%E8%AF%95%E9%A2%98/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="答题技巧总：当前问题回答的是哪些具体的点 分：以1，2，3，4，5的方式分细节描述相关的知识点，如果有哪些点不清楚，直接忽略过去 突出一些技术名词（核心概念，接口，类，关键方法） 避重就轻：没有重点 当面试官问到一个你熟悉的点的时候，一定要尽量拖时间 Spring面试题谈谈Spring IOC的理解，原理与实现？总： 控制反转：理论思想，原来的对象是由使用者进行控制，有了spring之后，可以把整">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-03-09T12:34:53.000Z">
<meta property="article:modified_time" content="2025-04-25T14:32:08.686Z">
<meta property="article:author" content="HERAO">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "面试题",
  "url": "http://example.com/2025/03/09/%E9%9D%A2%E8%AF%95%E9%A2%98/",
  "image": "http://example.com/img/butterfly-icon.png",
  "datePublished": "2025-03-09T12:34:53.000Z",
  "dateModified": "2025-04-25T14:32:08.686Z",
  "author": [
    {
      "@type": "Person",
      "name": "HERAO",
      "url": "http://example.com/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2025/03/09/%E9%9D%A2%E8%AF%95%E9%A2%98/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '面试题',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.2.0"></head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Hexo</span></a><a class="nav-page-title" href="/"><span class="site-name">面试题</span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">面试题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2025-03-09T12:34:53.000Z" title="Created 2025-03-09 20:34:53">2025-03-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-04-25T14:32:08.686Z" title="Updated 2025-04-25 22:32:08">2025-04-25</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="答题技巧"><a href="#答题技巧" class="headerlink" title="答题技巧"></a>答题技巧</h1><p>总：当前问题回答的是哪些具体的点</p>
<p>分：以1，2，3，4，5的方式分细节描述相关的知识点，如果有哪些点不清楚，直接忽略过去</p>
<p>突出一些技术名词（核心概念，接口，类，关键方法）</p>
<p>避重就轻：没有重点</p>
<p>当面试官问到一个你熟悉的点的时候，一定要尽量拖时间</p>
<h1 id="Spring面试题"><a href="#Spring面试题" class="headerlink" title="Spring面试题"></a>Spring面试题</h1><h2 id="谈谈Spring-IOC的理解，原理与实现？"><a href="#谈谈Spring-IOC的理解，原理与实现？" class="headerlink" title="谈谈Spring IOC的理解，原理与实现？"></a>谈谈Spring IOC的理解，原理与实现？</h2><p><strong>总：</strong></p>
<p>控制反转：理论思想，原来的对象是由使用者进行控制，有了spring之后，可以把整个对象交给spring来帮我们进行管理</p>
<p>​		DI：依赖注入，把对应的属性的值注入到具体的对象中，@Autowired，populateBean完成属性值的注入</p>
<p>容器：存储对象，使用map结构来存储，在spring中一般存在三级缓存，singletonObjects存放完整的bean对象，整个bean的生命周期，从创建到使用到销毁的过程全部都是由容器来管理（bean的生命周期）</p>
<p><strong>分：</strong></p>
<ol>
<li><p>一般聊ioc容器的时候要涉及到容器的创建过程（beanFactory，DefaultListableBeanFactory），向bean工厂中设置一些参数（BeanPostProcessor,Aware接口的子类）等等属性</p>
</li>
<li><p>加载解析bean对象，准备要创建的bean对象的定义对象beanDefinition（xml或者注解的解析过程）</p>
</li>
<li><p>beanFactoryPostProcessor的处理点，此处是扩展点，增强BeanDefinition</p>
</li>
<li><p>BeanPostProcessor的注册功能，方便后续对bean对象完成具体的扩展功能</p>
</li>
<li><p>通过反射的方式将BeanDefinition对象实例化为具体的Bean对象</p>
</li>
<li><p>bean对象的初始化过程（填充属性，调用aware子类的方法，调用BeanPostProcessor前置处理方法，调用init-method方法，调用BeanPostProcessor的后置处理方法）</p>
</li>
<li><p>生成完整的bean对象，通过getBean方法可以直接获取</p>
</li>
<li><p>销毁过程</p>
</li>
</ol>
<p>面试官，这是我堆ioc的整体理解，包含了一些详细的过程，您看有什么问题，可以指点我一下（允许你把整个流程说完）</p>
<h2 id="谈一下Spring-IOC的底层实现"><a href="#谈一下Spring-IOC的底层实现" class="headerlink" title="谈一下Spring IOC的底层实现"></a>谈一下Spring IOC的底层实现</h2><p>反射，工厂，设计模式（会的说，不会的不说），关键的几个方法</p>
<p>createBeanFactory，getBean，doGetBean，createBean，doCreateBean，createBeanInstance，populateBean</p>
<ol>
<li>先通过createBeanFactory创建处一个bean工厂（DefaultListableBeanFactory）</li>
<li>开始循环创建对象，因为容器中的bean默认都是单例的，所以优先通过getBean，doGetBean从容器中查找，找不到的话</li>
<li>通过createBean，doCreateBean方法，以反射的方式创建对象，一般情况下使用的无参构造方法（getDeclaredConstructor，newinstance）</li>
<li>进行对象的属性填充populateBean</li>
<li>进行其它的初始化操作（initializingBean）</li>
</ol>
<h2 id="描述一下bean的生命周期"><a href="#描述一下bean的生命周期" class="headerlink" title="描述一下bean的生命周期"></a>描述一下bean的生命周期</h2><p><img src="/../images/shujuku/3.png" alt="bean生命周期"></p>
<h2 id="Spring是如何解决循环依赖的问题的"><a href="#Spring是如何解决循环依赖的问题的" class="headerlink" title="Spring是如何解决循环依赖的问题的"></a>Spring是如何解决循环依赖的问题的</h2><p>三级缓存，提前暴露对象，aop</p>
<p>总：什么是循环依赖问题，A依赖B，B依赖A</p>
<p>分：先说明bean的创建过程：实例化，初始化（填充属性）</p>
<ol>
<li>先创建A对象，实例化A对象，此时A对象中的B属性为空，填充属性B</li>
<li>从容器中查找B对象，如果找到了直接赋值，不存在循环依赖问题（不通），找不到直接创造B对象</li>
<li>实例化B对象，此时B对象中的A属性为空，填充属性A</li>
<li>从容器中查找A对象，找不到，创建A对象</li>
</ol>
<p>上面4个步骤形成循环依赖问题</p>
<p>此时如果仔细琢磨的话，会发现A对象是存在的，只不过此时的A对象不是一个完整的状态，只完成了实例化但是未完成初始化，如果在程序调用的过程中，拥有了某个对象的引用的话，能否在后期给它完成赋值操作，可以优先把非完整状态的对象优先赋值，等待后续操作来完成赋值，相当于提前暴露了某个不完整对象的引用。所以解决问题的核心在于实例化和初始化分开操作，这也是解决循环依赖问题的关键。</p>
<p>当所有的对象都完成实例化和初始化操作之后，还要把完整对象放到容器中，此时在容器中存在对象的几个状态，完成实例化但未完成初始化，因为都在容器中，所以要使用不同的map结构来进行存储，此时就有了一级缓存和二级缓存，如果一级缓存中有个，那么二级缓存中就不会存在同名的对象，因为他们的查找顺序是1，2，3这样的方法来查找的。</p>
<p>一级缓存中放的是完整对象，二级缓存中方法半成品对象（非完整对象）</p>
<p>为什么需要三级缓存？三级缓存的value类型是ObjectFactory，是一个函数式接口，存在的意义是保证整个容器的运行过程中同名的bean对象只能有一个</p>
<p>如果一个对象需要被代理了，或者说需要生成代理对象，那么要不要优先生成一个普通对象？要！！！</p>
<p>普通对象和代理对象是不能同时出现在容器中的，因此当一个对象被代理的时候，就要使用代理对象来覆盖掉之前的普通对象。在实际的调用过程中，是没有办法确定什么时候对象被使用的，所以就要求当某个对象被调用的时候，优先判断此对象是否需要被代理，类似与一种回调机制，因此传入lambda表达式的时候，可以通过lambda表达式来执行对象的覆盖过程，getEarlyBeanReference（）</p>
<p>因此，所有的bean在创建的时候都要优先放到三级缓存中，在后续的使用过程中，如果需要被代理则返回代理对象，如果不需要代理则然会普通对象</p>
<h2 id="缓存的放置时间和删除时间"><a href="#缓存的放置时间和删除时间" class="headerlink" title="缓存的放置时间和删除时间"></a>缓存的放置时间和删除时间</h2><p>三级缓存：createBeanInstance之后：addSingletonFactory</p>
<p>二级缓存：第一次从三级缓存确定对象是代理对象还是普通对象的时候，同时删除三级缓存getSingleton</p>
<p>一级缓存：生成完整对象之后放到一级缓存，删除二三级缓存：addSingleton</p>
<h2 id="BeanFactory与FactoryBean有什么区别"><a href="#BeanFactory与FactoryBean有什么区别" class="headerlink" title="BeanFactory与FactoryBean有什么区别"></a>BeanFactory与FactoryBean有什么区别</h2><p>相同点：都是用来创建bean对象的</p>
<p>不同点：当使用BeanFactory创建对象的时候，必须要遵循严格的生命周期流程，太复杂了。如果想要简单的自定义某个对象的创建，同时创建完成的对象想交给spring来管理，那么就需要实现FactoryBean接口了</p>
<p>isSingleton：是否是单例对象</p>
<p>getObjectType：获取返回对象的类型</p>
<p>getObject：自定义创建对象的过程（new，反射，动态代理）</p>
<h2 id="Spring中用到的设计模式"><a href="#Spring中用到的设计模式" class="headerlink" title="Spring中用到的设计模式"></a>Spring中用到的设计模式</h2><p>单例模式：bean默认都是单例的</p>
<p>原型模式：指定作用域为prototype</p>
<p>工厂模式：BeanFactory</p>
<p>模板方法：postProcessBeanFactory，onRefresh，initPropertyValue</p>
<p>策略模式：XmlBeanDefinitionReader，PropertiesBeanDefinitionReader</p>
<p>观察者模式：listener，event，multicast</p>
<p>适配器模式：Adapter</p>
<p>装饰着模式：BeanWrapper</p>
<p>责任链模式：使用AOP的时候会先生成一个拦截器链</p>
<p>代理模式：动态代理</p>
<p>委托者模式：delegate</p>
<h2 id="Spring的AOP的底层实现原理"><a href="#Spring的AOP的底层实现原理" class="headerlink" title="Spring的AOP的底层实现原理"></a>Spring的AOP的底层实现原理</h2><p>aop是ioc的一个扩展功能，先有的ioc，再有的aop，只是在ioc的整个流程中新增的一个扩展点而已：BeanPostProcessor</p>
<p>总：aop概念，应用场景，动态代理</p>
<p>分：bean的创建过程中有个步骤可以对bean进行扩展实现，aop本身就是一个扩展功能，所以在BeanPostProcessor的后置方法中来进行实现</p>
<ol>
<li><p>代理对象的创建过程（advice，切面，切点）</p>
</li>
<li><p>通过jdk或者cglib的方式来生成代理对象</p>
</li>
<li><p>在执行方法调用的时候，会调用到生成的字节码文件中，直接会找到DynamicAdvisoredInterceptor类中的interceptor方法，从此方法开始执行</p>
</li>
<li><p>根据之前定义好的通知来生成拦截器链</p>
</li>
<li><p>从拦截器链中依次获取每一个通知开始执行，在执行过程中，为了方便找到下一个通知是哪个，会有一个InvocationInterceptor的对象，找的时候是从-1的位置依次开始查找并且执行的</p>
</li>
</ol>
<h2 id="Spring的事务是如何回滚的"><a href="#Spring的事务是如何回滚的" class="headerlink" title="Spring的事务是如何回滚的"></a>Spring的事务是如何回滚的</h2><p>spring的事务管理是如何实现的？</p>
<p>总：spring的事务是由aop来实现的，首先要生成具体的代理对象，然后按照aop的整套流程来执行具体的操作逻辑，正常情况下要通过通知来完成核心功能，但是事务不是通过通知来实现的，而是通过一个TransactionInterceptor来实现的，然后调用invoke来实现具体的逻辑</p>
<p>分：</p>
<ol>
<li>先做准备工作，解释各个方法上事务相关的属性，根据具体的属性来判断是否开始新的事务</li>
<li>当需要开启的时候，获取数据库连接，关闭自动提交功能，开启事务</li>
<li>执行具体的sql逻辑操作</li>
<li>在操作过程中，如果执行失败了，那么会通过completeTransactionAfterThrowing完成事务的回滚操作，回滚的具体逻辑是通过doRollBack方法来实现的，实现的时候也要先获取连接对象，通过连接对象来回滚</li>
<li>如果执行过程中没有任务意外情况的发生，那么通过commitTransactionAfterReturning来完成事务的提交操作，提交的具体逻辑是通过doCommit方法来实现的，实现的时候也是要获取连接，通过连接对象来提交</li>
<li>当事务执行完毕之后需要清除相关的事务信息cleanupTransactionInfo</li>
</ol>
<h2 id="谈一下spring事务传播"><a href="#谈一下spring事务传播" class="headerlink" title="谈一下spring事务传播"></a>谈一下spring事务传播</h2><p>传播特性有几种？7种</p>
<p>Required,Requires_new,nested,Support,Not_Support,Never,Mandatory</p>
<p>某一个事务嵌套另一个事务的时候怎么办？</p>
<p>A方法调用B方法，AB方法都有事务，并且传播特性不同，那么A如果有异常，B怎么办，B如果有异常，A怎么办？</p>
<p>总：事务的传播特性指的是不同方法的嵌套调用过程中，事务应该如何进行处理，是用同一个事务还是不同事务，当出现异常的时候会回滚还是提交，两个方法之间的相互影响，在日常工作中，使用比较多的是required，Requires_new,nested</p>
<p>分：</p>
<ol>
<li>先说事务的不同分类，可以分为三类：支持当前事务，不支持当前事务，嵌套事务</li>
<li>如果外层方法是required，内层方法是required，requires_new，nested</li>
<li>如果外层方法是requires_new，内层方法是required，requires_new，nested</li>
<li>如果外层方法是nested，内层方法是required，requires_new，nested</li>
</ol>
<p>核心处理逻辑非常简单：</p>
<ol>
<li>判断内外方法是否是同一个事务。<ol>
<li>是：异常统一在外层方法处理</li>
<li>不是：内层方法有可能影响到外层方法，但是外层方法是不会影响内层方法的</li>
<li>（大致可以这么理解，但是有个别情况不同，nested）</li>
</ol>
</li>
</ol>
<h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p>AOP称为面向切面编程，用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取并封装为一个可用的模块，这个模块被命名为“切面”，减少系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性</p>
<ul>
<li>记录操作日志</li>
<li>缓存处理</li>
<li>Spring中内置的事务处理</li>
</ul>
<p>记录日志：核心是使用aop中的环绕通知+切点表达式（找到要记录日志的方法），通过环绕通知的参数获取请求方法的参数（类、方法、注解、请求方式等），获取这些参数以后，保存到数据库</p>
<p>Spring中的事务实现：本质是通过AOP功能，对方法前后前后进行拦截，在执行方法之前开启事务，在执行完目标方法后根据执行情况提交或者回滚事务</p>
<h2 id="SpringMVC执行流程"><a href="#SpringMVC执行流程" class="headerlink" title="SpringMVC执行流程"></a>SpringMVC执行流程</h2><h3 id="视图阶段（JSP）"><a href="#视图阶段（JSP）" class="headerlink" title="视图阶段（JSP）"></a>视图阶段（JSP）</h3><p><img src="/../images/shujuku/29.png" alt="视图阶段"></p>
<ol>
<li>用户发送请求到前端控制器（DispatcherServlet）</li>
<li>DispatcherServlet收到请求调用HandlerMapping（处理器映射器）</li>
<li>HandlerMapping找到具体的处理器，生成处理器对象以及处理器拦截器（如果有），再一起返回给DispathcherServlet</li>
<li>DispatcherServlet调用HandlerAdapter（处理器适配器）</li>
<li>HandlerAdapter经过适配调用具体的处理器（Handler&#x2F;Controller）</li>
<li>Controller执行完成返回ModelAndView对象</li>
<li>HandlerAdapter将Controller执行结果ModelAndView返回给DispatcherServlet</li>
<li>DispatcherServlet将ModelAndView传给ViewResolver（视图解析器）</li>
<li>ViewResolver解析后返回具体View（视图）</li>
<li>DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）</li>
<li>DispatcherServlet响应用户</li>
</ol>
<h3 id="前后端分离阶段（接口开发，异步请求）"><a href="#前后端分离阶段（接口开发，异步请求）" class="headerlink" title="前后端分离阶段（接口开发，异步请求）"></a>前后端分离阶段（接口开发，异步请求）</h3><p><img src="/../images/shujuku/30.png" alt="前后端分离阶段"></p>
<ol>
<li>用户发送请求到前端控制器（DispatcherServlet）</li>
<li>DispatcherServlet收到请求调用HandlerMapping（处理器映射器）</li>
<li>HandlerMapping找到具体的处理器，生成处理器对象以及处理器拦截器（如果有），再一起返回给DispathcherServlet</li>
<li>DispatcherServlet调用HandlerAdapter（处理器适配器）</li>
<li>HandlerAdapter经过适配调用具体的处理器（Handler&#x2F;Controller）</li>
<li>方法上添加了@ResponseBody</li>
<li>通过HttpMessageConverter来返回结构转换为JSON并响应</li>
</ol>
<h2 id="SpringBoot自动配置原理"><a href="#SpringBoot自动配置原理" class="headerlink" title="SpringBoot自动配置原理"></a>SpringBoot自动配置原理</h2><ol>
<li>在Spring Boot项目中的引导类上有一个注解@SpringBootApplication，这个注解是对三个注解进行了封装，分别是：<ul>
<li>@SpringBootConfiguration</li>
<li>@EnableAutoConfiguration</li>
<li>@ComponentScan</li>
</ul>
</li>
<li>其中**@EnableAutoConfiguration<strong>是实现自动化配置的核心注解，该注解通过</strong>@import<strong>注解导入对应的配置选择器。内部就是读取了该项目和该项目引用的Jar包的classpath路径下</strong>META-INF&#x2F;spring.factories<strong>文件中的所配置的类的全类名。在这些配置类中所定义的Bean会根据条件注解</strong>所指定的条件来决定**是否需要将其导入到Spring容器中</li>
<li>条件判断会有像@ConditionalOnClass这样的注解，判断是否有对应的class文件，如果有则加载该类，把这个配置类的所有的Bean放入spring容器中使用</li>
</ol>
<h2 id="Spring框架常见注解（Spring、SpringBoot、SpringMVC）"><a href="#Spring框架常见注解（Spring、SpringBoot、SpringMVC）" class="headerlink" title="Spring框架常见注解（Spring、SpringBoot、SpringMVC）"></a>Spring框架常见注解（Spring、SpringBoot、SpringMVC）</h2><p><strong>Spring的常见注解</strong></p>
<p><img src="/../images/shujuku/31.png" alt="Spring常见注解"></p>
<p><strong>SpringMVC常见的注解</strong></p>
<p><img src="/../images/shujuku/32.png" alt="SpringMVC常见的注解"></p>
<p><strong>SpringBoot的常见注解</strong></p>
<p><img src="/../images/shujuku/33.png" alt="SpringBoot的常见注解"></p>
<h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1><h2 id="MyBatis执行流程"><a href="#MyBatis执行流程" class="headerlink" title="MyBatis执行流程"></a>MyBatis执行流程</h2><p><img src="/../images/shujuku/34.png" alt="MyBatis执行流程"></p>
<ol>
<li>读取MyBatis配置文件：mybatis-config.xml加载运行环境和映射文件</li>
<li>构造会话工厂SqlSessionFactory</li>
<li>会话工厂创建SqlSession对象（包含了执行SQL语句的所有方法）</li>
<li>操作数据库的接口，Executor执行器，同时负责查询缓存的维护</li>
<li>Executor接口的执行方法中有一个MappedStatement类型的参数，封装了映射信息</li>
<li>输入参数映射（将java语言转换为数据库支持的）</li>
<li>输出结果映射（将数据库语言转换为java支持的）</li>
</ol>
<h2 id="MyBatis延迟加载使用及原理"><a href="#MyBatis延迟加载使用及原理" class="headerlink" title="MyBatis延迟加载使用及原理"></a>MyBatis延迟加载使用及原理</h2><p>查询用户的时候，把用户所属的订单数据也查询出来，这个是立即加载</p>
<p>查询用户的时候，暂时不查询订单数据，当需要订单的时候，再查询订单，这个就是延迟加载（按需加载）</p>
<p> MyBatis支持一对一关联对象和一对多关联集合对象的延迟加载</p>
<p>在MyBatis配置文件中，可以配置是否启用延迟加载<strong>lazyLoadingEnabled&#x3D;true|false</strong>，默认是关闭的</p>
<p><strong>延迟加载底层原理：</strong></p>
<ol>
<li>使用<strong>CGLIB</strong>创建目标对象的代理方法</li>
<li>当调用目标方法时，进入拦截器invoke方法，发现目标方法是null值，执行sql查询</li>
<li>获取数据以后，调用set方法设置属性值，再继续查询目标方法，就有值了</li>
</ol>
<h2 id="MyBatis一级、二级缓存"><a href="#MyBatis一级、二级缓存" class="headerlink" title="MyBatis一级、二级缓存"></a>MyBatis一级、二级缓存</h2><p>本地缓存，基于PerpetualCache，本质是一个HashMap</p>
<p>一级缓存：作用域是SQLsession级别</p>
<p>二级缓存：作用域是namespace和mapper的作用域，不依赖于SQLsession</p>
<p><strong>一级缓存：</strong></p>
<p>基于PerpetualCache的HashMap本地缓存，其存储作用域为SQLSession，当SQLSession进入flush或close之后，该Session中的所有Cache就将清空，默认打开一级缓存</p>
<p>示例：</p>
<p><img src="/../images/shujuku/35.png" alt="一级缓存"></p>
<p><strong>二级缓存：</strong></p>
<p>二级缓存是基于namespace和mapper的作用域起作用的，不是依赖于SQL session，默认也是采用PerpetualCache，HashMap存储</p>
<p><img src="/../images/shujuku/36.png" alt="二级缓存"></p>
<p><strong>二级缓存默认是关闭的</strong></p>
<p>开启方式，两步：</p>
<ol>
<li>全局配置文件</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>映射文件</li>
</ol>
<p>使用cache标签让当前mapper生效二级缓存</p>
<p><strong>注意事项：</strong></p>
<ol>
<li>对于缓存数据更新机制，当某一个作用域（一级缓存session&#x2F;二级缓存Namespaces）的进行了新增、修改、删除操作后，默认该作用域下所有select中的缓存被clear</li>
<li>二级缓存需要缓存的数据实现Serializable</li>
<li>只有会话提交或者关闭以后，一级缓存中的数据才会转移到二级缓存中</li>
</ol>
<h1 id="Redis面试题"><a href="#Redis面试题" class="headerlink" title="Redis面试题"></a>Redis面试题</h1><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>查询一个不存在的数据，mysql查询不到数据也不会直接写入缓存，就会导致每次请求都查数据库</p>
<p>解决方案一：缓存空数据，查询返回的数据为空，仍把这个空结果进行缓存</p>
<p>优点：简单</p>
<p>缺点：消耗内存，可能会发生不一致的问题</p>
<p>解决方案二：布隆过滤器</p>
<p>优点：内存占用较少，没有多余的key</p>
<p>缺点：实现复杂，存在误判</p>
<p>bitmap（位图）：相当于是一个以bit为单位的数组，数组中每个单元只能存储二进制数0或1</p>
<p>布隆过滤器作用：用于检索一个元素是否在一个集合中</p>
<p>存储数据：通过多个hash函数获取hash值，根据hash计算数组对应位置为1</p>
<p>查询数据：使用相同hash函数获取hash值，判断对应位置是否都为1</p>
<p>误判：数组越大误判率越小，但是同时带来了更多的内存消耗</p>
<p>布隆过滤器实现方案：Redisson、Guava</p>
<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>redis中key过期，有大量的并发请求过来，DB被压垮</p>
<p>解决方案一：互斥锁</p>
<p>解决方案二：逻辑过期</p>
<p><img src="/../images/shujuku/4.png" alt="互斥锁和逻辑过期"></p>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>同一时间段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力</p>
<p>解决方案：</p>
<ul>
<li>给不同的key的TTL添加随机值</li>
<li>利用Redis集群提高服务的可用性（哨兵模式、集群模式）</li>
<li>给缓存业务添加降级限流策略（nginx或spring cloud gateway），降级可作为系统的保底策略，适用于穿透、击穿、雪崩</li>
<li>给业务添加多级缓存（Guava或Caffeine）</li>
</ul>
<h2 id="双写一致性"><a href="#双写一致性" class="headerlink" title="双写一致性"></a>双写一致性</h2><p>两种情况：</p>
<p>允许延时一致的业务，采用异步通知</p>
<ol>
<li>使用MQ中间件，更新数据之后，通知缓存进行删除</li>
<li>利用canal中间件，不需要修改业务代码，伪装为mysql的一个从节点，canal通过读取binlog数据更新缓存</li>
</ol>
<p>强一致性的，采用Redisson提供的读写锁</p>
<p>先更新数据库，在删除缓存（缓存的写入通常要快于数据库的写入）</p>
<ol>
<li>共享锁：读锁readLock，加锁之后，其它线程可以共享读操作</li>
<li>排他锁：独占锁writeLock也叫，加锁之后，阻塞其他线程读写操作</li>
</ol>
<p><strong>延时双删：</strong>如果是写操作，我们先把缓存中的数据删除，然后更新数据库，最后再延时删除缓存中的数据，其中这个延时多久不确定，在延时的过程中可能会出现脏数据，并不能保证数据的强一致性</p>
<h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><p>持久化方式：<strong>RDB</strong>、<strong>AOF</strong></p>
<h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><p>也被叫做Redis数据快照。简单来说就是把内存中的所有数据都记录到磁盘中。当Redis实例故障重启后，从磁盘中读取快照文件，恢复数据</p>
<p>save：由Redis主进程来执行RDB，会阻塞所有命令</p>
<p>bgsave：开启子进程执行RDB，避免主进程受到影响</p>
<p>进程无法直接修改物理内存，需要通过页表进行修改</p>
<p>bgsave开始时会fork主进程得到子进程，子进程<strong>共享</strong>主进程的内存数据。完成fork后读取内存数据并写入RDB文件</p>
<p><img src="/../images/shujuku/5.png" alt="RDB"></p>
<p>还有一个问题是如果执行过程中主进程在修改数据，而子进程也在读和写数据，可能会造成脏数据</p>
<p>fork采用的是copy-on-write技术：</p>
<ul>
<li>当主进程执行读操作时，访问共享内存</li>
<li>当主进程执行写操作时，则会拷贝一份数据，执行写操作</li>
</ul>
<h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><p>Redis处理的每一个写命令都会记录在AOF文件，可以看作是命令日志文件</p>
<p>默认是关闭的，需要修改redis.conf配置文件来开启AOF</p>
<p>三种记录频率：（常见使用everysec）</p>
<p><img src="/../images/shujuku/6.png" alt="AOF"></p>
<p>因为是记录命令，AOF文件会比RDB文件大的多。而且AOF会记录对同一个key的多次写操作，但只有最后一个写操作才有意义。通过执行命令能够让AOF文件执行重写功能，用最少的命令达到相同的效果</p>
<p>RDB和AOF各有自己的优缺点，如果对数据安全性要求较高，在实际开发中往往会结合两者来使用</p>
<h2 id="数据过期策略"><a href="#数据过期策略" class="headerlink" title="数据过期策略"></a>数据过期策略</h2><p>Redis对数据设置的有效时间，数据过期以后，就需要将数据从内存中删除掉。可以按照不同的规则进行删除，这种删除规则就被称之为数据的删除策略（数据过期策略）<strong>惰性删除、定期删除</strong></p>
<p><strong>惰性删除：</strong>设置该key过期时间后，我们不去管他，当需要该key时，我们在进行检查，如果过期我们直接删除，反之返回key</p>
<p>优点：对CPU友好，只会在使用该key时才会进行过期检查，对于很多用不到的key不用浪费时间进行过期检查</p>
<p>缺点：对内存不友好，如果一个key已经过期，但是一直没有使用，那么该key就会一直存在于内存中，内存永远不会释放</p>
<p><strong>定期删除：</strong> 每隔一段时间，我们就对一些key进行检查，删除里面过期的key（从一定数量的数据库中取出一定数量的随机key进行检查，并删除其中的过期key）</p>
<p>定期清理有两种模式：</p>
<ul>
<li>SLOW模式</li>
<li>FAST模式</li>
</ul>
<p>优点：可以通过限制删除操作执行的时长和频率来减少删除操作对CPU的影响。另外定期删除，也能有效释放过期键占用的内存</p>
<p>缺点：难以确定删除操作执行的时长和频率</p>
<p>Redis的过期删除策略：惰性删除+定期删除配合使用</p>
<h2 id="数据淘汰策略"><a href="#数据淘汰策略" class="headerlink" title="数据淘汰策略"></a>数据淘汰策略</h2><p>数据淘汰策略：当Redis中的内存不够的使用时，此时向Redis中添加新的key，那么redis就会按照某一种规则将内存中的数据删除掉，这种数据的删除规则称为内存的淘汰策略</p>
<p>redis支持8中不同策略来选择要删除的key：</p>
<p>noeviction：不淘汰任何的key，但是内存满时不允许写入新的数据，<strong>默认就是这种策略</strong></p>
<p>volatile-ttl：对设置了TTL的key，比较key的剩余TTL值，TTL越小越先被淘汰</p>
<p><img src="/../images/shujuku/7.png" alt="数据淘汰策略"></p>
<p><strong>LRU：</strong>最近最少使用</p>
<p><strong>LFU：</strong>最少频率使用</p>
<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>库存超卖</p>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>Redis实现分布式锁主要利用Redis的setnx命令</p>
<p>获取锁：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">添加锁，NX是互斥、EX是设置超时时间</span></span><br><span class="line">SET lock value NX EX 10</span><br></pre></td></tr></table></figure>

<p>Redis实现分布式锁如何合理的控制锁的有效时长？</p>
<p>给锁续期</p>
<p><strong>redisson实现的分布式锁-执行流程</strong></p>
<p><img src="/../images/shujuku/8.png" alt="Redisson"></p>
<p>release Time为获取锁的最大等待时间</p>
<p>加锁、设置过期时间等操作都是基于lua脚本完成的</p>
<p><strong>redisson实现的分布式锁-可重入</strong></p>
<p>利用hash结构记录线程id和重入次数</p>
<p><strong>redisson实现的分布式锁-主从一致性</strong></p>
<p>红锁，不能只在一个redis实例上创建锁，应该是在多个redis实例上创建锁（n&#x2F;2 + 1），避免一个redis实例上加锁。</p>
<p>Redisson不能解决主从数据一致问题，但是可以使用红锁解决，但是这样的话性能就太低了，如果业务中非要保持数据的强一致性，建议采用zookeeper实现的分布式锁</p>
<h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p>单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力，就需要搭建主从集群，实现读写分离</p>
<p><strong>主从数据同步原理</strong></p>
<p>主从<strong>全量同步</strong>：</p>
<p><img src="/../images/shujuku/9.png" alt="全量同步"></p>
<p>replid：数据集的标记，id一致则说明是统一数据集。每个master都有唯一的replid，slave则会继承master节点的replid</p>
<p>offset：偏移量，随着记录在repl_baklog中的数据增多而增大。slave完成同步时也会记录当前同步的offset。如果slave的offset小于master的offset，说明slave数据落后于master，需要更新</p>
<p>主从<strong>增量同步</strong>（slave重启或后期数据变化）：</p>
<p><img src="/../images/shujuku/10.png" alt="增量同步"></p>
<h2 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h2><p>Redis提供了哨兵（Sentinel）机制来实现主从集群的自动故障恢复。</p>
<p><img src="/../images/shujuku/11.png" alt="哨兵模式结构"></p>
<p><strong>监控：</strong>Sentinel会不断检查master和slave是否按照预期工作</p>
<p><strong>自动故障恢复：</strong>如果master故障，Sentinel会将一个slave提升为master。当故障实例恢复后也以新的master为主</p>
<p><strong>通知：</strong>Sentinel充当Redis客户端的服务发现来源，当集群发生故障转移时，会将最新信息推动给Redis的客户端</p>
<p><strong>服务状态监控机制：</strong></p>
<p>Sentinel基于心跳机制检测服务状态，每隔一秒向集群的每个实例发送ping命令：</p>
<ul>
<li>主观下线：如果某个sentinel节点发现某实例未在规定时间响应，则认为该实例<strong>主观下线</strong></li>
<li>客观下线：若超过指定数量（quorum）的sentinel都认为该实例主观下线，则该实例<strong>客观下线</strong>。quorum值最好超过Sentinel实例数量的一半</li>
</ul>
<p><strong>哨兵选主规则：</strong></p>
<ul>
<li>首先判断主与从节点断开时间长短，如超过指定值就排除该从节点</li>
<li>然后判断从节点的slave-priority值，越小优先级越高</li>
<li><strong>如果slave-priority一样，则判断slave节点的offset值，越大则优先级越高</strong></li>
<li>最后是判断slave节点的运行id大小，越小优先级越高</li>
</ul>
<p><img src="/../images/shujuku/12.png" alt="选主图示"></p>
<h2 id="脑裂"><a href="#脑裂" class="headerlink" title="脑裂"></a>脑裂</h2><p><strong>集群脑裂</strong>是由于主节点和从节点和sentinel处于不同的网络分区，使得sentinel没有能够心跳感知到主节点，所以通过选举的方式提升了一个从节点为主，这样就存在了两个master，就像大脑分裂一样，这样会导致客户端还在老的主节点那里写入数据，新节点无法同步数据，当网络恢复后，sentinel会将老的主节点降为从节点，这时再从新master同步数据，就会导致数据丢失</p>
<p>解决：可以设置最少的从节点数量以及缩短主从数据同步的延迟时间，达不到要求就拒绝请求，就可以避免大量的数据丢失</p>
<h2 id="分片集群结构"><a href="#分片集群结构" class="headerlink" title="分片集群结构"></a>分片集群结构</h2><p>主从可以解决高并发读的问题，哨兵可以解决高可用问题，但是还有两个问题没有解决：</p>
<ul>
<li>海量数据存储的问题</li>
<li>高并发写的问题</li>
</ul>
<p>使用分片集群可以解决上述问题，分片集群特征：</p>
<ul>
<li>集群中有多个master，每个master保存有不同的数据</li>
<li>每个master都可以有多个slave节点</li>
<li>master之间通过ping检测彼此健康状态</li>
<li>客户端请求可以访问集群任意节点，最终都会被转发到正确节点</li>
</ul>
<p><img src="/../images/shujuku/13.png" alt="分片集群结构"></p>
<p><strong>数据读写：</strong>Redis分片集群引入了哈希槽的概念，Redis集群有16384个哈希槽，每个key通过CRC16校验后对16384取模来决定放置哪个槽，集群的每个节点负责一部分hash槽</p>
<p><img src="/../images/shujuku/14.png" alt="hash槽"></p>
<p>读写数据：根据key的<strong>有效部分</strong>计算哈希值，对16384取余（<strong>有效部分</strong>，如果key前面有大括号，大括号的内容就是有效部分，如果没有，则以key本身作为有效部分）余数作为插槽，寻找插槽所在的实例</p>
<h2 id="Redis为单线程，但是为什么那么快？"><a href="#Redis为单线程，但是为什么那么快？" class="headerlink" title="Redis为单线程，但是为什么那么快？"></a>Redis为单线程，但是为什么那么快？</h2><ul>
<li>Redis是纯内存操作，执行速度非常快</li>
<li>采用单线程，避免不必要的上下文切换可竞争条件，多线程还要考虑线程安全问题</li>
<li>采用I&#x2F;O多路复用模型，非阻塞IO</li>
</ul>
<h2 id="能解释一下I-O多路复用模型吗？"><a href="#能解释一下I-O多路复用模型吗？" class="headerlink" title="能解释一下I&#x2F;O多路复用模型吗？"></a>能解释一下I&#x2F;O多路复用模型吗？</h2><p>Redis是纯内存操作，执行速度非常快，它的性能瓶颈是<strong>网络延迟</strong>而不是执行速度，I&#x2F;O多路复用模型主要就是为了实现高效的网络请求</p>
<ul>
<li>用户空间和内核空间</li>
<li>常见的I&#x2F;O模型<ul>
<li>阻塞IO</li>
<li>非阻塞IO</li>
<li>IO多路复用</li>
</ul>
</li>
<li>Redis网络模型</li>
</ul>
<p>Linux系统为了提高IO效率，会在用户空间和内核空间都加入缓冲区：</p>
<ul>
<li>写数据时，要把用户缓冲区数据拷贝到内核缓冲区，然后写入设备</li>
<li>读数据时，要从设备读取数据到内核缓冲区，然后拷贝到用户缓冲区</li>
</ul>
<p><img src="/../images/shujuku/15.png" alt="用户空间和内核空间"></p>
<p><strong>阻塞IO</strong></p>
<p><img src="/../images/shujuku/16.png" alt="阻塞IO"></p>
<p><strong>非阻塞IO</strong></p>
<p><img src="/../images/shujuku/17.png" alt="非阻塞IO"></p>
<p><strong>IO多路复用</strong></p>
<p><img src="/../images/shujuku/18.png" alt="IO多路复用"></p>
<p>监听Socket的方式、通知的方式又有多种实现，常见的有：</p>
<ul>
<li>select</li>
<li>poll</li>
<li>epoll</li>
</ul>
<p>select和poll只会通知用户进程有Socket就绪，但不确定具体是哪个Socket，需要用户进程逐个遍历Socket来确认</p>
<p>epoll则会在通知用户进程Socket就绪的同时，把已就绪的Socket写入用户空间</p>
<p><strong>Redis网络模型</strong></p>
<p>Redis通过IO多路复用来提高网络性能，并且支持各种不同的多路复用实现，并且将这些实现进行封装，提供了统一的高性能事件库</p>
<p><img src="/../images/shujuku/19.png" alt="Redis网络模型"></p>
<p>命令回复处理器：在Redis6.0之后，为了提升更好的性能，使用了多线程来处理回复事件</p>
<p>命令请求处理器：在Redis6.0之后，将命令的转换使用了多线程，增加命令转换速度，在命令执行的时候，依然是多线程</p>
<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="如何定位慢查询"><a href="#如何定位慢查询" class="headerlink" title="如何定位慢查询"></a>如何定位慢查询</h2><p>聚合查询</p>
<p>多表查询</p>
<p>表数据量过大查询</p>
<p>深度分页查询</p>
<p>表象：页面加载过慢、接口压测响应时间过长（超过1s）</p>
<p>方案一：开源工具</p>
<ul>
<li>调试工具：Arthas</li>
<li>运维工具：Prometheus、Skywalking</li>
</ul>
<p>Skywalking，测试接口响应速度</p>
<p>方案二：MySQL自带慢日志</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">开启MySQL慢日志查询开关</span></span><br><span class="line">slow_query_log=1</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志</span></span><br><span class="line">long_query_time=2</span><br></pre></td></tr></table></figure>

<p>配置完成后，重新启动MySQL服务器，查看慢日志文件中记录的信息</p>
<h2 id="SQL语句执行很慢，如何分析呢？"><a href="#SQL语句执行很慢，如何分析呢？" class="headerlink" title="SQL语句执行很慢，如何分析呢？"></a>SQL语句执行很慢，如何分析呢？</h2><p>可以采用<strong>EXPLAIN</strong>或者<strong>DESC</strong>命令获取MySQL如何执行SELECT语句的信息</p>
<p><img src="/../images/shujuku/20.png" alt="EXPLAIN结构"></p>
<ul>
<li>possible_keys：当前sql可能会使用到的索引</li>
<li>key：当前sql实际命中的索引</li>
<li>key_len：索引占用的大小（<strong>通过key和key_len检查是否命中了索引</strong>）</li>
<li>Extra：额外的优化建议</li>
</ul>
<p><img src="/../images/shujuku/21.png" alt="Extra"></p>
<ul>
<li>type：这条sql的连接的类型，性能由差到好为：all、index、range、ref、eq_ref、const、system、NULL<ul>
<li>all：全表扫描</li>
<li>index：索引树扫描</li>
<li>range：范围查询</li>
<li>ref：索引查询</li>
<li>eq_ref：主键索引查询或唯一索引查询</li>
<li>const：根据主键查询</li>
<li>system：查询系统中的表</li>
</ul>
</li>
</ul>
<h2 id="索引概念及底层数据结构"><a href="#索引概念及底层数据结构" class="headerlink" title="索引概念及底层数据结构"></a>索引概念及底层数据结构</h2><p>索引（index）是帮助MySQL高效获取数据的数据结构（有序）。在数据之外，数据库系统还维护着满足特定查找算法的数据结构（B+树），这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引</p>
<p>B树是一种多叉路衡查找树，相对于二叉树，B树每个节点可以有多个分支，即多叉</p>
<p><img src="/../images/shujuku/23.png" alt="B树"></p>
<p>B+Tree是在BTree基础上的一种优化，使其更适合实现外存储索引结构，InnoDB存储引擎就是用B+Tree实现其索引结构</p>
<p><img src="/../images/shujuku/24.png" alt="B+树"></p>
<p>B树与B+树对比：</p>
<p>磁盘读写代价B+树更低</p>
<p>查询效率B+树更加稳定</p>
<p>B+树便于扫库和区间查询 </p>
<p>MySQL的InnoDB引擎采用的B+树的数据结构来存储索引：</p>
<ul>
<li>阶数更多，路径更短</li>
<li>磁盘读写代价B+树更低，非叶子节点只存储指针，叶子节点存储数据</li>
<li>B+树便于扫库和区间查询，叶子节点是一个双向链表</li>
</ul>
<h2 id="聚簇索引和非聚簇索引、回表查询"><a href="#聚簇索引和非聚簇索引、回表查询" class="headerlink" title="聚簇索引和非聚簇索引、回表查询"></a>聚簇索引和非聚簇索引、回表查询</h2><p><img src="/../images/shujuku/25.png" alt="聚集索引和非聚集索引"></p>
<p>聚集索引选取规则：</p>
<ul>
<li>如果存在主键，主键索引就是聚集索引</li>
<li>如果不存在主键，将使用第一个唯一索引作为聚集索引</li>
<li>如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引</li>
</ul>
<p><strong>一张图直观展示什么是聚簇索引和非聚簇索引？</strong></p>
<p><img src="/../images/shujuku/26.png" alt="聚簇索引和非聚簇索引"></p>
<p> <strong>回表查询：</strong>通过二级索引找到对应的主键值，到聚集索引中查找整行数据，这个过程就是回表</p>
<h2 id="覆盖索引、超大分页优化"><a href="#覆盖索引、超大分页优化" class="headerlink" title="覆盖索引、超大分页优化"></a>覆盖索引、超大分页优化</h2><p><strong>覆盖索引</strong>是指查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到</p>
<p><img src="/../images/shujuku/27.png" alt="覆盖索引"></p>
<p>第二个id和name都可以在name二级索引中查到，所以为覆盖索引</p>
<p><strong>MYSQL超大分页处理</strong></p>
<p>在数据量比较大时，如果进行limit分页查询，在查询时，越往后，分页查询效率越低</p>
<p><img src="/../images/shujuku/28.png" alt="使用limit查询"></p>
<p>当在进行分页查询时，如果执行limit 9000000，10，此时需要MySQL排序前9000010记录，仅仅返回9000000-9000010的记录，其他记录丢弃，查询排序的代价非常大</p>
<p>优化思路：一般分页查询，通过创建<strong>覆盖索引</strong>能够比较好地提高性能，可以通过<strong>覆盖索引</strong>加<strong>子查询</strong>形式进行优化</p>
<p><strong>MYSQL超大分页怎么处理？</strong></p>
<p>超大分页一般都是在数据量比较大时，我们使用了limit分页查询，并且需要对数据进行排序，这个时候效率就很低，我们可以采用覆盖索引和子查询来解决</p>
<p>先分页查询数据的id字段，确定了id之后，再用子查询来过滤，只查询这个id列表中的数据就可以了，因为查询id的时候，走的是覆盖索引，所以效率可以提升很多</p>
<h2 id="索引创建的原则"><a href="#索引创建的原则" class="headerlink" title="索引创建的原则"></a>索引创建的原则</h2><ol>
<li>数据量大，且查询比较频繁的表</li>
<li>常作为查询条件、排序、分组的字段</li>
<li>尽量联合索引</li>
<li>要控制索引的数量</li>
<li>字段内容区分度高</li>
<li>内容较长，使用前缀索引</li>
<li>如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它</li>
</ol>
<h2 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h2><ol>
<li>违反最左前缀法则</li>
</ol>
<p>如果索引了多列，要遵循最左前缀法则。指的是查询从索引的最左前列开始，并且不跳过索引中的列。匹配最左前缀法则</p>
<ol start="2">
<li>范围查询的列的右边的列，不能使用索引</li>
<li>不要在索引列上进行运算操作，索引将失效</li>
<li>字符串不加单引号，造成索引失效（类型转换）</li>
<li>以%开头的Like模糊查询，索引失效</li>
</ol>
<h2 id="sql优化的经验"><a href="#sql优化的经验" class="headerlink" title="sql优化的经验"></a>sql优化的经验</h2><ol>
<li><p><strong>表的设计优化</strong></p>
<ol>
<li>比如设置合适的数值（int、bigint），要根据实际情况选择</li>
<li>比如设置合适的字符串类型（char和varchar）char定长效率高，varchar可变长度，效率低</li>
</ol>
</li>
<li><p><strong>SQL语句优化</strong></p>
<ol>
<li>SELECT语句务必指明字段名称（避免直接使用select *）</li>
<li>SQL语句要避免造成索引失效的写法</li>
<li>尽量用union all代替union union回多一次过滤，效率低</li>
<li>避免在where子句中对字段进行表达式操作</li>
<li>Join优化 能用innerjoin就不用left join right join，如必须使用 一定要以小表为驱动（内连接回对两个表进行优化，优先把小表放到表外，把大表放到里边。left join或right join，不会重新调整顺序）</li>
</ol>
</li>
<li><p><strong>索引优化，索引创建原则</strong></p>
</li>
<li><p><strong>主从复制、读写分离，不让数据的写入影响读的操作</strong></p>
</li>
<li><p>分库分表</p>
</li>
</ol>
<h1 id="Spring-Cloud"><a href="#Spring-Cloud" class="headerlink" title="Spring Cloud"></a>Spring Cloud</h1><h2 id="常见组件"><a href="#常见组件" class="headerlink" title="常见组件"></a>常见组件</h2><p>注册中心&#x2F;配置中心：Nacos&#x2F;Eureka&#x2F;zookeeper</p>
<p>负载均衡：Ribbon</p>
<p>服务调用：Feign</p>
<p>服务保护：sentinel</p>
<p>服务网关：Gateway</p>
<h2 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h2><p><strong>Eureka的作用：</strong></p>
<p><img src="/../images/shujuku/37.png" alt="Eureka"></p>
<ul>
<li>我们当时项目采用的eureka作为注册中心，这个也是spring cloud体系中的一个核心组件</li>
<li><strong>服务注册：</strong>服务提供者需要把自己的信息注册到eureka，由eureka来保存这些信息，比如服务名称、IP、端口等等</li>
<li><strong>服务发现：</strong>消费者向eureka拉取服务列表信息，如果服务提供者有集群，则消费者会利用负载均衡算法，选择一个发起调用</li>
<li><strong>服务监控：</strong>服务提供者会每隔30秒向eureka发送心跳，报告健康状态，如果eureka服务90秒没有接收到心跳，从eureka中剔除</li>
</ul>
<p><strong>nacos和eureka的区别：</strong></p>
<ol>
<li>Nacos支持服务端主动检测提供者状态：临时实例采用心跳模式，非临时实例采用主动检测模式</li>
<li>临时实例心跳不正常会被剔除，非临时实例则不会被剔除</li>
<li>Nacos支持服务列表更新的消息推送模式，服务列表更新更及时</li>
<li>Nacos集群默认采用AP方式，当集群中存在非临时实例时，采用CP模式；Eureka采用AP方式</li>
</ol>
<ul>
<li>Nacos还支持配置中心，eureka则只有注册中心，也是选择使用nacos的一个重要原因</li>
</ul>
<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p><strong>Ribbon负载均衡流程</strong></p>
<p><img src="/../images/shujuku/38.png" alt="Ribbon负载均衡流程"></p>
<p><strong>Ribbon负载均衡策略：</strong></p>
<ul>
<li>简单轮询</li>
<li>按照权重选择服务器，响应时间越长，权重越小</li>
<li>随机选择一个可用的服务器</li>
<li>区域敏感策略：以区域可用的服务器为基础进行服务器的选择。使用Zone对服务器进行分类，这个Zone可以理解为一个机房、一个机架等。而后再对Zone内的多个服务做轮询（默认）</li>
<li>一致性哈希：根据请求的客户端 ip、或请求参数通过哈希算法得到一个数值，利用该数值取模映射出对应的后端服务器，这样能保证同一个客户端或相同参数的请求每次都使用同一台服务器</li>
<li>最小活跃数：统计每台服务器上当前正在处理的请求数，也就是请求活跃数，将请求分发给活跃数最少的后台服务器</li>
</ul>
<p><strong>如何自定义负载均衡策略：</strong></p>
<ol>
<li>创建类实现IRule接口，可以指定负载均衡策略（全局）</li>
<li>在客户端的配置文件中，可以配置某一个服务调用的负载均衡策略（局部）</li>
</ol>
<h2 id="服务雪崩"><a href="#服务雪崩" class="headerlink" title="服务雪崩"></a>服务雪崩</h2><p>服务雪崩：一个服务失败，导致整条链路的服务都失败的情形</p>
<p>服务降级：服务自我保护的一种方式，或者保护下游服务的一种方式，用于确保服务不会受请求突增影响变得不可用，确保服务不会崩溃，<strong>一般在实际开发中与feign接口整合，编写降级逻辑</strong>（针对接口）</p>
<p>服务熔断：默认关闭，需要手动打开，如果检测<strong>到10秒内请求的失败率到达50%<strong>，就触发熔断机制。之后</strong>每隔5秒重新尝试请求</strong>微服务，如果微服务不能响应，继续走熔断机制。如果微服务可达，则关闭熔断机制，恢复正常请求</p>
<h2 id="微服务的监控"><a href="#微服务的监控" class="headerlink" title="微服务的监控"></a>微服务的监控</h2><ul>
<li>问题定位</li>
<li>性能分析</li>
<li>服务关系</li>
<li>服务告警</li>
</ul>
<p><strong>skywalking</strong></p>
<p>一个分布式系统的应用程序性能监控工具（APM），提供了完善的链路追踪能力，apache的顶级项目</p>
<p><img src="/../images/shujuku/39.png" alt="服务展示"></p>
<ul>
<li>服务（service）：业务资源应用系统（微服务）</li>
<li>端点（endpoint）：应用系统对外暴露的功能接口（接口）</li>
<li>实例（instance）：物理机</li>
</ul>
<p>我们项目中采用的skywalking进行监控的</p>
<ol>
<li>skywalking主要可以监控接口、服务、物理实例的一些状态。特别是在压测的时候可以看到众多服务中哪些服务和接口比较慢，我们可以针对性的分析和优化</li>
<li>我们还在skywalking设置了告警规则，特别是在项目上线以后，如果报错，我们分别设置了可以给相关负责人发短信和发邮件，第一时间知道项目的bug情况，第一时间修复</li>
</ol>
<h2 id="微服务限流"><a href="#微服务限流" class="headerlink" title="微服务限流"></a>微服务限流</h2><p>为什么要限流？</p>
<ol>
<li>并发的确大（突发流量）</li>
<li>防止用户恶意刷接口</li>
</ol>
<p>限流的实现方式：</p>
<ul>
<li>Tomcat：可以设置最大连接数</li>
<li>Nginx，漏桶算法</li>
<li>网关，令牌桶算法</li>
<li>自定义拦截器</li>
</ul>
<h3 id="Nginx限流"><a href="#Nginx限流" class="headerlink" title="Nginx限流"></a>Nginx限流</h3><p><strong>控制速率（突发流量）</strong></p>
<p><img src="/../images/shujuku/40.png" alt="漏桶算法"></p>
<p>请求会先进入桶中，如果请求很多超过桶的容量则等待或抛弃。漏桶以固定的速率漏出请求</p>
<p><strong>控制并发连接数</strong></p>
<p>限制单个ip的连接数和整个服务并发连接的总数</p>
<h3 id="网关限流"><a href="#网关限流" class="headerlink" title="网关限流"></a>网关限流</h3><p><img src="/../images/shujuku/41.png" alt="令牌桶算法"></p>
<p>在spring cloud gateway中支持局部过滤器RequestRateLimiter来做限流，使用的是令牌桶算法</p>
<p>可以根据IP或路径进行限流，可以设置每秒填充平均速率和令牌桶总容量</p>
<h2 id="CAP和BASE"><a href="#CAP和BASE" class="headerlink" title="CAP和BASE"></a>CAP和BASE</h2><p><strong>CAP定理</strong></p>
<p><img src="/../images/shujuku/42.png" alt="CAP"></p>
<ul>
<li>Consistency（一致性）：用户访问分布式系统中的任意节点，得到的数据必须一致</li>
<li>Availability（可用性）：用户给访问集群中的任意健康节点，必须能得到响应，而不是超时或拒绝</li>
<li>Partition tolerance（分区容错性）<ul>
<li>Partition（分区）：因为网络故障或其它原因导致分布式系统中的部分节点与其它节点失去连接，形成独立分区。</li>
<li>Tolerance（容错）：在集群出现分区时，整个系统也要持续对外提供服务</li>
</ul>
</li>
</ul>
<p>分布式系统无法同时满足这三个指标</p>
<p>结论：</p>
<ul>
<li>分布式系统节点之间肯定是需要网络连接的：<strong>分区（P）是必然存在的</strong></li>
<li>如果保证访问的高可用性（A），可以持续对外提供服务，但不能保证数据的强一致性 &#x3D;&#x3D;&gt; <strong>AP</strong></li>
<li>如果保证访问的数据强一致性（C），就要放弃高可用性 &#x3D;&#x3D;&gt; <strong>CP</strong></li>
</ul>
<p><strong>BASE理论</strong></p>
<p>BASE理论是对CAP的一种解决思路，包含三个思想：</p>
<ul>
<li><strong>基本可用</strong>：分布式系统在出现故障时，允许损失部分可用性，即保证核心可用</li>
<li><strong>软状态</strong>：在一定时间内，允许出现中间状态，比如临时的不一致状态</li>
<li><strong>最终一致性</strong>：虽然无法保证强一致性，但是在软状态结束后，最终达到数据一致</li>
</ul>
<p>解决分布式事务的思想和模型：</p>
<ol>
<li>最终一致思想：各分支事务分别执行并提交，如果有不一致的情况，再想办法恢复数据（AP）</li>
<li>强一致思想：各分支事务执行完业务不要提交，等待彼此结果。而后统一提交或回滚（CP）</li>
</ol>
<h2 id="分布式事务解决方案"><a href="#分布式事务解决方案" class="headerlink" title="分布式事务解决方案"></a>分布式事务解决方案</h2><p><strong>Seata架构：</strong></p>
<p>Seata事务管理中有三个重要的角色：</p>
<ul>
<li><strong>TC-事务协调者</strong>：维护全局和分支事务的状态，协调全局事务提交或回滚</li>
<li><strong>TM-事务管理器</strong>：定义全局事务的范围、开始全局事务、提交或回滚全局事务</li>
<li><strong>RM-资源管理器</strong>：管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚</li>
</ul>
<p>seata的XA模式，CP，需要互相等待各个分支事务提交，可以保证强一致性，性能差（<strong>银行业务</strong>）</p>
<p>seata的AT模式，AP，底层使用undo log实现，性能好</p>
<p>seata的TCC模式，AP，性能好，不过需要人工编码</p>
<p>MQ模式实现分布式事务，在A服务写数据的时候，需要在同一个事务内发送消息到另外一个事务，异步，性能最好（<strong>互联网业务</strong>）</p>
<h2 id="分布式服务的接口幂等性"><a href="#分布式服务的接口幂等性" class="headerlink" title="分布式服务的接口幂等性"></a>分布式服务的接口幂等性</h2><p>幂等：多次调用方法或者接口不会改变业务状态，可以保证重复调用接口的结果和单次调用的结果一致</p>
<p>需要幂等场景</p>
<ul>
<li>用户重复点击（网络波动）</li>
<li>MQ消息重复</li>
<li>应用使用失败或超时重试机制</li>
</ul>
<p><strong>接口幂等</strong></p>
<p>基于RESTful API的角度对部分常见类型请求的幂等性特点进行分析</p>
<p><img src="/../images/shujuku/43.png" alt="接口幂等分析"></p>
<p><strong>数据库唯一索引</strong>：解决新增幂等</p>
<p><strong>token+redis</strong>：解决新增和修改幂等</p>
<p>创建商品、提交订单、转账、支付等操作</p>
<p><img src="/../images/shujuku/44.png" alt="token+redis"></p>
<p>当用于点击立即购买，会在redis中存储一个token，这时候跳转到订单页面</p>
<p>在订单页面点击提交，为第二次请求，验证token是否存在，存在直接删除，执行业务；后续多次请求token不存在，则不处理业务</p>
<p><strong>分布式锁</strong>：解决新增和修改幂等</p>
<ul>
<li>快速失败（抢不到锁的线程）</li>
<li>控制锁的粒度（越小越好，避免其它线程等待）</li>
</ul>
<h2 id="分布式任务调度"><a href="#分布式任务调度" class="headerlink" title="分布式任务调度"></a>分布式任务调度</h2><p><strong>xxl-job解决的问题</strong></p>
<ul>
<li>解决集群任务的重复执行问题</li>
<li>cron表达式定义灵活</li>
<li>定时任务失败了，重试和统计</li>
<li>任务量大，分片执行</li>
</ul>
<p><strong>xxl-job路由策略</strong></p>
<ol>
<li>轮询，任务1选择机器1，任务2选择机器2，任务3选择机器1，以此类推</li>
<li>故障转移：按照顺序依次进行心跳检测，第一个心跳检测成功的机器选定为目标执行器并发起调度</li>
<li>分片广播：广播触发对应集群中所有机器执行一次任务，同时系统自动传递分片参数；可根据分片参数开发分片任务</li>
<li>一致性hash</li>
<li>最不经常使用</li>
<li>最近最久未使用</li>
<li>忙碌转移：按照顺序依次进行空闲检测，第一个空闲检测成功的机器选定为目标执行器并发起调度</li>
</ol>
<p><strong>xxl-job任务执行失败怎样解决</strong></p>
<p>故障转移+失败重试，查看日志分析&#x3D;&#x3D;&gt;邮件告警</p>
<p><strong>如果有大数据量的任务同时执行，怎样解决</strong></p>
<p>执行器部署时，任务路由策略选择<strong>分片广播</strong>情况下，<strong>一次任务</strong>调度将会广播触发对应集群中所有执行器执行一次任务</p>
<p><img src="/../images/shujuku/45.png" alt="分片广播"></p>
<p>分片参数：</p>
<ul>
<li>index：当前分片序号（从0开始），执行器集群列表中当前执行器的序号</li>
<li>total：总分片数，执行器集群的总机器数量</li>
</ul>
<h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><h2 id="如何保证消息不丢失"><a href="#如何保证消息不丢失" class="headerlink" title="如何保证消息不丢失"></a>如何保证消息不丢失</h2><p>消息丢失情况：</p>
<p><img src="/../images/shujuku/46.png" alt="消息丢失"></p>
<p><strong>生产者确认机制</strong></p>
<p>RabbitMQ提供了publisher confirm机制来避免消息发送到MQ过程中丢。消息发送到MQ以后，会返回一个结果给发送者，表示消息是否处理成功</p>
<p><img src="/../images/shujuku/47.png" alt="生产者确认"></p>
<p>消息发送失败之后如何处理：</p>
<ul>
<li>回调消息即时重发</li>
<li>记录日志</li>
<li>保存到数据库然后定时重发，成功发送后即刻删除表中的数据</li>
</ul>
<p><strong>消息持久化</strong></p>
<p>MQ默认是内存存储消息，开启持久化功能可以确保缓存在MQ中的消息不丢失</p>
<ol>
<li>交换机持久化</li>
<li>队列持久化</li>
<li>消息持久化，SpringAMQP中的消息默认是持久的，可以通过MessageProperties中的DeliveryMode来指定</li>
</ol>
<p><strong>消费者确认</strong></p>
<p>RabbitMQ支持消费者确认机制，即：消费者处理消息后可以向MQ发送ack回执，MQ收到ack回执后才会删除该消息，而SpringAMQP则允许配置三种确认模式：</p>
<ul>
<li>manual：手动ack，需要在业务代码结束后，调用api发送ack</li>
<li>auto：自动ack，由spring监测listener代码是否出现异常，没有异常则返回ack；抛出异常则返回nack</li>
<li>none：关闭ack，MQ假定消费者获取消息后会成功处理，因此消息投递后立即被删除</li>
</ul>
<p>我们可以利用Spring的retry机制，在消费者出现异常时利用本地重试，设置重试次数，当次数到达了以后，如果消息依然失败，将消息投递到异常交换机，交由人工处理</p>
<h2 id="RabbitMQ重复消费问题"><a href="#RabbitMQ重复消费问题" class="headerlink" title="RabbitMQ重复消费问题"></a>RabbitMQ重复消费问题</h2><ul>
<li>网络抖动</li>
<li>消费者挂了</li>
</ul>
<p>解决方案：</p>
<ul>
<li>每条消息设置一个唯一的标识id（优先考虑）</li>
<li>幂等方案：分布式锁，数据库锁</li>
</ul>
<p><img src="/../images/shujuku/48.png" alt="重复消费"></p>
<h2 id="死信交换机（延迟队列）"><a href="#死信交换机（延迟队列）" class="headerlink" title="死信交换机（延迟队列）"></a>死信交换机（延迟队列）</h2><p>延迟队列：进入队列的消息会被延迟消费的队列</p>
<p>场景：超时订单、限时优惠、定时发布</p>
<p><strong>延迟队列&#x3D;死信交换机+TTL（生存时间）</strong></p>
<p><strong>死信交换机</strong></p>
<p>当一个队列中的消息满足下列情况之一时，可以成为<strong>死信（dead letter）</strong></p>
<ul>
<li>消费者使用basic.reject或basic.nack声明消费失败，并且消息的requeue参数设置为false</li>
<li>消息是一个过期消息，超时无人消费</li>
<li>要投递的队列消息堆积满了，最早的消息可能成为死信</li>
</ul>
<p>如果该队列配置了dead-letter-exchange属性，指定了一个交换机，那么队列中的死信就会投递到这个交换机中，而这个交换机</p>
<p>称为<strong>死信交换机（DLX）</strong></p>
<p><img src="/../images/shujuku/49.png" alt="死信交换机"></p>
<p><strong>TTL</strong></p>
<p>如果一个队列中的消息TTL结束仍未消费，则会变为死信，ttl超时分为两种情况：</p>
<ul>
<li>消息所在的队列设置了存活时间</li>
<li>消息本身设置了存活时间</li>
</ul>
<p><img src="/../images/shujuku/50.png" alt="TTL"></p>
<p>延迟队列插件实现延迟队列</p>
<h2 id="消息堆积"><a href="#消息堆积" class="headerlink" title="消息堆积"></a>消息堆积</h2><p>当生产者发送消息的速度超过了消费者处理消息的速度，就会导致队列中的消息堆积，直到队列存储消息达到上限。之后发送的消息就会成为死信，可能会被丢弃，这就是消息堆积问题</p>
<p>解决消息堆积有三种思路：</p>
<ul>
<li>增加更多消费者，提高消费速度</li>
<li>在消费者内开启线程池加快消息处理速度</li>
<li>扩大队列容积，提高堆积上限，采用惰性队列</li>
</ul>
<p><strong>惰性队列</strong></p>
<p>惰性队列的特征如下：</p>
<ul>
<li>接收到消息后直接存入磁盘而非内存</li>
<li>消费者要消费消息时才会从磁盘中读取并加载到内存</li>
<li>支持数百万条的消息存储</li>
</ul>
<h2 id="RabbitMQ高可用机制"><a href="#RabbitMQ高可用机制" class="headerlink" title="RabbitMQ高可用机制"></a>RabbitMQ高可用机制</h2><p>在生产环境下，使用集群来保证高可用性</p>
<p><strong>普通集群</strong></p>
<p>普通集群，或者叫做标准集群，具备以下特征：</p>
<ul>
<li>会在集群的各个节点间共享部分数据，包括：交换机、队列元信息。不包含队列中的消息</li>
<li>当访问集群某节点时，如果队列不在该节点，会从数据所在节点传递到当前节点并返回</li>
<li>队列所在节点宕机，队列中的消息就会消失</li>
</ul>
<p><strong>镜像集群</strong></p>
<p>镜像集群：本质是主从模式，具备下面的特征：</p>
<ul>
<li>交换机、队列、队列中的消息会在各个mq的镜像节点之间同步备份</li>
<li>创建队列的节点被称为该队列的<strong>主节点</strong>，备份到的其它节点叫做该队列的<strong>镜像</strong>节点</li>
<li>一个队列的主节点可能是另一个队列的镜像节点</li>
<li>所有操作都是主节点完成，然后同步给镜像节点</li>
<li>主节点宕机后，镜像节点会替代称为新的主节点</li>
</ul>
<p>如果在主从同步完成前，主节点已经宕机了，可能会出现数据丢失</p>
<p><img src="/../images/shujuku/51.png" alt="镜像集群"></p>
<p><strong>仲裁队列</strong></p>
<p>仲裁队列：仲裁队列是3.8版本以后才有的新功能，用来替代镜像队列，具备以下特征：</p>
<ul>
<li>与镜像队列一样，都是主从模式，支持主从数据同步</li>
<li>使用非常简单，没有复杂的配置</li>
<li>主从同步基于Raft协议，强一致</li>
</ul>
<h1 id="kafka"><a href="#kafka" class="headerlink" title="kafka"></a>kafka</h1><h2 id="Kafka是如何保证消息不丢失"><a href="#Kafka是如何保证消息不丢失" class="headerlink" title="Kafka是如何保证消息不丢失"></a>Kafka是如何保证消息不丢失</h2><p>需要从三个层面去解决这个问题：</p>
<ul>
<li><p>生产者发送消息到Brocker丢失</p>
<ul>
<li>设置异步发送，发送失败使用回调进行记录或重发</li>
<li>失败重试，参数配置，可以设置重试次数</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置重试次数</span></span><br><span class="line">prop.put(ProducerConfig.RETRIES_CONFIG,<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>消息在Brocker中存储丢失</p>
<ul>
<li>发送确认acks，选择all，让所有的副本都参与保存数据后确认</li>
</ul>
<p><img src="/../images/shujuku/53.png" alt="发送消息"></p>
<p><img src="/../images/shujuku/52.png" alt="回调确认"></p>
</li>
</ul>
<p>Kafka中的分区机制指的是将每个主题划分为多个分区（Partition）</p>
<p>topic分区中消息只能由消费组中的唯一消费者处理，不同的分区分配给不同的消费者（同一个消费者组）</p>
<p>消费者默认是自动按期提交已经消费的偏移量，默认是每隔5s提交一次。如果出现重平衡的情况，可能会出现重复消费或丢失数据</p>
<ul>
<li><p>消费者从Brocker接受消息丢失</p>
<ul>
<li><p>关闭自动提交偏移量，开启手动提交偏移量</p>
</li>
<li><p>提交方式，最好是同步+异步</p>
</li>
</ul>
</li>
</ul>
<p><strong>Kafka中消息的重复消费问题如何解决的</strong></p>
<ul>
<li>关闭自动提交偏移量，开启手动提交偏移量</li>
<li>提交方式，最好是同步+异步</li>
<li>幂等方案</li>
</ul>
<h2 id="Kafka如何保证消费的顺序性"><a href="#Kafka如何保证消费的顺序性" class="headerlink" title="Kafka如何保证消费的顺序性"></a>Kafka如何保证消费的顺序性</h2><p>应用场景：</p>
<ul>
<li>即时消息中的单对单聊天和群聊，保证发送方消息发送顺序与接收方的顺序一致</li>
<li>充值转账两个渠道在同一时间进行余额变更，短信通知必须要有顺序</li>
</ul>
<p><img src="/../images/shujuku/54.png" alt="分区"></p>
<p>topic分区中消息只能由消费者组中的唯一消费者进行消费，所以消息肯定是按照先后顺序进行处理的。但是它也仅仅时保证Topic的一个分区顺序处理，不能保证跨分区的消息先后处理顺序。所以，如果你想要顺序的处理Topic的所有消息，那就只提供一个分区</p>
<p><strong>问题原因：</strong></p>
<p>一个topic的数据可能存储在不同的分区中，每个分区都有一个按照顺序的偏移量，如果消费者关联了多个分区不能保证顺序</p>
<p><strong>解决方案：</strong></p>
<ul>
<li>发送消息时指定分区号</li>
<li>发送消息时按照相同的业务设置相同的key（指定分区）</li>
</ul>
<h2 id="Kafka的高可用机制有了解过吗"><a href="#Kafka的高可用机制有了解过吗" class="headerlink" title="Kafka的高可用机制有了解过吗"></a>Kafka的高可用机制有了解过吗</h2><ul>
<li>集群模式</li>
<li>分区备份机制</li>
</ul>
<p><strong>集群模式</strong></p>
<p><img src="/../images/shujuku/55.png" alt="集群模式"></p>
<ul>
<li>Kafka的服务器端由被称为Broker的服务进程构成，即一个Kafka集群由多个Broker组成</li>
<li>这样如果集群中某一台机器宕机，其它机器上的Broker也依然能够对外提供服务。这其实就是Kafka提供高可用的手段之一</li>
</ul>
<p><strong>分区备份机制</strong></p>
<p><img src="/../images/shujuku/56.png" alt="分区备份"></p>
<ul>
<li>一个topic有多个分区，每个分区有多个副本，其中有一个leader，其余的是follower，副本存储在不同的broker中</li>
<li>所有的分区副本的内容都是相同的，如果leader发生故障时，会自动将其中一个follower提升为leader</li>
</ul>
<p><img src="/../images/shujuku/57.png" alt="分区备份"></p>
<p>ISR，需要同步复制保存的follower</p>
<p>如果leader失效后，需要选出新的leader，选举的原则如下：</p>
<p>第一：选举时优先从ISR中选定，因为这个列表中follower的数据是与leader同步的</p>
<p>第二：如果ISR列表中的follower都不行了，就只能从其他follower中选取</p>
<p><strong>总结</strong></p>
<p>可以从两个层面回答，第一个是集群，第二个是复制机制</p>
<p><strong>集群：</strong></p>
<p>一个kafka集群由多个broker实例组成，即时某一台宕机，也不耽误其他broker继续对外提供服务</p>
<p><strong>复制机制：</strong></p>
<ul>
<li>一个topic有多个分区，每个分区有多个副本，有一个leader，其余的是follower，副本存储在不同的broker中</li>
<li>所有的分区副本的内容都是相同的，如果leader发生故障时，会自动将其中一个follower提升为leader，保证了系统的容错性、高可用性</li>
</ul>
<p><strong>解释下复制机制中的ISR</strong></p>
<p>ISR，需要同步复制保存的follower</p>
<p>分区副分为了两个类，一个是ISR，与leader副本同步保存数据，另外一个普通的副本，是异步同步数据，当leader挂掉之后，会优先从ISR副本列表中选取一个作为leader</p>
<h2 id="Kafka数据清理机制了解过吗"><a href="#Kafka数据清理机制了解过吗" class="headerlink" title="Kafka数据清理机制了解过吗"></a>Kafka数据清理机制了解过吗</h2><ul>
<li>Kafka文件存储机制</li>
<li>数据清理机制</li>
</ul>
<p><strong>存储结构</strong></p>
<p><img src="/../images/shujuku/60.png" alt="存储结构"></p>
<p>为什么要分段？</p>
<ul>
<li>删除无用文件方便，提高磁盘利用率</li>
<li>查找数据便捷</li>
</ul>
<p><strong>数据清理机制</strong></p>
<p>日志的清理策略有两个</p>
<ol>
<li>根据消息的保留时间，当消息在kafka中保存的时间超过了指定的时间，就会触发清理过程（默认为168小时）</li>
<li>根据topic存储的数据大小，当topic所占的日志文件大小大于一定的阈值，则开始删除最久的消息。需手动开启</li>
</ol>
<p><strong>总结</strong></p>
<p><strong>Kafka存储结构</strong></p>
<ul>
<li>Kafka中topic的数据存储在分区上，分区如果文件过大会分段存储segment</li>
<li>每个分段都在磁盘上以索引l(xxxx.index)和日志文件(xxxx.log)的形式存储</li>
<li>分段的好处是，第一能够减少单个文件内容的大小，查找数据方便，第二方便kafka进行日志清理。</li>
</ul>
<p><strong>日志的清理策略有两个：</strong></p>
<ul>
<li>根据消息的保留时间，当消息保存的时间超过了指定的时间，就会触发清理，默认是168小时（七天）</li>
<li>根据topic存储的数据大小，当topic所占的日志文件大小大于一定的阈值，则开始删除最久的消息。（默认关闭）</li>
</ul>
<h2 id="Kafka中实现高性能的设计有了解过吗"><a href="#Kafka中实现高性能的设计有了解过吗" class="headerlink" title="Kafka中实现高性能的设计有了解过吗"></a>Kafka中实现高性能的设计有了解过吗</h2><ul>
<li>消息分区：不受单台服务器的限制，可以不受限的处理更多的数据</li>
<li>顺序读写：磁盘顺序读写，提高读写效率</li>
<li>页缓存：把磁盘中的数据缓存到内存中，把对磁盘的访问变为对内存的访问</li>
<li>零拷贝：减少上下文切换及数据拷贝</li>
<li>消息压缩：减少磁盘IO和网络IO</li>
<li>分批发送：将消息打包批量发送，减少网络开销</li>
</ul>
<p><strong>零拷贝</strong></p>
<p><img src="/../images/shujuku/61.png" alt="不适用零拷贝"></p>
<p>可以看见consumer从磁盘文件中消费一共有四次拷贝</p>
<p><img src="/../images/shujuku/62.png" alt="零拷贝"></p>
<p>可以看见consumer从磁盘文件中消费一共有两次拷贝</p>
<h1 id="JVM相关面试题"><a href="#JVM相关面试题" class="headerlink" title="JVM相关面试题"></a>JVM相关面试题</h1><h2 id="JVM是什么"><a href="#JVM是什么" class="headerlink" title="JVM是什么"></a>JVM是什么</h2><p>JVM是java程序的运行环境</p>
<p>好处：</p>
<ul>
<li>一次编写，到处运行</li>
<li>自动内存管理，垃圾回收机制</li>
</ul>
<p><strong>JVM的组成，运行流程</strong></p>
<p><img src="/../images/shujuku/63.png" alt="JVM"></p>
<h2 id="JVM组成"><a href="#JVM组成" class="headerlink" title="JVM组成"></a>JVM组成</h2><h3 id="什么是程序计数器"><a href="#什么是程序计数器" class="headerlink" title="什么是程序计数器"></a>什么是程序计数器</h3><p>程序计数器：线程私有的，内部保存的字节码的行号。用于记录正在执行的字节码指令地址</p>
<h3 id="你能给我详细的介绍Java堆吗"><a href="#你能给我详细的介绍Java堆吗" class="headerlink" title="你能给我详细的介绍Java堆吗"></a>你能给我详细的介绍Java堆吗</h3><p><strong>线程共享的区域：</strong>主要用来保存<strong>对象实例、数组</strong>等，当堆中没有内存空间可分配给实例，也无法再扩展时，则抛出OutOfMemoryError异常</p>
<p><img src="/../images/shujuku/64.png" alt="Java8-JVM内存结构"></p>
<p><strong>年轻代</strong>被划分为三部分，Eden区和两个大小严格相同的Survivor区，根据JVM的策略，在经过几次垃圾收集后，任然存活Survivor的对象将被移动到老年代区间<br><strong>老年代</strong>主要保存生命周期长的对象，一般是一些老的对象</p>
<p><strong>元空间</strong>保存的类信息、静态变量、常量、编译后的代码</p>
<p><img src="/../images/shujuku/65.png" alt="Java7-JVM内存结构"></p>
<p><strong>Jdk1.7和1.8的区别</strong></p>
<ul>
<li>1.7中有一个永久代，存储的是类信息、静态变量、常量、编译后的代码</li>
<li>1.8移除了永久代，把数据存储到了本地内存的元空间中，防止内存溢出</li>
</ul>
<h3 id="什么是虚拟机栈"><a href="#什么是虚拟机栈" class="headerlink" title="什么是虚拟机栈"></a>什么是虚拟机栈</h3><ol>
<li><strong>什么是虚拟机栈</strong></li>
</ol>
<ul>
<li>每个线程运行时所需要的内存，称为虚拟机栈，先进后出</li>
<li>每个栈由多个栈帧（frame）组成，对应着每次方法调用时所占用的内存</li>
<li>每个线程只能有一个活动栈，对应着当前正在执行的那个方法</li>
</ul>
<ol start="2">
<li><strong>垃圾回收是否涉及栈内存</strong></li>
</ol>
<p>垃圾回收主要指就是堆内存，当栈帧弹出来以后，内存就会释放</p>
<ol start="3">
<li><strong>栈内存分配越大越好吗</strong></li>
</ol>
<p>未必，默认的栈内存通常为1024k</p>
<p>栈帧过大会导致线程数变少，例如，机器总内存为512m，目前能活动的线程数则为512个，如果把栈内存改为2048k，那么能活动的线程数就会减半</p>
<ol start="4">
<li><strong>方法内的局部变量是否是线程安全的</strong></li>
</ol>
<ul>
<li>如果方法内局部变量没有逃离方法的作用范围，它是线程安全的</li>
<li>如果是局部变量引用了对象，并逃离了方法的作用范围，需要考虑线程安全</li>
</ul>
<ol start="5">
<li><strong>什么情况下会导致内存溢出</strong></li>
</ol>
<ul>
<li>栈帧过多导致栈内存溢出，典型问题：递归调用</li>
<li>栈帧过大导致栈内存溢出</li>
</ul>
<ol start="6">
<li><strong>堆栈的区别是什么</strong></li>
</ol>
<ul>
<li>栈内存一般会用来存储局部变量和方法调用，但堆内存是用来存储java对象和数组的。堆会GC垃圾回收，而栈不会</li>
<li>栈内存是线程私有的，而堆内存是线程共有的</li>
<li>两者异常错误不同，但如果栈内存或者堆内存不足都会抛出异常<ul>
<li>栈空间不足：java.lang.StackOverFlowError</li>
<li>堆空间不足：java.lang.OutOfMemoryError</li>
</ul>
</li>
</ul>
<h3 id="能不能介绍下方法区"><a href="#能不能介绍下方法区" class="headerlink" title="能不能介绍下方法区"></a>能不能介绍下方法区</h3><ul>
<li>方法区是各个线程<strong>共享的内存区域</strong></li>
<li>主要存储类的信息、运行时常量池</li>
<li>虚拟机启动的时候创建，关闭虚拟机时释放</li>
<li>如果方法区域中的内存无法满足分配请求，则会抛出OutOfMemoryError:Metaspace</li>
</ul>
<p><img src="/../images/shujuku/66.png" alt="方法区"></p>
<p><strong>常量池</strong></p>
<p>可以看作是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息</p>
<p><img src="/../images/shujuku/67.png" alt="常量池"></p>
<p><strong>运行时常量池</strong></p>
<p>常量池是***.class<strong>文件中的，当该类被加载，它的常量池信息就会</strong>放入运行时常量池<strong>，并把里面的</strong>符号地址变为真实地址**</p>
<h3 id="你听说过直接内存吗"><a href="#你听说过直接内存吗" class="headerlink" title="你听说过直接内存吗"></a>你听说过直接内存吗</h3><p>直接内存：并不属于JVM中的内存结构，不由JVM进行管理。是虚拟机的系统内存</p>
<p>常见于NIO操作时，用于数据缓冲区，它分配回收成本较高，但读写性能高，不受JVM内存回收管理</p>
<p>常规IO的数据拷贝流程：</p>
<p><img src="/../images/shujuku/68.png" alt="常规IO"></p>
<p>NIO数据拷贝流程：</p>
<p><img src="/../images/shujuku/69.png" alt="NIO"></p>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><h3 id="什么是类加载器，类加载器有哪些？"><a href="#什么是类加载器，类加载器有哪些？" class="headerlink" title="什么是类加载器，类加载器有哪些？"></a>什么是类加载器，类加载器有哪些？</h3><p><strong>类加载器</strong></p>
<p>JVM只会运行二进制文件，类加载器的作用就是将<strong>字节码文件加载到JVM中</strong>，从而让Java程序能够启动起来</p>
<p><strong>类加载器有哪些</strong></p>
<p><img src="/../images/shujuku/70.png" alt="类加载器"></p>
<h3 id="什么是双亲委派模型？"><a href="#什么是双亲委派模型？" class="headerlink" title="什么是双亲委派模型？"></a>什么是双亲委派模型？</h3><p>加载某一个类，先委托上一级的加载器进行加载，如果上级加载器也有上级，则会继续向上委托，如果该类委托上级没有被加载，子加载器尝试加载该类</p>
<p><strong>JVM为什么采用双亲委派机制？</strong></p>
<ol>
<li>通过双亲委派机制可以避免某一个类被重复加载，当父类已经加载后则无需重复加载，保证唯一性</li>
<li>为了安全，保证类库API不会被修改</li>
</ol>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">String</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;demo info&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时执行main函数会出错，在类java.lang.Stirng中找不到main方法</p>
<p><em>由于是双亲委派机制，java.lang.String在启动类加载器得到加载，因为在核心jre库中有其相同名字的类文件，但该类中并没有main方法。这样就能防止恶意篡改核心API库</em></p>
<h3 id="说下类装载的执行过程"><a href="#说下类装载的执行过程" class="headerlink" title="说下类装载的执行过程"></a>说下类装载的执行过程</h3><p><img src="/../images/shujuku/71.png" alt="类加载"></p>
<p><strong>加载</strong></p>
<ul>
<li>通过类的全名，获取类的二进制数据流</li>
<li>解析类的二进制数据流为方法区内的数据结构（将二进制加载至方法区中）</li>
<li>创建java.lang.Class类的实例，表示该类型。作为方法区这个类的各种数据的访问入口</li>
</ul>
<p><img src="/../images/shujuku/72.png" alt="类加载"></p>
<p><strong>验证</strong></p>
<p><strong>验证类是否符合JVM规范，安全性检查</strong></p>
<ol>
<li>文件格式验证</li>
<li>元数据验证</li>
<li>字节码验证</li>
<li>符号引用验证 Class文件在其常量池会通过字符串记录自己将要使用的其他类或者方法，检查它们是否存在</li>
</ol>
<p>前三种为格式检查，如：文件格式是否错误、语法是否错误、字节码是否合规</p>
<p><strong>准备</strong></p>
<p><strong>为类变量分配内存并设置类变量初始值</strong></p>
<ul>
<li>static变量，分配空间在准备阶段完成（设置默认值），赋值在初始化阶段完成</li>
<li>static变量是final的基本类型，以及字符串常量，值已经确定，赋值在准备阶段完成</li>
<li>static变量是final的引用类型，那么赋值也会在初始化阶段完成</li>
</ul>
<p><img src="/../images/shujuku/73.png" alt="准备赋值"></p>
<p><strong>解析</strong></p>
<p><strong>把类中的符号引用转换为直接引用</strong></p>
<p>比如：方法中调用了其他方法，方法名可以理解为符号引用，而直接引用就是使用指针直接指向方法</p>
<p><strong>初始化</strong></p>
<p><strong>对类的静态变量、静态代码块执行初始化操作</strong></p>
<ul>
<li>如果初始化一个类的时候，其父类尚未初始化，则优先初始化其父类</li>
<li>如果同时包含多个静态变量和静态代码块，则按照自上而下的顺序依次执行</li>
</ul>
<p><strong>使用</strong></p>
<p>JVM开始从入口方法开始执行用户的程序代码</p>
<ul>
<li>调用静态类成员信息（比如：静态字段、静态方法）</li>
<li>使用new关键字为其创建对象实例</li>
</ul>
<p><strong>卸载</strong></p>
<p>当用户程序代码执行完毕后，JVM便开始销毁创建的Class对象</p>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><h3 id="对象什么时候可以被垃圾回收器回收"><a href="#对象什么时候可以被垃圾回收器回收" class="headerlink" title="对象什么时候可以被垃圾回收器回收"></a>对象什么时候可以被垃圾回收器回收</h3><p>简单一句就是：如果一个或多个对象没有任何的引用指向它了，那么这个对象现在就是垃圾，如果定位了垃圾，则有可能会被垃圾回收器回收</p>
<p>如果要定位什么是垃圾，有两种方式来确定，第一个是<strong>引用计数法</strong>，第二个是<strong>可达性分析算法</strong></p>
<p><strong>引用计数法</strong></p>
<p>一个对象被引用了一次，在当前的对象头上递增一次引用次数，如果这个对象的引用次数为0，代表这个对象可回收</p>
<p>当对象出现了<strong>循环引用</strong>的话，则引用计数器就会失效（内存泄漏）</p>
<p><strong>可达性分析算法</strong></p>
<p>扫描堆中的对象，看是否能够沿着GC Root对象为起点的引用链找到该对象，找不到，表示可以回收</p>
<p><strong>哪些对象可以作为GC Root？</strong></p>
<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中JNI（即一般说的Native方法）引用的对象</li>
</ul>
<h3 id="JVM垃圾回收算法"><a href="#JVM垃圾回收算法" class="headerlink" title="JVM垃圾回收算法"></a>JVM垃圾回收算法</h3><ul>
<li>标记清除算法</li>
<li>复制算法</li>
<li>标记整理算法</li>
</ul>
<p><strong>标记清除算法</strong></p>
<p>标记清除算法，是将垃圾回收分为两个部分，分别是<strong>标记和清除</strong></p>
<ol>
<li>根据可达性分析算法得出的垃圾进行标记</li>
<li>对这些标记为可回收的内容进行垃圾回收</li>
</ol>
<p><img src="/../images/shujuku/74.png" alt="标记清除"></p>
<p><strong>标记整理算法</strong></p>
<p><img src="/../images/shujuku/75.png" alt="标记整理"></p>
<p>优缺点同标记清除算法，解决了标记清除算法的碎片化的问题，同时，标记整理算法多了一步，对象移动内存位置的步骤，其效率也有一定的影响</p>
<p><strong>复制算法</strong></p>
<p><img src="/../images/shujuku/76.png" alt="复制算法"></p>
<p>优点：</p>
<ul>
<li>在垃圾对象多的情况下，效率较高</li>
<li>清理后，内存无碎片</li>
</ul>
<p>缺点：</p>
<ul>
<li>分配的两块内存空间，在同一时刻，只能使用一半，降低内存的使用率</li>
</ul>
<h3 id="说下JVM中的分代回收"><a href="#说下JVM中的分代回收" class="headerlink" title="说下JVM中的分代回收"></a>说下JVM中的分代回收</h3><p>在java8时，堆被分成了两份：<strong>新生代和老年代【1：2】</strong></p>
<p><img src="/../images/shujuku/77.png" alt="分代"></p>
<p>对于新生代，内部又被分为了三个区域</p>
<ul>
<li>伊甸园区，新生的对象都分配在这里</li>
<li>幸存者区survivor（分成from和to）</li>
<li>Eden区，from区，to区【8：1：1】</li>
</ul>
<p><strong>分代回收-工作机制</strong></p>
<ul>
<li>新创建的对象，都会先分配到Eden中</li>
<li>当Eden中内存不足时，标记Eden与from的存活对象</li>
<li>将存活对象采用复制算法复制到to中，复制完毕后，将from与to交换，然后清空Eden和to区域中内存</li>
<li>经过一段时间Eden内存不足，重复以上步骤</li>
<li>当幸村区对象熬过几次回收（最多15次），晋升到老年代（幸村区内存不足或大对象会导致提前晋升）</li>
</ul>
<p><strong>Minor、Mixed GC、FullGC的区别是什么？</strong></p>
<ul>
<li>Minor【young GC】发生在新生代的垃圾回收，暂停时间短（STW）</li>
<li>Mixed GC新生代+老年代部分区域的垃圾回收，G1收集器特有</li>
<li>FullGC：新生代+老年代完整垃圾回收，暂停时间长（STW），应尽力避免</li>
</ul>
<h3 id="说一下JVM中有哪些垃圾回收器？"><a href="#说一下JVM中有哪些垃圾回收器？" class="headerlink" title="说一下JVM中有哪些垃圾回收器？"></a>说一下JVM中有哪些垃圾回收器？</h3><p>在jvm中，实现了多张垃圾回收器，包括：</p>
<ul>
<li>串行垃圾回收器</li>
<li>并行垃圾回收器</li>
<li>CMS（并发）垃圾回收器</li>
<li>G1垃圾回收器</li>
</ul>
<p><strong>串行垃圾回收器</strong></p>
<p><strong>Serial</strong>和<strong>Serial Old</strong>串行垃圾回收器，是指使用单线程进行垃圾回收，堆内存较小，适合个人电脑</p>
<ul>
<li>Serial作用于新生代，采用复制算法</li>
<li>Serial Old作用于老年代，采用标记-整理算法</li>
</ul>
<p>垃圾回收时，只有一个线程在工作，并且java应用中的所有线程都要暂停（STW），等待垃圾回收的完成</p>
<p><img src="/../images/shujuku/78.png" alt="串行垃圾回收"></p>
<p><strong>并行垃圾回收器</strong></p>
<p>Parallel New和Parallel Old是一个并行垃圾回收器，<strong>JDK8默认采用此垃圾回收器</strong></p>
<ul>
<li>Parallel New作用于新生代，采用复制算法</li>
<li>Parallel Old作用于老年代，采用标记-整理算法</li>
</ul>
<p>垃圾回收时，多个线程在工作，并且java应用中的所有线程都要暂停（STW），等待垃圾回收的完成</p>
<p><img src="/../images/shujuku/79.png" alt="并行垃圾回收器"></p>
<p><strong>CMS（并发）垃圾回收器</strong></p>
<p>CMS，是一款<strong>并发</strong>的、使用<strong>标记—清除</strong>算法的垃圾回收器，该回收器是<strong>针对老年代垃圾回收的</strong>，是一款以获取最短回收停顿时间为目标的收集器，停顿时间短，用户体验就好。其最大的特点是在进行垃圾回收时，应用仍然能正常运行</p>
<p><img src="/../images/shujuku/80.png" alt="CMS垃圾回收器"></p>
<h3 id="详细聊一下G1垃圾回收器"><a href="#详细聊一下G1垃圾回收器" class="headerlink" title="详细聊一下G1垃圾回收器"></a>详细聊一下G1垃圾回收器</h3><p><img src="/../images/shujuku/82.png" alt="G1垃圾回收器"></p>
<ul>
<li>应用于新生代和老年代，<strong>在JDK9之后默认使用G1</strong></li>
<li>划分成多个区域，每个区域都可以充当eden、survivor、old、humongous，其中humongous专为大对象准备</li>
<li>采用复制算法</li>
<li>响应时间与吞吐量兼顾</li>
<li>分成三个阶段：新生代回收、并发标记、混合收集</li>
<li>如果并发失败（即回收速度赶不上创建新对象速度），会触发Full GC</li>
</ul>
<p><strong>Young Collection（年轻代垃圾回收）</strong></p>
<ul>
<li>初始时，所有区域都处于空闲状态</li>
<li>创建了一些对象，挑出一些空闲区域作为伊甸园区存储这些对象</li>
<li>当伊甸园需要垃圾回收时，挑出一个空闲区作为幸村区，用复制算法复制存活对象，需要暂停用户线程</li>
<li>随着时间的流逝，伊甸园的内存又有不足</li>
<li>将伊甸园以及之前幸存区中的存活对象，采用复制算法，复制到新的幸村区，其中较老的对象晋升至老年代</li>
</ul>
<p><img src="/../images/shujuku/83.png" alt="新生代垃圾回收"></p>
<p><strong>Young Collection + Concurrent Mark（年轻代垃圾回收+并发标记）</strong></p>
<p>当老年代占用内存超过阈值（默认是45%）后，触发并发标记，这时无需暂停用户线程</p>
<p><img src="/../images/shujuku/84.png" alt="并发标记"></p>
<ul>
<li>并发标记之后，会有重新标记阶段解决漏标问题，此时需要暂停用户线程</li>
<li>这些都是完成后就知道了老年代有哪些存活对象，随后进入混合收集阶段。此时不会对所有老年代区域进行回收，而是根据<strong>暂停时间目标</strong>优先回收价值高（存活对象少）的区域（这也是Gabage First名称的由来）</li>
</ul>
<p><strong>Mixed Collection（混合垃圾回收）</strong></p>
<p>混合收集阶段中，参与复制的有eden、survivor、old</p>
<p>复制完成，内存得到释放。进入下一轮的新生代回收、并发标记、混合收集</p>
<p><img src="/../images/shujuku/85.png" alt="混合回收"></p>
<h3 id="强引用、软引用、弱引用、虚引用的区别"><a href="#强引用、软引用、弱引用、虚引用的区别" class="headerlink" title="强引用、软引用、弱引用、虚引用的区别"></a>强引用、软引用、弱引用、虚引用的区别</h3><p><strong>强引用：</strong>只有所有GC Roots对象都不通过【强引用】引用该对象时，该对象才能被垃圾回收</p>
<p><strong>软引用：</strong>仅有软引用引用该对象时，在垃圾回收后，内存依然不足的时会回收软引用对象，需要配合SoftReference使用</p>
<p><strong>弱引用：</strong>仅有弱引用引用该对象时，在垃圾回收时，无论内存是否充足，都会回收弱引用对象，需要配合WeakReference使用</p>
<p><img src="/../images/shujuku/81.png" alt="ThreadLocal内存泄漏"></p>
<p>Entry中的key为虚引用，value为强引用</p>
<p><strong>虚引用：</strong>必须配合引用队列使用，当引用对象回收时，会将虚引用入队，由Reference Handler线程调用虚引用相关方法释放直接内存</p>
<h2 id="JVM实践"><a href="#JVM实践" class="headerlink" title="JVM实践"></a>JVM实践</h2><h3 id="JVM调优的参数可以在哪里设置？"><a href="#JVM调优的参数可以在哪里设置？" class="headerlink" title="JVM调优的参数可以在哪里设置？"></a>JVM调优的参数可以在哪里设置？</h3><ul>
<li>war包部署在tomcat中设置</li>
</ul>
<p>修改TOMCAT_HOME&#x2F;bin&#x2F;catalina.sh文件</p>
<p><img src="/../images/shujuku/86.png" alt="tomcat"></p>
<ul>
<li>jar包部署在启动参数设置</li>
</ul>
<p>通常在linux系统下直接加参数启动springboot项目</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup java -Xms512m -Xmx1024m -jar xxxx.jar --spring.profiles.active=prod &amp;</span><br></pre></td></tr></table></figure>

<p><strong>nohup：</strong>用于在系统后台不挂断地运行命令，退出终端不会影响程序的运行</p>
<p>参数**&amp;**：让命令在后台运行，终端退出后命令仍旧运行</p>
<h3 id="JVM调优的参数都有哪些？"><a href="#JVM调优的参数都有哪些？" class="headerlink" title="JVM调优的参数都有哪些？"></a>JVM调优的参数都有哪些？</h3><p>对于JVM调优，主要就是调整年轻代、老年代、元空间的内存空间大小及使用的垃圾回收器类型</p>
<ul>
<li>设置堆空间大小</li>
<li>虚拟机栈的设置</li>
<li>年轻代中Eden区和两个Survivor区的大小比例</li>
<li>年轻代晋升老年代阈值</li>
<li>设置垃圾回收收集器</li>
</ul>
<p><strong>设置堆空间的大小</strong></p>
<p>设置堆的初始大小和最大大小，为了防止垃圾收集器在初始大小、最大大小之间收缩堆而产生额外的时间，通常把最大、初始大小设置为相同的值</p>
<p><img src="/../images/shujuku/87.png" alt="设置堆的大小"></p>
<p><em>不指定单位默认为字节，指定单位，按照指定的单位设置</em></p>
<p><strong>堆空间设置多少合适？</strong></p>
<ul>
<li>最大大小的默认值是物理内存的1&#x2F;4，初始大小是物理内存的1&#x2F;64</li>
<li>堆太小，可能会频繁的导致年轻代和老年代的垃圾回收，会产生stw，暂停用户线程</li>
<li>堆内存大肯定是好的，存在风险，加入发生了fullgc，它会扫描整个堆空间，暂停用户线程的时间长</li>
<li>设置参数推荐：尽量大、也要考察一下当前计算机其他程序的内存使用情况</li>
</ul>
<p><strong>虚拟机栈的设置</strong></p>
<p>虚拟机栈的设置：<strong>每个线程会默认开启1M的内存</strong>，用于存放栈帧、调用参数、局部变量等，但一般256K就够用了。通常减少每个线程的堆栈，可以产生更多的线程，但这实际上还受限于操作系统</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xss 对每个线程stack大小的调整，-Xss128K</span><br></pre></td></tr></table></figure>

<p><strong>年轻代中Eden区和两个Survivor区的大小比例</strong></p>
<p>设置年轻代中Eden区和两个Survivor区的大小比例。该值如果不设置，则默认比例为8：1：1。通过增大Eden区的大小，来减少YGC发生的次数，但有时我们发现，虽然次数减少了，但Eden区满的时候，由于占用的空间较大，导致释放缓慢，此时STW的时间较长，因此需要按照程序情况去调优</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XXSurvivorRatio=8，表示年轻代中的分配比率：survivor:eden = 2 : 8</span><br></pre></td></tr></table></figure>

<p><strong>年轻代晋升老年代阈值</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:MaxTenuringThreshold=threshold</span><br></pre></td></tr></table></figure>

<p>默认为15</p>
<p>取值范围0~15</p>
<p><strong>设置垃圾回收收集器</strong></p>
<p>通过增大吞吐量提高系统性能，可以通过设置并行垃圾回收收集器</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseParallelGC</span><br><span class="line">-XX:+UseParallelOldGC</span><br><span class="line">-xx:+UseG1GC</span><br></pre></td></tr></table></figure>

<h3 id="说一下JVM调优的工具？"><a href="#说一下JVM调优的工具？" class="headerlink" title="说一下JVM调优的工具？"></a>说一下JVM调优的工具？</h3><ul>
<li>命令工具<ul>
<li>jps：进程状态信息</li>
<li>jstack：查看java进程内线程的堆栈信息</li>
<li>jmap：查看堆转信息</li>
<li>jhat：堆转储快照分析工具</li>
<li>jstat：JVM统计监测工具</li>
</ul>
</li>
<li>可视化工具<ul>
<li>jconsole：用于对jvm的内存，线程，类的监控</li>
<li>VisualVM：能够监控线程，内存情况</li>
</ul>
</li>
</ul>
<p><strong>jmap</strong></p>
<p>用于生成堆转内存快照、内存使用情况</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jmap -heap pid 显示Java堆的信息</span><br><span class="line">jmap -dump:format=b,file=heap.hprof pid</span><br></pre></td></tr></table></figure>

<ul>
<li>format&#x3D;b表示以hprof二进制格式转储Java堆的内存</li>
<li>file&#x3D;<filename>用于指定快照dump文件的文件名</li>
</ul>
<p><em>dump文件中包含了程序运行的模块信息、线程信息、堆栈调用信息、异常信息等数据，方便系统技术人员进行错误排查</em></p>
<p><strong>jstat</strong></p>
<p>是JVM统计监测工具。可以用来显示垃圾回收信息、类加载信息、新生代统计信息等</p>
<p><img src="/../images/shujuku/88.png" alt="jstat工具"></p>
<p><strong>jconsole</strong></p>
<p>用于对jvm的内存，线程，类的监控，是一个基于jmx的GUI性能监控工具</p>
<p>打开方式：java安装目录下直接启动jconsole.exe就行</p>
<p><strong>VisualVM</strong></p>
<p>能够监控线程，内存情况，查看方法的CPU时间和内存中的对象，已被GC的对象，反向查看分配的堆栈</p>
<p>打开方式：java安装目录bin目录下 直接启动jvisualvm.exe</p>
<h3 id="Java内存泄漏的排查思路？"><a href="#Java内存泄漏的排查思路？" class="headerlink" title="Java内存泄漏的排查思路？"></a>Java内存泄漏的排查思路？</h3><p><img src="/../images/shujuku/89.png" alt="内存泄漏"></p>
<p>内存泄漏通常是指堆内存，通常是指一些大对象不被回收的情况</p>
<ol>
<li>通过jmap或设置jvm参数获取堆内存快照dump（有的情况是内存溢出之后程序则会直接中断，而jmap只能打印正在运行中的程序，所以建议通过参数的方式生成dump文件）</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:+HeapDumpOnOutOfMemoryError</span><br><span class="line">-XX:HeapDumpPath=/home/app/dumps/</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>通过工具，VisualVM去分析dump文件，VisulaVM可以加载离线的dump文件</li>
<li>通过查看堆信息的情况，可以大概定位内存溢出是哪行代码出现了问题</li>
<li>找到对应的代码，通过阅读上下文的情况，进行修复即可</li>
</ol>
<h3 id="CPU飙高排查方案与思路"><a href="#CPU飙高排查方案与思路" class="headerlink" title="CPU飙高排查方案与思路"></a>CPU飙高排查方案与思路</h3><ol>
<li>使用top命令查看cpu占用情况</li>
</ol>
<p><img src="/../images/shujuku/90.png" alt="top命令"></p>
<ol start="2">
<li>通过top命令查看后，可以查看是哪一个进程占用cpu较高，上图所示的进程为：40940</li>
<li>使用ps命令查看进程中的线程信息</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps H -eo pid,tid,%cpu | grep 40940</span><br></pre></td></tr></table></figure>

<p><img src="/../images/shujuku/91.png" alt="进程中的线程"></p>
<p>通过以上分析，在进程40940中的线程40950占用cpu较高</p>
<ol start="4">
<li>使用jstack命令查看进程中哪些线程出现了问题，最终定位问题（其中包含一个十进制转换为十六进制问题）</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack 40940 此处是进程id</span><br></pre></td></tr></table></figure>

<p><img src="/../images/shujuku/92.png" alt="十进制转换为十六进制"></p>
<h1 id="多线程课程"><a href="#多线程课程" class="headerlink" title="多线程课程"></a>多线程课程</h1><h2 id="线程的基础知识"><a href="#线程的基础知识" class="headerlink" title="线程的基础知识"></a>线程的基础知识</h2><h3 id="线程和进程的区别？"><a href="#线程和进程的区别？" class="headerlink" title="线程和进程的区别？"></a>线程和进程的区别？</h3><p>程序由<strong>指令和数据</strong>组成，但这些指令要运行，数据要读写，就必须将指令加载到CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网路等设备</p>
<p><strong>进程就是用来加载指令、管理内存、管理IO的</strong></p>
<p><strong>当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程</strong></p>
<p><img src="/../images/shujuku/93.png" alt="单实例和多实例"></p>
<p>一个线程就是一个指令流，将指令流中的一条条指令指令以一定的顺序交给CPU执行</p>
<p>一个进程之内可以分为一到多个线程</p>
<p><img src="/../images/shujuku/94.png" alt="线程"></p>
<p><strong>二者对比</strong></p>
<ul>
<li>进程是正在运行程序的实例，进程中包含了线程，每个线程执行不同的任务</li>
<li>不同的进程使用不同的内存空间，在当前进程下的所有线程可以共享内存空间</li>
<li>线程更轻量，线程上下文切换成本一般上要比进程上下文切换低（上下文切换指的是从一个线程切换到另一个线程）</li>
</ul>
<h3 id="并行和并发有什么区别？"><a href="#并行和并发有什么区别？" class="headerlink" title="并行和并发有什么区别？"></a>并行和并发有什么区别？</h3><p> 现在都是多核CPU，在多核CPU下</p>
<ul>
<li>并发是同一时间应对多件事情的能力，多个线程轮流使用一个或多个CPU</li>
<li>并行是同一时间动手做多件事情的能力，4核CPU同时执行4个线程</li>
</ul>
<h3 id="创建线程的方式有哪些？"><a href="#创建线程的方式有哪些？" class="headerlink" title="创建线程的方式有哪些？"></a>创建线程的方式有哪些？</h3><ul>
<li>继承Thread类</li>
<li>实现runnable接口</li>
<li>实现Callable接口</li>
<li>线程池创建线程</li>
</ul>
<p><strong>继承Thread类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyThread...run...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建MyThread对象</span></span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>() ;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>() ;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//调用start方法启动线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>实现runnable接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyRunnable...run...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//创建MyRunnable对象</span></span><br><span class="line">        <span class="type">MyRunnable</span> <span class="variable">mr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建Thread对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(mr);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(mr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用start方法启动线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>实现Callable接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">//创建MyCallable对象</span></span><br><span class="line">        <span class="type">MyCallable</span> <span class="variable">mc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCallable</span>();</span><br><span class="line">        <span class="comment">//创建FutureTask</span></span><br><span class="line">        FutureTask&lt;String&gt; ft = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(mc);</span><br><span class="line">        <span class="comment">//创建Thread对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ft);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ft);</span><br><span class="line">        <span class="comment">//调用start方法启动线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="comment">//调用ft的get方法获取执行结果</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> ft.get();</span><br><span class="line">        <span class="comment">//输出</span></span><br><span class="line">        System.out.println(result);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>线程池创建线程</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyExecutors</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyRunnable..run..&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建线程池对象</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">        threadPool.submit(<span class="keyword">new</span> <span class="title class_">MyExecutors</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭线程池</span></span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Runnable和Callable都可以创建线程，区别是什么？"><a href="#Runnable和Callable都可以创建线程，区别是什么？" class="headerlink" title="Runnable和Callable都可以创建线程，区别是什么？"></a>Runnable和Callable都可以创建线程，区别是什么？</h4><ul>
<li>Runnable接口run方法没有返回值</li>
<li>Callable接口call方法有返回值，是个泛型，和Future、FutureTask配合可以用来获取异步执行结果</li>
<li>Callable接口的call()方法允许抛出异常；而Runnable接口的run()方法的异常只能在内部消化，不能继续上抛</li>
</ul>
<h4 id="启动线程时可以使用run方法，run和start方法有什么区别？"><a href="#启动线程时可以使用run方法，run和start方法有什么区别？" class="headerlink" title="启动线程时可以使用run方法，run和start方法有什么区别？"></a>启动线程时可以使用run方法，run和start方法有什么区别？</h4><p>start()：用来启动线程，通过该线程调用run方法执行run方法中所定义的逻辑代码。start方法只能被调用一次</p>
<p>run()：封装了要被线程执行的代码，可以被调用多次</p>
<h3 id="线程包含哪些状态，状态之间是如何变化的？"><a href="#线程包含哪些状态，状态之间是如何变化的？" class="headerlink" title="线程包含哪些状态，状态之间是如何变化的？"></a>线程包含哪些状态，状态之间是如何变化的？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="comment">//尚未启动的线程的线程状态</span></span><br><span class="line">    NEW,</span><br><span class="line">    <span class="comment">//可运行线程的线程状态</span></span><br><span class="line">    RUNNABLE,</span><br><span class="line">    <span class="comment">//线程阻塞等待监视器锁的线程状态</span></span><br><span class="line">    BLOCKED,</span><br><span class="line">    <span class="comment">//等待线程的线程状态</span></span><br><span class="line">    WAITING,</span><br><span class="line">    <span class="comment">//具有指定等待时间的等待线程的线程状态</span></span><br><span class="line">    TIMED_WAITING,</span><br><span class="line">    <span class="comment">//已终止线程的线程状态。线程已完成执行</span></span><br><span class="line">    TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../images/shujuku/95.png" alt="线程状态"></p>
<p><strong>线程状态之间是如何变化的</strong></p>
<ul>
<li>创建线程对象是<strong>新建状态</strong></li>
<li>调用了start()方法转变为<strong>可执行状态</strong></li>
<li>线程获取了CPU的执行权，执行结束时<strong>终止状态</strong></li>
<li>在可执行状态的过程中，如果没有获取CPU的执行权，可能会切换到其他状态<ul>
<li>如果没有获取锁（synchronized或lock）进入<strong>阻塞状态</strong>，获得锁再切换为可执行状态</li>
<li>如果线程调用了wait()方法进入<strong>等待状态</strong>，其他线程调用notify()唤醒后可切换为可执行状态</li>
<li>如果线程调用了sleep(50)方法，进入<strong>计时等待状态</strong>，到时间后可切换为可执行状态</li>
</ul>
</li>
</ul>
<h3 id="新建T1、T2、T3三个线程，如何保证它们按顺序执行？"><a href="#新建T1、T2、T3三个线程，如何保证它们按顺序执行？" class="headerlink" title="新建T1、T2、T3三个线程，如何保证它们按顺序执行？"></a>新建T1、T2、T3三个线程，如何保证它们按顺序执行？</h3><p>可以使用线程中的join方法解决</p>
<p>join()；等待线程运行结束</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">小例子：</span><br><span class="line">t.join()</span><br><span class="line">阻塞调用此方法的线程进入timed_waiting</span><br><span class="line">直到线程t执行完毕之后，此线程再继续执行</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        t1.join;<span class="comment">//加入线程1，只有t1线程执行完毕以后，再次执行该线程</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (interruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        t2.join();<span class="comment">//加入线程2，只有t2线程执行完毕以后，再次执行该线程</span></span><br><span class="line">    &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;t3&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//启动线程</span></span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">t3.start();</span><br></pre></td></tr></table></figure>

<h4 id="notify-和notifyAll-有什么区别"><a href="#notify-和notifyAll-有什么区别" class="headerlink" title="notify()和notifyAll()有什么区别"></a>notify()和notifyAll()有什么区别</h4><ul>
<li>notifyAll()：唤醒所有wait的线程</li>
<li>notify()：只随机唤醒一个wait线程</li>
</ul>
<h3 id="java中wait和sleep方法有什么区别？"><a href="#java中wait和sleep方法有什么区别？" class="headerlink" title="java中wait和sleep方法有什么区别？"></a>java中wait和sleep方法有什么区别？</h3><p><strong>共同点</strong></p>
<p>wait()，wait(long)和sleep(long)的效果都是让当前线程暂时放弃CPU的使用权，进入阻塞状态</p>
<p><strong>不同点</strong></p>
<ul>
<li>方法归属不同<ul>
<li>sleep(long)是Thread的静态方法</li>
<li>而wait()，wait(long)都是Object的成员方法，每个对象都有</li>
</ul>
</li>
<li>唤醒时机不同<ul>
<li>执行sleep(long)和wait(long)的线程都会在等待相应毫秒后醒来</li>
<li>wait(long)和wait()还可以被notify唤醒，wait()如果不唤醒就一直等待下去</li>
<li>它们都可以被打断唤醒</li>
</ul>
</li>
<li>锁特性不同<ul>
<li>wait方法的调用必须先获取wait对象的锁，而sleep则无此限制</li>
<li>wait方法执行后会释放对象锁，允许其他线程获取该对象锁（我放弃cpu，但你们还可以用）</li>
<li>而sleep如果再synchronized代码块中执行，并不会释放对象锁（我放弃CPU，你们也用不了）</li>
</ul>
</li>
</ul>
<h3 id="如何停止一个正在运行的线程"><a href="#如何停止一个正在运行的线程" class="headerlink" title="如何停止一个正在运行的线程"></a>如何停止一个正在运行的线程</h3><p>有三种方式可以停止线程</p>
<ul>
<li>使用退出标志，使线程正常退出，也就是当run方法完成后线程终止</li>
<li>使用stop方法强制终止（不推荐，方法已作废）</li>
<li>使用interrupt方法中断线程<ul>
<li>打断阻塞的线程（sleep，wait，join）的线程，线程会抛出InterruptedException异常</li>
<li>打断正常的线程，可以根据打断状态来标记是否退出线程</li>
</ul>
</li>
</ul>
<p>举例：</p>
<p>第一种方式：flag为标志，更新后t1不再运行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInterrupt1</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!flag) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;MyThread...run...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//创建MyThread对象</span></span><br><span class="line">        <span class="type">MyInterrupt1</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyInterrupt1</span>();</span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="comment">//主线程休息6秒</span></span><br><span class="line">        Thread.sleep(<span class="number">6000</span>);</span><br><span class="line">        <span class="comment">//更新标志</span></span><br><span class="line">        t1.flag = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种：调用stop方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInterrupt1</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!flag) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;MyThread...run...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//创建MyThread对象</span></span><br><span class="line">        <span class="type">MyInterrupt1</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyInterrupt1</span>();</span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="comment">//主线程休息6秒</span></span><br><span class="line">        Thread.sleep(<span class="number">6000</span>);</span><br><span class="line"></span><br><span class="line">        t1.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三种的第一种情况：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">//打断阻塞的线程</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;t1 正在运行...&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    t1.start();</span><br><span class="line">    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">    t1.interrupt();</span><br><span class="line">    System.out.println(t1.isInterrupted());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<p><img src="/../images/shujuku/96.png" alt="第一种情况"></p>
<p>第三种的第二种情况：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">//打断正常的线程</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> current.isInterrupted();</span><br><span class="line">            <span class="keyword">if</span> (interrupted) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;打断状态： &quot;</span> + interrupted);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">    t2.start();</span><br><span class="line">    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">    t2.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：interrupted默认为false，调用current.isInterrupted()打断后变为true，然后跳出</p>
<p><img src="/../images/shujuku/97.png" alt="第二种情况"></p>
<h2 id="线程中并发安全"><a href="#线程中并发安全" class="headerlink" title="线程中并发安全"></a>线程中并发安全</h2><h3 id="synchronized关键字的底层原理"><a href="#synchronized关键字的底层原理" class="headerlink" title="synchronized关键字的底层原理"></a>synchronized关键字的底层原理</h3><ul>
<li><p>Synchronized【对象锁】采用互斥的方式让同一时刻至多只有一个线程能持有【对象锁】，其他线程再想获取这个【对象锁】时就会阻塞住</p>
</li>
<li><p>底层是由monitor实现的，monitor被翻译为监视器，是由jvm提供，c++语言实现，线程获取锁需要使用对象关联monitor</p>
</li>
<li><p>monitor内部有三个属性：</p>
<ul>
<li><p>Owner：存储当前获取锁的线程的，只能有一个线程可以获取</p>
</li>
<li><p>EntryList：关联没有抢到锁的线程，处于Blocked状态的线程</p>
</li>
<li><p>WaitSet：关联调用了wait方法的线程，处于Waiting状态的线程</p>
</li>
</ul>
</li>
</ul>
<h3 id="synchronized关键字的底层原理-进阶"><a href="#synchronized关键字的底层原理-进阶" class="headerlink" title="synchronized关键字的底层原理-进阶"></a>synchronized关键字的底层原理-进阶</h3><p>Monitor实现的锁属于重量级锁，你了解过锁升级吗？</p>
<ul>
<li>Monitor实现的锁属于重量级锁，里面涉及到了用户态和内核态的切换、进程的上下文切换，成本较高，性能比较低</li>
<li>在JDK1.6中引入了两种新型锁机制：<strong>偏向锁和轻量级锁</strong>，它们的引入是为了解决在没有多线程竞争或基本没有竞争的场景下因使用传统锁机制带来的性能开销小问题</li>
</ul>
<p> <strong>对象的内存结构</strong></p>
<p>在HotSpot虚拟机中，对象在内存中存储的布局可分为3块区域：对象头（Header）、实例数据（Instance Data）和对齐补充</p>
<p><img src="/../images/shujuku/98.png" alt="对象的内存结构"></p>
<p><strong>MarkWord</strong></p>
<p><img src="/../images/shujuku/99.png" alt="MarkWord"></p>
<ul>
<li>hashcode：25位的对象标示Hash码</li>
<li>age：对象分代年龄占4位</li>
<li>biased_lock：偏向锁标示，占1位，0表示没有开启偏向锁，1表示开启了偏向锁</li>
<li>thread：持有偏向锁的线程ID，占23位</li>
<li>epoch：偏向时间戳，占2位</li>
<li>ptr_to_lock_record：轻量级锁状态下，指向栈中锁记录的指针，占30位</li>
<li>ptr_to_heavyweight_monitor：重量级锁状态下，指向对象监视器Monitor的指针，占30位数</li>
</ul>
<p><strong>轻量级锁</strong></p>
<p>在很多情况下，在Java程序运行时，同步块中的代码都是不存在竞争的，不同的线程交替的执行同步块中的代码。这种情况下，用重量级锁是没有必要的。因此JVM中引入了轻 量级锁的概念</p>
<p><img src="/../images/shujuku/100.png" alt="加锁流程"></p>
<p><img src="/../images/shujuku/101.png" alt="加锁和解锁流程"></p>
<p><strong>偏向锁</strong></p>
<p>轻量级锁在没有竞争时（就自己这个线程），每次重入仍然需要执行CAS操作</p>
<p>Java6中引入了偏向锁来做进一步优化：只有第一次使用CAS将线程ID设置到对象的Mark Word头，之后发现这个线程ID是自己的就表示没有竞争，不用重新CAS。以后只要不发生竞争，这个对象就归该线程持有</p>
<p><img src="/../images/shujuku/102.png" alt="偏向锁加锁流程"></p>
<p><strong>总结：</strong></p>
<p>Java中的synchronized有偏向锁、轻量级锁、重量级锁三种形式，分别对应了锁只被一个线程持有、不同线程交替持有锁、多线程竞争锁三种情况</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">重量级锁</td>
<td align="center">底层使用的monitor实现，里面涉及到了用户态和内核态的切换、进程的上下文切换，成本较高，性能比较低</td>
</tr>
<tr>
<td align="center">轻量级锁</td>
<td align="center">线程加锁的时间是错开的（也就是没有竞争），可以使用轻量级锁来优化。轻量级修改了对象头的锁标志，相对重量级锁性能提升很多。每次修改都是CAS操作，保证原子性</td>
</tr>
<tr>
<td align="center">偏向锁</td>
<td align="center">一段很长的时间内都只被一个线程使用锁，可以使用了偏向锁，在第一次获取锁时，会有一个CAS操作，之后该线程再获取锁，只需要判断mark word中是否是自己的线程id即可，而不是开销相对较大的CAS</td>
</tr>
</tbody></table>
<p><strong>一旦锁发生了竞争，都会升级为重量级锁</strong></p>
<h3 id="谈谈JMM（Java内存模型）"><a href="#谈谈JMM（Java内存模型）" class="headerlink" title="谈谈JMM（Java内存模型）"></a>谈谈JMM（Java内存模型）</h3><ul>
<li>JMM（Java Memory Model）Java内存模型，定义了<strong>共享内存</strong>中<strong>多线程程序读写操作</strong>的行为规范，通过这些规则来规范对内存的读写操作从而保证指令的正确性</li>
<li>JMM把内存分为两块，一块是私有线程的工作区域（工作内存），一块是所有线程的共享区域（主内存）</li>
<li>线程跟线程之间是相互隔离，线程跟线程交互需要通过主内存</li>
</ul>
<h3 id="CAS你知道吗？"><a href="#CAS你知道吗？" class="headerlink" title="CAS你知道吗？"></a>CAS你知道吗？</h3><ul>
<li>CAS体现的是一种乐观锁的思想，在无锁状态下保持线程操作数据的原子性</li>
<li>CAS使用到的地方很多：AQS框架、AtomicXXX类</li>
<li>在操作共享变量的时候使用的自旋锁，效率上更高一些</li>
<li>CAS的底层是调用的Unsafe类中的方法，都是操作系统提供的，其他语言实现的</li>
</ul>
<p>CAS的数据交换流程：一个当前值V、旧的预期值A、即将更新的值B，当且仅当旧的预期值A和内存值V相同时，将内存值修改为B并返回true，否则什么都不做，并返回false。如果CAS操作失败，通过自旋的方式等待并再次尝试，直到成功</p>
<ul>
<li>因为没有加锁，所以线程不会陷入阻塞，效率较高</li>
<li>如果竞争激烈，重试频繁发生，效率会受到影响</li>
</ul>
<h4 id="乐观锁和悲观锁的区别"><a href="#乐观锁和悲观锁的区别" class="headerlink" title="乐观锁和悲观锁的区别"></a>乐观锁和悲观锁的区别</h4><ul>
<li>CAS是基于乐观锁的思想：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没有关系，我吃点亏再试试</li>
<li>synchronized是基于悲观锁的思想：最悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想改，我改完了解开锁，你们才有机会</li>
</ul>
<h3 id="请谈谈你对volatile的理解"><a href="#请谈谈你对volatile的理解" class="headerlink" title="请谈谈你对volatile的理解"></a>请谈谈你对volatile的理解</h3><p>一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：</p>
<ol>
<li><strong>保证线程间的可见性</strong></li>
<li><strong>禁止进行指令重排序</strong></li>
</ol>
<p><strong>保证线程间的可见性</strong></p>
<p>用volatile修饰共享变量时，能够防止编译器等优化发生，让一个线程对共享变量的修改对另一个线程可见</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForeverLoop</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">stop</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            stop = <span class="literal">true</span>;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:modify stop to true...&quot;</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">200</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + stop);</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (!stop) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;stopped...c:&quot;</span> + i);</span><br><span class="line">        &#125;, <span class="string">&quot;t3&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行以上代码：</p>
<p>输出：</p>
<p><img src="/../images/shujuku/103.png" alt="运行结果"></p>
<p>可以发现线程3不停止，一直在运行</p>
<p>问题分析：主要是因为在JVM虚拟机中有一个JIT（即时编译器）给代码做了优化</p>
<p><img src="/../images/shujuku/104.png" alt="优化"></p>
<p>解决方案一：在程序运行的时候加上vm参数**-Xint**表示禁用即时编译器，不推荐，得不偿失（其它程序还要使用）</p>
<p>解决方案二：在修饰<strong>stop</strong>变量时候加上<strong>volatile</strong>，告诉当前JIT，不要对volatile修饰的变量做优化</p>
<p>使用上述两种方案都可以解决：</p>
<p><img src="/../images/shujuku/105.png" alt="输出"></p>
<p><strong>禁止指令重排序</strong></p>
<p>用volatile修饰共享变量会在读、写共享变量时加入不同的屏障，阻止其它读写操作越过屏障，从而达到阻止重排序的效果</p>
<p><img src="/../images/shujuku/106.png" alt="例子"></p>
<p>注解@Actor保证方法内的代码在同一个线程下执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lh;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.openjdk.jcstress.annotations.*;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jcstress.infra.results.II_Result;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> LH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> volatile指令重排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2025/04/13 11:09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@JCStressTest</span></span><br><span class="line"><span class="meta">@Outcome(id = &#123;&quot;0, 0&quot;, &quot;1,1&quot;, &quot;0, 1&quot;&#125;, expect = Expect.ACCEPTABLE, desc = &quot;ACCEPTABLE&quot;)</span></span><br><span class="line"><span class="meta">@Outcome(id = &quot;1, 0&quot;, expect = Expect.ACCEPTABLE_INTERESTING, desc = &quot;INTERESTING&quot;)</span></span><br><span class="line"><span class="meta">@State</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReorderTest</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Actor</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor1</span><span class="params">()</span> &#123;</span><br><span class="line">        x = <span class="number">1</span>;</span><br><span class="line">        y = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Actor</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor2</span><span class="params">(II_Result r)</span> &#123;</span><br><span class="line">        r.r1 = y;</span><br><span class="line">        r.r2 = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置Application：（如下配置）</p>
<p><img src="/../images/shujuku/107.png" alt="配置"></p>
<p>执行clean和package，然后运行这个Application，之后可以看到多出来个results文件夹，打开第一个页面</p>
<p><img src="/../images/shujuku/108.png" alt="results"></p>
<p>可以发现，存在1，0结果，相当于发生了指令重排序</p>
<p><img src="/../images/shujuku/109.png" alt="结果"></p>
<p><strong>在y变量前加上volatile，禁止指令重排序，再次运行：可以发现1，0的情况消息</strong></p>
<p><img src="/../images/shujuku/110.png" alt="结果"></p>
<p><strong>但是如果将volatile加到x前面，再次重复上述操作，看看运行结果：可以发现1，0的情况又出现了</strong></p>
<p><img src="/../images/shujuku/112.png" alt="结果"></p>
<p>原因：看下面两张图</p>
<p>首先是使用volatile修饰y</p>
<p><img src="/../images/shujuku/113.png" alt="volatile y"></p>
<p>然后是volatile修饰x</p>
<p><img src="/../images/shujuku/114.png" alt="volatile y"></p>
<p>可以看出volatile使用小技巧：</p>
<ul>
<li>写变量让volatile修饰的变量在代码的最后位置</li>
<li>读变量让volatile修饰的变量在代码的开始位置（使用volatile y可以解决问题）</li>
</ul>
<p><strong>总结：</strong></p>
<ol>
<li>保证线程间的可见性</li>
</ol>
<p>用volatile修饰共享变量时，能够防止编译器等优化发生，让一个线程对共享变量的修改对另一个线程可见</p>
<ol start="2">
<li>禁止进行指令重排序</li>
</ol>
<p>用volatile修饰共享变量会在读、写共享变量时加入不同的屏障，阻止其它读写操作越过屏障，从而达到阻止重排序的效果</p>
<h3 id="什么是AQS"><a href="#什么是AQS" class="headerlink" title="什么是AQS"></a>什么是AQS</h3><ul>
<li>是多线程中的队列同步器。是一种锁机制，它是作为一个<strong>基础框架</strong>使用的，像ReentrantLock（阻塞式锁）、Semaphore（信号量）、CountDownLatch（倒计时锁）都是基于AQS实现的</li>
<li>AQS内部维护了一个先进先出的双向队列，队列中存储的排队的线程</li>
<li>在AQS内部还有一个属性state，这个state就相当于是一个资源，默认是0（无锁状态），如果队列中的有一个线程修改成功了state为1，则当前线程就相当于获取了资源</li>
<li>在对state修改的时候使用CAS操作，保证多个线程修改的情况下的原子性</li>
</ul>
<p><img src="/../images/shujuku/115.png" alt="AQS"></p>
<h3 id="ReentrantLock的实现原理"><a href="#ReentrantLock的实现原理" class="headerlink" title="ReentrantLock的实现原理"></a>ReentrantLock的实现原理</h3><ul>
<li>ReentrantLock表示支持重新进入的锁，调用lock方法获取了锁之后，再次调用lock，是不会再阻塞</li>
<li>ReentrantLock主要利用<strong>CAS+AQS</strong>队列来实现</li>
<li>支持公平锁和非公平锁，在提供的构造器中无参默认是<strong>非公平锁</strong>，当设置为true时，表示公平锁，否则是非公平锁</li>
</ul>
<h3 id="synchronized和Lock有什么区别"><a href="#synchronized和Lock有什么区别" class="headerlink" title="synchronized和Lock有什么区别"></a>synchronized和Lock有什么区别</h3><ul>
<li>语法层面</li>
</ul>
<p>synchronized是关键字，源码在jvm中，用c++语言实现</p>
<p>Lock是接口，源码由jdk提供，用java语言实现</p>
<p>使用synchronized时，退出同步代码块锁会自动释放，而使用Lock时，需要手动调用unlock方法释放锁</p>
<ul>
<li>功能层面</li>
</ul>
<p>二者均属于悲观锁、都具备基本的互斥、同步、锁重入功能</p>
<p>Lock提供了许多synchronized不具备的功能，例如公平锁、可打断、可超时、多条件变量</p>
<p>Lock有适合不同场景的实现，如ReentrantLock、ReentrantReadWriteLock（读写锁）</p>
<ul>
<li>性能层面</li>
</ul>
<p>在没有竞争时，synchronized做了很多优化，如偏向锁、轻量级锁，性能不赖</p>
<p>在竞争激烈时，Lock的实现通常会提供更好的性能</p>
<h3 id="死锁产生的条件是什么？"><a href="#死锁产生的条件是什么？" class="headerlink" title="死锁产生的条件是什么？"></a>死锁产生的条件是什么？</h3><ul>
<li>互斥条件：互斥条件指的是<strong>多个线程不能同时使用同一个资源</strong></li>
<li>持有并等待条件：持有并等待条件是指，当线程 A 已经持有了资源 1，又想申请资源 2，而资源 2 已经被线程 C 持有了，所以线程 A 就会处于等待状态，但是<strong>线程 A 在等待资源 2 的同时并不会释放自己已经持有的资源 1</strong>。</li>
<li>不可剥夺条件：不可剥夺条件是指，当线程已经持有了资源 ，<strong>在自己使用完之前不能被其他线程获取</strong>，线程 B 如果也想使用此资源，则只能在线程 A 使用完并释放后才能获取。**</li>
<li>环路等待条件：环路等待条件指的是，在死锁发生的时候，<strong>两个线程获取资源的顺序构成了环形链</strong>。</li>
</ul>
<p>执行如下代码，线程t1和线程t2发生死锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLock</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">A</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">B</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (A) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-lock A&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (B) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-lock B&quot;</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-操作...&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (B) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-lock B&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (A) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-lock A&quot;</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-操作...&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如何进行死锁诊断？</strong></p>
<p>当程序出现了死锁现象，我们可以使用jdk自带的工具：<strong>jps和jstack</strong></p>
<ul>
<li><strong>jps</strong>：输出JVM中运行的<strong>进程状态</strong>信息</li>
<li><strong>jstack</strong>：查看java进程内<strong>线程的堆栈</strong>信息</li>
</ul>
<p>使用jps：</p>
<p><img src="/../images/shujuku/116.png" alt="jps"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">输入命令</span></span><br><span class="line">jstack -l 1932</span><br></pre></td></tr></table></figure>

<p>然后可以查看死锁情况</p>
<p><img src="/../images/shujuku/117.png" alt="jstack"></p>
<p>还可以使用<strong>jconsole</strong>可视化工具进行诊断（在jdk安装bin下有jconsole.exe）</p>
<p><img src="/../images/shujuku/118.png" alt="jconsole"></p>
<p>还可以使用VisualVM进行诊断（打开方式，VisualVM安装bin下的visualvm.exe）</p>
<p><img src="/../images/shujuku/119.png" alt="VisualVM"></p>
<h3 id="聊一下ConcurrentHashMap"><a href="#聊一下ConcurrentHashMap" class="headerlink" title="聊一下ConcurrentHashMap"></a>聊一下ConcurrentHashMap</h3><ul>
<li>底层数据结构<ul>
<li>JDK1.7底层采用分段的数组+链表实现</li>
<li>JDK1.8采用的数据结构跟HashMap1.8的结构一样，数组+链表&#x2F;红黑二叉树</li>
</ul>
</li>
<li>加锁的方式<ul>
<li>JDK1.7采用Segment分段锁，底层使用的是ReentrantLock</li>
<li>JDK1.8采用CAS添加新节点，采用synchronized锁定链表或红黑树的首节点，相对Segment分段锁粒度更细，性能更好</li>
</ul>
</li>
</ul>
<h3 id="导致并发程序出现问题的根本原因是什么？（如何保证多线程的执行安全）"><a href="#导致并发程序出现问题的根本原因是什么？（如何保证多线程的执行安全）" class="headerlink" title="导致并发程序出现问题的根本原因是什么？（如何保证多线程的执行安全）"></a>导致并发程序出现问题的根本原因是什么？（如何保证多线程的执行安全）</h3><p>Java并发编程三大特性</p>
<ul>
<li>原子性</li>
<li>可见性</li>
<li>有序性</li>
</ul>
<p><strong>原子性：</strong>一个线程在CPU中操作不可暂停，也不可中断，要不执行完成，要不不执行</p>
<ul>
<li>synchronized：同步加锁</li>
<li>JUC里面的lock：加锁</li>
</ul>
<p><strong>内存可见性：</strong>让一个线程对共享变量的修改对另一个线程可见</p>
<ul>
<li>volatile</li>
<li>synchronized</li>
<li>Lock</li>
</ul>
<p><strong>有序性：</strong></p>
<p>指令重排：处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的</p>
<ul>
<li>volatile</li>
</ul>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="说一下线程池的核心参数（线程池的执行原理）"><a href="#说一下线程池的核心参数（线程池的执行原理）" class="headerlink" title="说一下线程池的核心参数（线程池的执行原理）"></a>说一下线程池的核心参数（线程池的执行原理）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                          TimeUnit unit,</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue, </span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>corePoolSize：核心线程数目</li>
<li>maximumPoolSize：最大线程数目&#x3D;核心线程数目+非核心线程的最大数目</li>
<li>keepAliveTime：生存时间-非核心线程的生存时间，生存时间内没有新任务，此线程资源会释放</li>
<li>unit：时间单位-非核心线程的生存时间单位，如秒、毫秒等</li>
<li>workQueue：当没有空闲核心线程时，新来任务会加入到此队列排队，队列满会创建非核心线程执行任务</li>
<li>threadFactory：线程工厂-可以定制线程对象的创建，例如设置线程名字、是否是守护线程等</li>
<li>handler：拒绝策略-当所有线程都在繁忙，workQueue也放满时，会触发拒绝策略</li>
</ul>
<p><strong>线程池的执行原理：</strong></p>
<p><img src="/../images/shujuku/120.png" alt="线程池的执行原理"></p>
<p>拒绝策略：</p>
<ol>
<li>AbortPolicy：直接抛出异常，默认策略；</li>
<li>CallerRunsPolicy：用调用者所在的线程来执行任务；</li>
<li>DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；</li>
<li>DiscardPolicy：直接丢弃任务；</li>
</ol>
<h3 id="线程中有哪些常见的阻塞队列？"><a href="#线程中有哪些常见的阻塞队列？" class="headerlink" title="线程中有哪些常见的阻塞队列？"></a>线程中有哪些常见的阻塞队列？</h3><p>workQueue-当没有空闲核心线程时，新来任务会加入到此队列排队，队列满会创建非核心线程执行任务</p>
<ol>
<li><strong>ArrayBlockingQueue：基于数组结构的有界阻塞队列，FIFO</strong></li>
<li><strong>LinkedBlockingQueue：基于链表结构的有界队列，FIFO</strong></li>
<li>DelayedWorkQueue：是一个优先级队列，它可以保证每次出队和任务都是当前队列中执行时间最靠前的</li>
<li>SynchronousQueue：不存储元素的阻塞队列，每个插入操作都必须等待一个移除操作</li>
</ol>
<p>ArrayBlockingQueue的LinkedBlockingQueue的区别：</p>
<table>
<thead>
<tr>
<th align="center">LinkedBlockingQueue</th>
<th align="center">ArrayBlockingQueue</th>
</tr>
</thead>
<tbody><tr>
<td align="center">默认无界，支持有界</td>
<td align="center">强制有界</td>
</tr>
<tr>
<td align="center">底层是链表</td>
<td align="center">底层是数组</td>
</tr>
<tr>
<td align="center">是懒惰的，创建节点的时候添加数据</td>
<td align="center">提前初始化Node数组</td>
</tr>
<tr>
<td align="center">入队会生成新Node</td>
<td align="center">Node需要是提前创建好的</td>
</tr>
<tr>
<td align="center">两把锁（头尾）</td>
<td align="center">一把锁</td>
</tr>
</tbody></table>
<p><img src="/../images/shujuku/121.png" alt="锁原理"></p>
<h3 id="如何确定核心线程数？"><a href="#如何确定核心线程数？" class="headerlink" title="如何确定核心线程数？"></a>如何确定核心线程数？</h3><ul>
<li>IO密集型任务</li>
</ul>
<p>一般来说：文件读写、DB读写、网络请求等</p>
<ul>
<li>CPU密集型任务</li>
</ul>
<p>一般来说：计算型代码、Bitmap转换、Gson转换等</p>
<p><strong>总结：</strong></p>
<ul>
<li><p><strong>高并发、任务执行时间短 —&gt; （CPU核数 + 1）</strong>，减少线程上下文切换</p>
</li>
<li><p><strong>并发不高、任务执行时间长</strong></p>
<ul>
<li><strong>IO密集型的任务 —&gt; （CPU核数 * 2 + 1）</strong></li>
<li><strong>计算密集型任务 —&gt; （CPU核数 + 1）</strong></li>
</ul>
</li>
<li><p><strong>并发高、业务执行时间长</strong>，解决这种类型任务的关键不在于线程池而在于整体架构的设计，看看这些业务里面某些数据是否能做缓存是第一步，增加服务器是第二步，至于线程池的设置，参考上面</p>
</li>
</ul>
<h3 id="线程池的种类有哪些？"><a href="#线程池的种类有哪些？" class="headerlink" title="线程池的种类有哪些？"></a>线程池的种类有哪些？</h3><ul>
<li>newFixedThreadPool：创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待<ul>
<li>适用于任务量已知，相对耗时的任务</li>
</ul>
</li>
<li>newSingleThreadExecutor：创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序（FIFO）执行<ul>
<li>适用于按照顺序执行的任务</li>
</ul>
</li>
<li>newCachedThreadPool：创建一个可缓存线程池，如果线程池长度超过处理需求，可以灵活回收空闲线程，若无可回收，则新建线程<ul>
<li>适合任务数比较密集，但每个任务执行时间较短的情况</li>
</ul>
</li>
<li>newScheduledThreadPool：可以执行延迟任务的线程池，支持定时及周期性任务执行</li>
</ul>
<h3 id="为什么不建议用Executors创建线程池？"><a href="#为什么不建议用Executors创建线程池？" class="headerlink" title="为什么不建议用Executors创建线程池？"></a>为什么不建议用Executors创建线程池？</h3><p>Executors返回的线程池对象的弊端如下：</p>
<ol>
<li>FixedThreadPool和SingleThreadExecutor：</li>
</ol>
<p>允许的请求队列长度为Integer.MAX_VALUE，可能会堆积大量的请求，从而导致OOM</p>
<ol start="2">
<li>CachedThreadPool</li>
</ol>
<p>允许的创建线程数量为Integer.MAX_VALUE，可能会创建大量的线程，从而导致OOM</p>
<h2 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h2><h3 id="线程池使用场景（CountDownLatch、Future）"><a href="#线程池使用场景（CountDownLatch、Future）" class="headerlink" title="线程池使用场景（CountDownLatch、Future）"></a>线程池使用场景（CountDownLatch、Future）</h3><p><strong>CountDownLatch</strong></p>
<p>CountDownLatch（闭锁&#x2F;倒计时锁）用来进行线程同步协作，等待所有线程完成倒计时（一个或者多个线程，等待其他多个线程完成某件事情之后才能执行）</p>
<ul>
<li>其中构造参数用来初始化等待计数值</li>
<li>await()用来等待计数归零</li>
<li>countDown()用来让计数减一</li>
</ul>
<p><strong>使用场景一（es数据批量导入）</strong></p>
<p>需要将数据库中数据一次性同步到es索引库中，当时数据好像有1000w，一次性读取数据肯定不行（oom异常），当时我就想到可以使用线程池的方式导入，利用CountDownLatch来控制，就能避免一次性加载过多，防止内存溢出</p>
<p><img src="/../images/shujuku/122.png" alt="业务流程"></p>
<p><strong>使用场景二（数据汇总）</strong></p>
<p>在一个电商网站中，用户下单之后，需要查询数据，数据包含了三部分：订单信息、包含的商品、物流信息；这三块信息都在不同的微服务中进行实现的，我们如何完成这个业务呢？</p>
<p><img src="/../images/shujuku/123.png" alt="业务流程"></p>
<p>在实际开发的过程中，难免需要调用多个接口来汇总数据，如果所有接口（或部分接口）的没有依赖关系，就可以使用线程池+future来提高性能</p>
<p><strong>使用场景三（异步线程）</strong></p>
<p>为了避免下一级方法影响上一级啊方法（性能考虑），可以使用异步线程调用下一个方法（不需要下一级方法返回值），可以提升方法响应时间</p>
<h3 id="如何控制某个方法允许并发访问线程的数量"><a href="#如何控制某个方法允许并发访问线程的数量" class="headerlink" title="如何控制某个方法允许并发访问线程的数量"></a>如何控制某个方法允许并发访问线程的数量</h3><p>在多线程中提供了一个工具Semphore，信号量。在并发的情况下，可以控制方法的访问量</p>
<ol>
<li>创建Semaphore对象，可以给一个容量</li>
<li>acquire()可以请求一个信号量，这时候的信号量个数-1</li>
<li>release()释放一个信号量，此时信号量个数+1</li>
</ol>
<h3 id="谈谈你对ThreadLocal的理解"><a href="#谈谈你对ThreadLocal的理解" class="headerlink" title="谈谈你对ThreadLocal的理解"></a>谈谈你对ThreadLocal的理解</h3><ul>
<li>ThreadLocal可以实现【资源对象】的线程隔离，让每个线程各用各的【资源对象】，避免争用引发的线程安全问题</li>
<li>ThreadLocal同时实现了线程内的资源共享</li>
<li>每个线程都有一个ThreadLocalMap类型的成员变量，用来存储资源对象<ul>
<li>调用set方法，就是以ThreadLocal自己作为key，资源对象作为value，放入当前线程的ThreadLocalMap集合中</li>
<li>调用get方法，就是以ThreadLocal自己作为key，到当前线程中查找关联的资源值</li>
<li>调用remove方法，就是以ThreadLocal自己作为key，移除当前线程关联的资源值</li>
</ul>
</li>
<li>TheradLocal内存泄漏问题：ThreadLocalMap中的key是弱引用，值为强引用；key会被GC释放内存，关联value的内存并不会释放。建议主动remove释放key，value</li>
</ul>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="工厂设计模式"><a href="#工厂设计模式" class="headerlink" title="工厂设计模式"></a>工厂设计模式</h2><h3 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a><strong>简单工厂</strong></h3><ul>
<li>所有的产品都共有一个工厂，如果新增产品，则需要修改代码，违反开闭原则</li>
<li>是一种编程习惯，可以借鉴这种编程思路</li>
</ul>
<p>简单工厂包含如下角色：</p>
<ul>
<li>抽象产品：定义了产品的规范，描述了产品的主要特性和功能</li>
<li>具体产品：实现或者继承抽象产品的子类</li>
<li>具体工厂：提供了创建产品的方法，调用者通过该方法来获取产品</li>
</ul>
<p><img src="D:/Blog/source/images/shujuku/124.png" alt="简单工厂"></p>
<h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a><strong>工厂方法模式</strong></h3><ul>
<li>给每个产品都提供了一个工厂，让工厂专门负责对应的产品生产，遵循开闭原则</li>
<li>项目中用的最多</li>
</ul>
<p>工厂方法模式的主要角色：</p>
<ul>
<li>抽象工厂：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法来创建产品</li>
<li>具体工厂：主要是实现抽象工厂中的抽象方法，完成具体产品的创建</li>
<li>抽象产品：定义了产品的规范，描述了产品的主要特性和功能</li>
<li>具体产品：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应</li>
</ul>
<p><img src="D:/Blog/source/images/shujuku/125.png" alt="工厂方法"></p>
<h3 id="抽象工厂方法模式"><a href="#抽象工厂方法模式" class="headerlink" title="抽象工厂方法模式"></a><strong>抽象工厂方法模式</strong></h3><ul>
<li>如果有多个维度的产品需要配合生产时，优先建议采用抽象工厂（工厂的工厂）</li>
<li>一般的企业开发中的较少</li>
</ul>
<p>抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品</p>
<p><strong>一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂</strong></p>
<p><img src="D:/Blog/source/images/shujuku/126.png" alt="抽象工厂"></p>
<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><ul>
<li>该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户</li>
<li>它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理</li>
</ul>
<p>策略模式的主要角色如下：</p>
<ul>
<li>抽象策略类：这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口</li>
<li>具体策略类：实现了抽象策略定义的接口，提供具体的算法实现或行为</li>
<li>环境类：持有一个策略类的引用，最终给客户端调用</li>
</ul>
<p><img src="D:/Blog/source/images/shujuku/127.png" alt="策略模式"></p>
<p><strong>优点：</strong></p>
<p>策略类之间可以自由切换</p>
<p>易于扩展</p>
<p>避免使用多重条件选择语句（if else），充分体现面向对象设计思想</p>
<p><strong>缺点：</strong></p>
<p>客户端必须知道所有的策略类，并自行决定使用哪一个策略类</p>
<p>策略模式将造成产生很多策略类</p>
<h2 id="登陆案例（工厂模式-策略模式）"><a href="#登陆案例（工厂模式-策略模式）" class="headerlink" title="登陆案例（工厂模式+策略模式）"></a>登陆案例（工厂模式+策略模式）</h2><ul>
<li>订单的支付策略（支付宝、微信、银行卡…）</li>
<li>解析不同类型excel（xls格式、xlsx格式）</li>
<li>打折促销（满300元9折、满500元8折、满1000元7折）</li>
<li>物流运费阶梯计算（5kg以下、5-10kg、10-20kg、20kg以上）</li>
</ul>
<p><strong>一句话总结：只要代码中有冗长的if-else或switch分支判断都可以采用策略模式优化</strong></p>
<p>回答流程：</p>
<ul>
<li>介绍业务（登陆、支付、解析excel、优惠等级…）</li>
<li>提供了很多种策略，都让spring容器管理</li>
<li>提供一个工厂：准备策略对象 ，根据参数提供对象</li>
</ul>
<h2 id="责任链设计模式"><a href="#责任链设计模式" class="headerlink" title="责任链设计模式"></a>责任链设计模式</h2><p>责任链模式：为了避免请求发送者与多个请求处理者耦合在一起，将所有请求的处理者通过前一个对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，知道有对象处理它为止</p>
<ul>
<li>抽象处理者角色：定义一个处理请求的接口，包含抽象处理方法和一个后继连接</li>
<li>具体处理者角色：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者</li>
<li>客户类角色：创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程</li>
</ul>
<p><img src="D:/Blog/source/images/shujuku/128.png" alt="责任链模式"></p>
<p><strong>责任链模式的优缺点：</strong></p>
<p>优点：</p>
<ul>
<li>降低了对象之间的耦合度</li>
<li>增强了系统的可扩展性</li>
<li>增强了给对象指派职责的灵活性</li>
<li>责任链简化了对象之间的连接</li>
<li>责任分担</li>
</ul>
<p>缺点：</p>
<ul>
<li>对比较长的责任链，请求的处理可能涉及多个处理对象，系统性能可能受到一定影响</li>
<li>责任链建立的合理性要靠客户端来保证，增强了客户端的复杂性，可能会由于责任链的错误设置而导致系统出现错误，如可能会造成循环调用</li>
</ul>
<p><strong>常见的业务中的责任链：</strong></p>
<p><img src="D:/Blog/source/images/shujuku/129.png" alt="业务中的责任链"></p>
<h1 id="技术场景"><a href="#技术场景" class="headerlink" title="技术场景"></a>技术场景</h1><h2 id="单点登陆这块是怎么实现的？"><a href="#单点登陆这块是怎么实现的？" class="headerlink" title="单点登陆这块是怎么实现的？"></a>单点登陆这块是怎么实现的？</h2><p><strong>SSO（单点登陆）：</strong>只需要登陆一次，就可以访问所有信任的应用系统</p>
<p><img src="D:/Blog/source/images/shujuku/130.png" alt="问题分析"></p>
<p>单点登陆解决方案：</p>
<ul>
<li>JWT（常见）</li>
<li>Oauth2</li>
<li>CAS</li>
<li>…</li>
</ul>
<p><img src="D:/Blog/source/images/shujuku/131.png" alt="实现流程"></p>
<p><strong>总结：</strong></p>
<ol>
<li>先解释什么叫做单点登陆</li>
</ol>
<p>单点登陆的英文名称叫做：Single Sign On（简称<strong>SSO</strong>）</p>
<ol start="2">
<li>介绍自己项目中涉及到的单点登陆（即使没有涉及过，也可以说实现的思路）</li>
<li>介绍单点登陆的解决方案，以JWT为例</li>
</ol>
<ul>
<li>用户访问其他系统，会在网关判断token是否有效</li>
<li>如果token无效则会返回401（认证失败）前端跳转到登陆页面</li>
<li>用户发送登陆请求，返回浏览器一个token，浏览器把token保存到cookie</li>
<li>再去访问其他服务的时候，都需要携带token，由网关统一验证后路由到目标服务</li>
</ul>
<h2 id="权限认证是如何实现的？"><a href="#权限认证是如何实现的？" class="headerlink" title="权限认证是如何实现的？"></a>权限认证是如何实现的？</h2><p>后台的管理系统，更注重权限控制，最常见的就是RBAC模型来指导实现权限</p>
<p>RBAC–基于角色的访问控制</p>
<ul>
<li>3个基础部分组成：用户、角色、权限</li>
<li>具体实现<ul>
<li>5张表（用户表、角色表、权限表、用户角色中间表、角色权限中间表）</li>
<li>7张表（用户表、角色表、权限表、菜单表、用户角色中间表、角色权限中间表、权限菜单中间表）</li>
</ul>
</li>
</ul>
<p><img src="D:/Blog/source/images/shujuku/132.png" alt="RBAC权限模型"></p>
<p><img src="D:/Blog/source/images/shujuku/134.png" alt="举例分析"></p>
<p>张三具有什么权限呢？</p>
<p>流程：张三登陆系统—-&gt;查询张三拥有的角色列表—-&gt;再根据角色查询拥有的权限</p>
<p>权限框架：</p>
<p>Apache chiro、Spring security（推荐）</p>
<h2 id="上传数据的安全性你们怎么控制？"><a href="#上传数据的安全性你们怎么控制？" class="headerlink" title="上传数据的安全性你们怎么控制？"></a>上传数据的安全性你们怎么控制？</h2><p><strong>对称加密</strong></p>
<p>文件加密和解密使用相同的密钥，即加密密钥也可以用作解密密钥</p>
<p><img src="D:/Blog/source/images/shujuku/135.png" alt="对称加密"></p>
<p>优点：加密速度快，效率高</p>
<p>缺点：相对不安全（不要保存敏感信息）</p>
<p><strong>非对称加密</strong></p>
<p>两个密钥：公开密钥和私有密钥，共有密钥加密，私有密钥解密</p>
<p><img src="D:/Blog/source/images/shujuku/136.png" alt="非对称密钥"></p>
<p>优点：与对称加密相比，安全性更高</p>
<p>缺点：加密和解密速度慢，建议少量数据加密</p>
<p><strong>总结：</strong></p>
<p>使用<strong>非对称加密（或对称加密）</strong>，给前端一个公钥让他把数据加密后传到后台，后台负责解密后处理数据</p>
<ul>
<li>文件很大建议使用对称加密，不过不能保存敏感信息</li>
<li>文件较小，要求安全性高，建议采用非对称加密</li>
</ul>
<h2 id="你负责项目的时候遇到了哪些比较棘手的问题？怎么解决的"><a href="#你负责项目的时候遇到了哪些比较棘手的问题？怎么解决的" class="headerlink" title="你负责项目的时候遇到了哪些比较棘手的问题？怎么解决的"></a>你负责项目的时候遇到了哪些比较棘手的问题？怎么解决的</h2><ol>
<li><p>在负责洪涝项目开发过程中，一开始我没有使用到策略模式，所有的登陆都是融合到业务类中的，在后续开发过程中发现需求经常改，然后登陆代码就经常变换。在后续中，使用工厂和策略模式实现登陆模块，解决了经常修改代码方面的问题</p>
</li>
<li><p>还有一个，在设计美食平台系统时，要解决单点登陆问题。之后查询资料和自己对于代码的理解采用JWT方式解决单点登陆问题。为了加深自己的印象，也使用了token和redis方案解决单点登陆问题</p>
</li>
<li><p>还有库存超卖问题，在之前的美食平台系统设计中，其中涉及到一个库存超卖问题，经过查阅资料，先使用了悲观锁解决库存超卖问题，但是在进行接口测试过程中发现反应时间较长。最后使用redis和乐观锁方式解决库存超卖问题。</p>
</li>
</ol>
<h2 id="你们项目中日志怎么采集的？"><a href="#你们项目中日志怎么采集的？" class="headerlink" title="你们项目中日志怎么采集的？"></a>你们项目中日志怎么采集的？</h2><p>为什么要采集日志？</p>
<p>日志是定位系统问题的重要手段，可以根据日志信息快速定位系统中的问题</p>
<p>采集日志的方式有哪些？</p>
<ul>
<li>ELK：即Elasticsearch、Logstach和Kibana三个软件的首字母</li>
<li>常规采集：按天保存到一个日志文件中</li>
</ul>
<p><img src="D:/Blog/source/images/shujuku/137.png" alt="日志采集"></p>
<p><strong>总结：</strong></p>
<ul>
<li>我们搭建了ELK日志采集系统</li>
<li>介绍ELK的三个组件：<ul>
<li>Elasticsearch是全文搜索分析引擎，可以对数据存储、搜索、分析</li>
<li>Logstach是一个数据收集引擎，可以动态收集数据，可以堆数据进行过滤、分析，将数据存储到指定的位置</li>
<li>Kibana是一个数据分析和可视化平台，配合Elasticsearch对数据进行搜索，分析，图标化展示</li>
</ul>
</li>
</ul>
<h2 id="常见日志的命令"><a href="#常见日志的命令" class="headerlink" title="常见日志的命令"></a>常见日志的命令</h2><p><img src="D:/Blog/source/images/shujuku/138.png" alt="日志命令"></p>
<h2 id="生产问题怎么排查？"><a href="#生产问题怎么排查？" class="headerlink" title="生产问题怎么排查？"></a>生产问题怎么排查？</h2><p>已经上线的bug排查思路：</p>
<ul>
<li>先分析日志，通常在业务中都会有日志的记录，或者查看系统日志，或者查看日志文件，然后定位问题</li>
<li>远程debug（通常公司的正式环境（生产环境）是不允许远程debug。一般远程debug都是公司的测试环境，方便调试代码）</li>
</ul>
<h2 id="怎么快速定位系统的瓶颈？"><a href="#怎么快速定位系统的瓶颈？" class="headerlink" title="怎么快速定位系统的瓶颈？"></a>怎么快速定位系统的瓶颈？</h2><ul>
<li><p>压测（性能测试），<strong>项目上线之前测试系统的压力</strong></p>
<ul>
<li>压测目的：给出系统当前的性能状况；定位系统性能瓶颈或潜在性能瓶颈</li>
<li>指标：响应时间、QPS、并发数、吞吐量、CPU利用率、内存使用率、磁盘IO、错误率</li>
<li>压测工具：Apache Jmeter、LoadRunner</li>
<li>后端工程师：根据压测的结果进行解决或调优（接口慢、代码报错、并发达不到要求…）</li>
</ul>
</li>
<li><p>监控工具、链路追踪工具，<strong>项目上线之后监控</strong></p>
<ul>
<li>监控工具：Prometheus+Grafana</li>
<li>链路追踪工具：skywalking、Zipkin</li>
</ul>
</li>
<li><p>线上诊断工具Arthas（阿尔萨斯），<strong>项目上线之后监控、排查</strong></p>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="http://example.com">HERAO</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="http://example.com/2025/03/09/%E9%9D%A2%E8%AF%95%E9%A2%98/">http://example.com/2025/03/09/%E9%9D%A2%E8%AF%95%E9%A2%98/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/02/03/Docker%E9%BB%91%E9%A9%AC/" title="Docker"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">Docker</div></div><div class="info-2"><div class="info-item-1">安装Docker快速构建、运行、管理应用的工具 在centos中使用yum命令报错： 12345678910111213141516171819202122232425262728293031323334353637已加载插件：fastestmirrorLoading mirror speeds from cached hostfileCould not retrieve mirrorlist http://mirrorlist.centos.org/?release=7&amp;arch=x86_64&amp;repo=os&amp;infra=stock error was14: curl#6 - &quot;Could not resolve host: mirrorlist.centos.org; 未知的错误&quot; One of the configured repositories failed (未知), and yum doesn&#x27;t have enough cached data to continue. At this point the...</div></div></div></a><a class="pagination-related" href="/2025/03/19/JVM/" title="JVM"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">JVM</div></div><div class="info-2"><div class="info-item-1">概念定义：Java Virtual Machine - java程序运行环境（java二进制字节码的运行环境） 好处：  一次编写，到处运行 自动内存管理，垃圾回收功能 数组下标越界检查 多态  JVM JRE JDK三者关系：  内存结构程序计数器Program Counter Register程序计数器（寄存器） 作用 记住下一条jvm指令的执行地址，解释器读取二进制字节码转换为机器码 特点  线程私有的，属于单个线程 不会存在内存溢出  虚拟机栈栈：线程运行需要的内存空间 栈帧：每个方法运行时需要的内存（参数、局部变量、返回地址） Java Virtual Machine...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">HERAO</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">16</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AD%94%E9%A2%98%E6%8A%80%E5%B7%A7"><span class="toc-number">1.</span> <span class="toc-text">答题技巧</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">2.</span> <span class="toc-text">Spring面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%88%E8%B0%88Spring-IOC%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%8C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-number">2.1.</span> <span class="toc-text">谈谈Spring IOC的理解，原理与实现？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%88%E4%B8%80%E4%B8%8BSpring-IOC%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.2.</span> <span class="toc-text">谈一下Spring IOC的底层实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8Bbean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">2.3.</span> <span class="toc-text">描述一下bean的生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring%E6%98%AF%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E7%9A%84%E9%97%AE%E9%A2%98%E7%9A%84"><span class="toc-number">2.4.</span> <span class="toc-text">Spring是如何解决循环依赖的问题的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%9A%84%E6%94%BE%E7%BD%AE%E6%97%B6%E9%97%B4%E5%92%8C%E5%88%A0%E9%99%A4%E6%97%B6%E9%97%B4"><span class="toc-number">2.5.</span> <span class="toc-text">缓存的放置时间和删除时间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BeanFactory%E4%B8%8EFactoryBean%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">2.6.</span> <span class="toc-text">BeanFactory与FactoryBean有什么区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring%E4%B8%AD%E7%94%A8%E5%88%B0%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.7.</span> <span class="toc-text">Spring中用到的设计模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring%E7%9A%84AOP%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">2.8.</span> <span class="toc-text">Spring的AOP的底层实现原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring%E7%9A%84%E4%BA%8B%E5%8A%A1%E6%98%AF%E5%A6%82%E4%BD%95%E5%9B%9E%E6%BB%9A%E7%9A%84"><span class="toc-number">2.9.</span> <span class="toc-text">Spring的事务是如何回滚的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%88%E4%B8%80%E4%B8%8Bspring%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD"><span class="toc-number">2.10.</span> <span class="toc-text">谈一下spring事务传播</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AOP"><span class="toc-number">2.11.</span> <span class="toc-text">AOP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SpringMVC%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">2.12.</span> <span class="toc-text">SpringMVC执行流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%86%E5%9B%BE%E9%98%B6%E6%AE%B5%EF%BC%88JSP%EF%BC%89"><span class="toc-number">2.12.1.</span> <span class="toc-text">视图阶段（JSP）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%98%B6%E6%AE%B5%EF%BC%88%E6%8E%A5%E5%8F%A3%E5%BC%80%E5%8F%91%EF%BC%8C%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82%EF%BC%89"><span class="toc-number">2.12.2.</span> <span class="toc-text">前后端分离阶段（接口开发，异步请求）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86"><span class="toc-number">2.13.</span> <span class="toc-text">SpringBoot自动配置原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring%E6%A1%86%E6%9E%B6%E5%B8%B8%E8%A7%81%E6%B3%A8%E8%A7%A3%EF%BC%88Spring%E3%80%81SpringBoot%E3%80%81SpringMVC%EF%BC%89"><span class="toc-number">2.14.</span> <span class="toc-text">Spring框架常见注解（Spring、SpringBoot、SpringMVC）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MyBatis"><span class="toc-number">3.</span> <span class="toc-text">MyBatis</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#MyBatis%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">3.1.</span> <span class="toc-text">MyBatis执行流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MyBatis%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8E%9F%E7%90%86"><span class="toc-number">3.2.</span> <span class="toc-text">MyBatis延迟加载使用及原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MyBatis%E4%B8%80%E7%BA%A7%E3%80%81%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="toc-number">3.3.</span> <span class="toc-text">MyBatis一级、二级缓存</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">4.</span> <span class="toc-text">Redis面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-number">4.1.</span> <span class="toc-text">缓存穿透</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="toc-number">4.2.</span> <span class="toc-text">缓存击穿</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-number">4.3.</span> <span class="toc-text">缓存雪崩</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">4.4.</span> <span class="toc-text">双写一致性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">4.5.</span> <span class="toc-text">持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RDB"><span class="toc-number">4.5.1.</span> <span class="toc-text">RDB</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOF"><span class="toc-number">4.5.2.</span> <span class="toc-text">AOF</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5"><span class="toc-number">4.6.</span> <span class="toc-text">数据过期策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5"><span class="toc-number">4.7.</span> <span class="toc-text">数据淘汰策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">4.8.</span> <span class="toc-text">分布式锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">4.8.1.</span> <span class="toc-text">使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">4.8.2.</span> <span class="toc-text">实现原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-number">4.9.</span> <span class="toc-text">主从复制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.10.</span> <span class="toc-text">哨兵模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%84%91%E8%A3%82"><span class="toc-number">4.11.</span> <span class="toc-text">脑裂</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4%E7%BB%93%E6%9E%84"><span class="toc-number">4.12.</span> <span class="toc-text">分片集群结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E4%B8%BA%E5%8D%95%E7%BA%BF%E7%A8%8B%EF%BC%8C%E4%BD%86%E6%98%AF%E4%B8%BA%E4%BB%80%E4%B9%88%E9%82%A3%E4%B9%88%E5%BF%AB%EF%BC%9F"><span class="toc-number">4.13.</span> <span class="toc-text">Redis为单线程，但是为什么那么快？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%83%BD%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8BI-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%A8%A1%E5%9E%8B%E5%90%97%EF%BC%9F"><span class="toc-number">4.14.</span> <span class="toc-text">能解释一下I&#x2F;O多路复用模型吗？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MySQL"><span class="toc-number">5.</span> <span class="toc-text">MySQL</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8D%E6%85%A2%E6%9F%A5%E8%AF%A2"><span class="toc-number">5.1.</span> <span class="toc-text">如何定位慢查询</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SQL%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E5%BE%88%E6%85%A2%EF%BC%8C%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90%E5%91%A2%EF%BC%9F"><span class="toc-number">5.2.</span> <span class="toc-text">SQL语句执行很慢，如何分析呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">5.3.</span> <span class="toc-text">索引概念及底层数据结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E3%80%81%E5%9B%9E%E8%A1%A8%E6%9F%A5%E8%AF%A2"><span class="toc-number">5.4.</span> <span class="toc-text">聚簇索引和非聚簇索引、回表查询</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%E3%80%81%E8%B6%85%E5%A4%A7%E5%88%86%E9%A1%B5%E4%BC%98%E5%8C%96"><span class="toc-number">5.5.</span> <span class="toc-text">覆盖索引、超大分页优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%88%9B%E5%BB%BA%E7%9A%84%E5%8E%9F%E5%88%99"><span class="toc-number">5.6.</span> <span class="toc-text">索引创建的原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88"><span class="toc-number">5.7.</span> <span class="toc-text">索引失效</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sql%E4%BC%98%E5%8C%96%E7%9A%84%E7%BB%8F%E9%AA%8C"><span class="toc-number">5.8.</span> <span class="toc-text">sql优化的经验</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring-Cloud"><span class="toc-number">6.</span> <span class="toc-text">Spring Cloud</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%BB%84%E4%BB%B6"><span class="toc-number">6.1.</span> <span class="toc-text">常见组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83"><span class="toc-number">6.2.</span> <span class="toc-text">注册中心</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-number">6.3.</span> <span class="toc-text">负载均衡</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E9%9B%AA%E5%B4%A9"><span class="toc-number">6.4.</span> <span class="toc-text">服务雪崩</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E7%9B%91%E6%8E%A7"><span class="toc-number">6.5.</span> <span class="toc-text">微服务的监控</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%99%90%E6%B5%81"><span class="toc-number">6.6.</span> <span class="toc-text">微服务限流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Nginx%E9%99%90%E6%B5%81"><span class="toc-number">6.6.1.</span> <span class="toc-text">Nginx限流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E5%85%B3%E9%99%90%E6%B5%81"><span class="toc-number">6.6.2.</span> <span class="toc-text">网关限流</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CAP%E5%92%8CBASE"><span class="toc-number">6.7.</span> <span class="toc-text">CAP和BASE</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">6.8.</span> <span class="toc-text">分布式事务解决方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89%E6%80%A7"><span class="toc-number">6.9.</span> <span class="toc-text">分布式服务的接口幂等性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6"><span class="toc-number">6.10.</span> <span class="toc-text">分布式任务调度</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RabbitMQ"><span class="toc-number">7.</span> <span class="toc-text">RabbitMQ</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E4%B8%8D%E4%B8%A2%E5%A4%B1"><span class="toc-number">7.1.</span> <span class="toc-text">如何保证消息不丢失</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RabbitMQ%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9%E9%97%AE%E9%A2%98"><span class="toc-number">7.2.</span> <span class="toc-text">RabbitMQ重复消费问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E4%BF%A1%E4%BA%A4%E6%8D%A2%E6%9C%BA%EF%BC%88%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97%EF%BC%89"><span class="toc-number">7.3.</span> <span class="toc-text">死信交换机（延迟队列）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E5%A0%86%E7%A7%AF"><span class="toc-number">7.4.</span> <span class="toc-text">消息堆积</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RabbitMQ%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9C%BA%E5%88%B6"><span class="toc-number">7.5.</span> <span class="toc-text">RabbitMQ高可用机制</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#kafka"><span class="toc-number">8.</span> <span class="toc-text">kafka</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Kafka%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E4%B8%8D%E4%B8%A2%E5%A4%B1"><span class="toc-number">8.1.</span> <span class="toc-text">Kafka是如何保证消息不丢失</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Kafka%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E8%B4%B9%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%80%A7"><span class="toc-number">8.2.</span> <span class="toc-text">Kafka如何保证消费的顺序性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Kafka%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9C%BA%E5%88%B6%E6%9C%89%E4%BA%86%E8%A7%A3%E8%BF%87%E5%90%97"><span class="toc-number">8.3.</span> <span class="toc-text">Kafka的高可用机制有了解过吗</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Kafka%E6%95%B0%E6%8D%AE%E6%B8%85%E7%90%86%E6%9C%BA%E5%88%B6%E4%BA%86%E8%A7%A3%E8%BF%87%E5%90%97"><span class="toc-number">8.4.</span> <span class="toc-text">Kafka数据清理机制了解过吗</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Kafka%E4%B8%AD%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%9C%89%E4%BA%86%E8%A7%A3%E8%BF%87%E5%90%97"><span class="toc-number">8.5.</span> <span class="toc-text">Kafka中实现高性能的设计有了解过吗</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">9.</span> <span class="toc-text">JVM相关面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">9.1.</span> <span class="toc-text">JVM是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM%E7%BB%84%E6%88%90"><span class="toc-number">9.2.</span> <span class="toc-text">JVM组成</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-number">9.2.1.</span> <span class="toc-text">什么是程序计数器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%A0%E8%83%BD%E7%BB%99%E6%88%91%E8%AF%A6%E7%BB%86%E7%9A%84%E4%BB%8B%E7%BB%8DJava%E5%A0%86%E5%90%97"><span class="toc-number">9.2.2.</span> <span class="toc-text">你能给我详细的介绍Java堆吗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88"><span class="toc-number">9.2.3.</span> <span class="toc-text">什么是虚拟机栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%83%BD%E4%B8%8D%E8%83%BD%E4%BB%8B%E7%BB%8D%E4%B8%8B%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="toc-number">9.2.4.</span> <span class="toc-text">能不能介绍下方法区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%A0%E5%90%AC%E8%AF%B4%E8%BF%87%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E5%90%97"><span class="toc-number">9.2.5.</span> <span class="toc-text">你听说过直接内存吗</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">9.3.</span> <span class="toc-text">类加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">9.3.1.</span> <span class="toc-text">什么是类加载器，类加载器有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%EF%BC%9F"><span class="toc-number">9.3.2.</span> <span class="toc-text">什么是双亲委派模型？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E4%B8%8B%E7%B1%BB%E8%A3%85%E8%BD%BD%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">9.3.3.</span> <span class="toc-text">说下类装载的执行过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">9.4.</span> <span class="toc-text">垃圾回收</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%8F%AF%E4%BB%A5%E8%A2%AB%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E5%9B%9E%E6%94%B6"><span class="toc-number">9.4.1.</span> <span class="toc-text">对象什么时候可以被垃圾回收器回收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="toc-number">9.4.2.</span> <span class="toc-text">JVM垃圾回收算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E4%B8%8BJVM%E4%B8%AD%E7%9A%84%E5%88%86%E4%BB%A3%E5%9B%9E%E6%94%B6"><span class="toc-number">9.4.3.</span> <span class="toc-text">说下JVM中的分代回收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8BJVM%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%9F"><span class="toc-number">9.4.4.</span> <span class="toc-text">说一下JVM中有哪些垃圾回收器？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E8%81%8A%E4%B8%80%E4%B8%8BG1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-number">9.4.5.</span> <span class="toc-text">详细聊一下G1垃圾回收器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%BA%E5%BC%95%E7%94%A8%E3%80%81%E8%BD%AF%E5%BC%95%E7%94%A8%E3%80%81%E5%BC%B1%E5%BC%95%E7%94%A8%E3%80%81%E8%99%9A%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">9.4.6.</span> <span class="toc-text">强引用、软引用、弱引用、虚引用的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM%E5%AE%9E%E8%B7%B5"><span class="toc-number">9.5.</span> <span class="toc-text">JVM实践</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM%E8%B0%83%E4%BC%98%E7%9A%84%E5%8F%82%E6%95%B0%E5%8F%AF%E4%BB%A5%E5%9C%A8%E5%93%AA%E9%87%8C%E8%AE%BE%E7%BD%AE%EF%BC%9F"><span class="toc-number">9.5.1.</span> <span class="toc-text">JVM调优的参数可以在哪里设置？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM%E8%B0%83%E4%BC%98%E7%9A%84%E5%8F%82%E6%95%B0%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">9.5.2.</span> <span class="toc-text">JVM调优的参数都有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8BJVM%E8%B0%83%E4%BC%98%E7%9A%84%E5%B7%A5%E5%85%B7%EF%BC%9F"><span class="toc-number">9.5.3.</span> <span class="toc-text">说一下JVM调优的工具？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E6%8E%92%E6%9F%A5%E6%80%9D%E8%B7%AF%EF%BC%9F"><span class="toc-number">9.5.4.</span> <span class="toc-text">Java内存泄漏的排查思路？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU%E9%A3%99%E9%AB%98%E6%8E%92%E6%9F%A5%E6%96%B9%E6%A1%88%E4%B8%8E%E6%80%9D%E8%B7%AF"><span class="toc-number">9.5.5.</span> <span class="toc-text">CPU飙高排查方案与思路</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AF%BE%E7%A8%8B"><span class="toc-number">10.</span> <span class="toc-text">多线程课程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">10.1.</span> <span class="toc-text">线程的基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">10.1.1.</span> <span class="toc-text">线程和进程的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E5%92%8C%E5%B9%B6%E5%8F%91%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">10.1.2.</span> <span class="toc-text">并行和并发有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">10.1.3.</span> <span class="toc-text">创建线程的方式有哪些？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Runnable%E5%92%8CCallable%E9%83%BD%E5%8F%AF%E4%BB%A5%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%EF%BC%8C%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">10.1.3.1.</span> <span class="toc-text">Runnable和Callable都可以创建线程，区别是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E7%BA%BF%E7%A8%8B%E6%97%B6%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8run%E6%96%B9%E6%B3%95%EF%BC%8Crun%E5%92%8Cstart%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">10.1.3.2.</span> <span class="toc-text">启动线程时可以使用run方法，run和start方法有什么区别？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%8C%85%E5%90%AB%E5%93%AA%E4%BA%9B%E7%8A%B6%E6%80%81%EF%BC%8C%E7%8A%B6%E6%80%81%E4%B9%8B%E9%97%B4%E6%98%AF%E5%A6%82%E4%BD%95%E5%8F%98%E5%8C%96%E7%9A%84%EF%BC%9F"><span class="toc-number">10.1.4.</span> <span class="toc-text">线程包含哪些状态，状态之间是如何变化的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E5%BB%BAT1%E3%80%81T2%E3%80%81T3%E4%B8%89%E4%B8%AA%E7%BA%BF%E7%A8%8B%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%AE%83%E4%BB%AC%E6%8C%89%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C%EF%BC%9F"><span class="toc-number">10.1.5.</span> <span class="toc-text">新建T1、T2、T3三个线程，如何保证它们按顺序执行？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#notify-%E5%92%8CnotifyAll-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">10.1.5.1.</span> <span class="toc-text">notify()和notifyAll()有什么区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java%E4%B8%ADwait%E5%92%8Csleep%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">10.1.6.</span> <span class="toc-text">java中wait和sleep方法有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%81%9C%E6%AD%A2%E4%B8%80%E4%B8%AA%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84%E7%BA%BF%E7%A8%8B"><span class="toc-number">10.1.7.</span> <span class="toc-text">如何停止一个正在运行的线程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%AD%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8"><span class="toc-number">10.2.</span> <span class="toc-text">线程中并发安全</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-number">10.2.1.</span> <span class="toc-text">synchronized关键字的底层原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86-%E8%BF%9B%E9%98%B6"><span class="toc-number">10.2.2.</span> <span class="toc-text">synchronized关键字的底层原理-进阶</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%88%E8%B0%88JMM%EF%BC%88Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%89"><span class="toc-number">10.2.3.</span> <span class="toc-text">谈谈JMM（Java内存模型）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS%E4%BD%A0%E7%9F%A5%E9%81%93%E5%90%97%EF%BC%9F"><span class="toc-number">10.2.4.</span> <span class="toc-text">CAS你知道吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">10.2.4.1.</span> <span class="toc-text">乐观锁和悲观锁的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9volatile%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">10.2.5.</span> <span class="toc-text">请谈谈你对volatile的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFAQS"><span class="toc-number">10.2.6.</span> <span class="toc-text">什么是AQS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReentrantLock%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">10.2.7.</span> <span class="toc-text">ReentrantLock的实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized%E5%92%8CLock%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">10.2.8.</span> <span class="toc-text">synchronized和Lock有什么区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E6%9D%A1%E4%BB%B6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">10.2.9.</span> <span class="toc-text">死锁产生的条件是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%8A%E4%B8%80%E4%B8%8BConcurrentHashMap"><span class="toc-number">10.2.10.</span> <span class="toc-text">聊一下ConcurrentHashMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E8%87%B4%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E5%87%BA%E7%8E%B0%E9%97%AE%E9%A2%98%E7%9A%84%E6%A0%B9%E6%9C%AC%E5%8E%9F%E5%9B%A0%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%EF%BC%88%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%89%A7%E8%A1%8C%E5%AE%89%E5%85%A8%EF%BC%89"><span class="toc-number">10.2.11.</span> <span class="toc-text">导致并发程序出现问题的根本原因是什么？（如何保证多线程的执行安全）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">10.3.</span> <span class="toc-text">线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8F%82%E6%95%B0%EF%BC%88%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86%EF%BC%89"><span class="toc-number">10.3.1.</span> <span class="toc-text">说一下线程池的核心参数（线程池的执行原理）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%EF%BC%9F"><span class="toc-number">10.3.2.</span> <span class="toc-text">线程中有哪些常见的阻塞队列？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E6%A0%B8%E5%BF%83%E7%BA%BF%E7%A8%8B%E6%95%B0%EF%BC%9F"><span class="toc-number">10.3.3.</span> <span class="toc-text">如何确定核心线程数？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E7%A7%8D%E7%B1%BB%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">10.3.4.</span> <span class="toc-text">线程池的种类有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%BB%BA%E8%AE%AE%E7%94%A8Executors%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9F"><span class="toc-number">10.3.5.</span> <span class="toc-text">为什么不建议用Executors创建线程池？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-1"><span class="toc-number">10.4.</span> <span class="toc-text">使用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%88CountDownLatch%E3%80%81Future%EF%BC%89"><span class="toc-number">10.4.1.</span> <span class="toc-text">线程池使用场景（CountDownLatch、Future）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%8E%A7%E5%88%B6%E6%9F%90%E4%B8%AA%E6%96%B9%E6%B3%95%E5%85%81%E8%AE%B8%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%95%B0%E9%87%8F"><span class="toc-number">10.4.2.</span> <span class="toc-text">如何控制某个方法允许并发访问线程的数量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9ThreadLocal%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">10.4.3.</span> <span class="toc-text">谈谈你对ThreadLocal的理解</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">11.</span> <span class="toc-text">设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">11.1.</span> <span class="toc-text">工厂设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82"><span class="toc-number">11.1.1.</span> <span class="toc-text">简单工厂</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F"><span class="toc-number">11.1.2.</span> <span class="toc-text">工厂方法模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F"><span class="toc-number">11.1.3.</span> <span class="toc-text">抽象工厂方法模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F"><span class="toc-number">11.2.</span> <span class="toc-text">策略模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%99%BB%E9%99%86%E6%A1%88%E4%BE%8B%EF%BC%88%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%EF%BC%89"><span class="toc-number">11.3.</span> <span class="toc-text">登陆案例（工厂模式+策略模式）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%A3%E4%BB%BB%E9%93%BE%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">11.4.</span> <span class="toc-text">责任链设计模式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8A%80%E6%9C%AF%E5%9C%BA%E6%99%AF"><span class="toc-number">12.</span> <span class="toc-text">技术场景</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E7%82%B9%E7%99%BB%E9%99%86%E8%BF%99%E5%9D%97%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-number">12.1.</span> <span class="toc-text">单点登陆这块是怎么实现的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%83%E9%99%90%E8%AE%A4%E8%AF%81%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-number">12.2.</span> <span class="toc-text">权限认证是如何实现的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8A%E4%BC%A0%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%E4%BD%A0%E4%BB%AC%E6%80%8E%E4%B9%88%E6%8E%A7%E5%88%B6%EF%BC%9F"><span class="toc-number">12.3.</span> <span class="toc-text">上传数据的安全性你们怎么控制？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%A0%E8%B4%9F%E8%B4%A3%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%97%B6%E5%80%99%E9%81%87%E5%88%B0%E4%BA%86%E5%93%AA%E4%BA%9B%E6%AF%94%E8%BE%83%E6%A3%98%E6%89%8B%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9F%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E7%9A%84"><span class="toc-number">12.4.</span> <span class="toc-text">你负责项目的时候遇到了哪些比较棘手的问题？怎么解决的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%A0%E4%BB%AC%E9%A1%B9%E7%9B%AE%E4%B8%AD%E6%97%A5%E5%BF%97%E6%80%8E%E4%B9%88%E9%87%87%E9%9B%86%E7%9A%84%EF%BC%9F"><span class="toc-number">12.5.</span> <span class="toc-text">你们项目中日志怎么采集的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E6%97%A5%E5%BF%97%E7%9A%84%E5%91%BD%E4%BB%A4"><span class="toc-number">12.6.</span> <span class="toc-text">常见日志的命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E9%97%AE%E9%A2%98%E6%80%8E%E4%B9%88%E6%8E%92%E6%9F%A5%EF%BC%9F"><span class="toc-number">12.7.</span> <span class="toc-text">生产问题怎么排查？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E5%BF%AB%E9%80%9F%E5%AE%9A%E4%BD%8D%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%93%B6%E9%A2%88%EF%BC%9F"><span class="toc-number">12.8.</span> <span class="toc-text">怎么快速定位系统的瓶颈？</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/15/Docker%E5%B0%8F%E5%93%88/" title="Docker小哈">Docker小哈</a><time datetime="2025-06-15T01:41:46.000Z" title="Created 2025-06-15 09:41:46">2025-06-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/15/CompletableFuture%E5%AD%A6%E4%B9%A0/" title="CompletableFuture学习">CompletableFuture学习</a><time datetime="2025-05-15T08:46:27.000Z" title="Created 2025-05-15 16:46:27">2025-05-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/02/SpringSecurity/" title="SpringSecurity">SpringSecurity</a><time datetime="2025-05-02T01:12:10.000Z" title="Created 2025-05-02 09:12:10">2025-05-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/28/JWT/" title="JWT">JWT</a><time datetime="2025-04-28T14:43:02.000Z" title="Created 2025-04-28 22:43:02">2025-04-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/18/Java-NIO-Netty/" title="Java NIO Netty">Java NIO Netty</a><time datetime="2025-04-18T03:43:38.000Z" title="Created 2025-04-18 11:43:38">2025-04-18</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By HERAO</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.2.0</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>