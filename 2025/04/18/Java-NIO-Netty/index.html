<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java NIO Netty | Hexo</title><meta name="author" content="John Doe"><meta name="copyright" content="John Doe"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="NIO基础缓冲区Buffer类及其实现Buffer类是缓冲区的实现，类似于Java中的数组，也是用来存放和获取数据的。但是Buffer相比于Java中的数组，功能就非常强大了，它包含一系列对于数组的快捷操作 Buffer是一个抽象类，它的核心内容： 12345678910public abstract class Buffer &#123;    &#x2F;&#x2F;这四个变量的关系：mark &lt;&#x3D; pos">
<meta property="og:type" content="article">
<meta property="og:title" content="Java NIO Netty">
<meta property="og:url" content="http://example.com/2025/04/18/Java-NIO-Netty/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="NIO基础缓冲区Buffer类及其实现Buffer类是缓冲区的实现，类似于Java中的数组，也是用来存放和获取数据的。但是Buffer相比于Java中的数组，功能就非常强大了，它包含一系列对于数组的快捷操作 Buffer是一个抽象类，它的核心内容： 12345678910public abstract class Buffer &#123;    &#x2F;&#x2F;这四个变量的关系：mark &lt;&#x3D; pos">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2025-04-18T03:43:38.000Z">
<meta property="article:modified_time" content="2025-04-20T04:27:15.958Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2025/04/18/Java-NIO-Netty/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Error',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java NIO Netty',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-04-20 12:27:15'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><hr class="custom-hr"/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Hexo"><span class="site-name">Hexo</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java NIO Netty</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2025-04-18T03:43:38.000Z" title="Created 2025-04-18 11:43:38">2025-04-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-04-20T04:27:15.958Z" title="Updated 2025-04-20 12:27:15">2025-04-20</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java NIO Netty"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="NIO基础"><a href="#NIO基础" class="headerlink" title="NIO基础"></a>NIO基础</h1><h2 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h2><h3 id="Buffer类及其实现"><a href="#Buffer类及其实现" class="headerlink" title="Buffer类及其实现"></a>Buffer类及其实现</h3><p>Buffer类是缓冲区的实现，类似于Java中的数组，也是用来存放和获取数据的。但是Buffer相比于Java中的数组，功能就非常强大了，它包含一系列对于数组的快捷操作</p>
<p>Buffer是一个抽象类，它的核心内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Buffer</span> &#123;</span><br><span class="line">    <span class="comment">//这四个变量的关系：mark &lt;= position &lt;= limit &lt;= capacity</span></span><br><span class="line">    <span class="comment">//这些变量就是Buffer操作的核心</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">mark</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">position</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> limit;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//直接缓冲区实现子类的数据内存地址</span></span><br><span class="line">    <span class="type">long</span> address;</span><br></pre></td></tr></table></figure>

<p>来看下Buffer类的子类，包括我们认识的所有基本类型（除了boolean类型之外）：</p>
<ul>
<li>IntBuffer - int类型的缓冲区</li>
<li>ShortBuffer - short类型的缓冲区</li>
<li>LongBuffer - long类型的缓冲区</li>
<li>FloatBuffer - float类型的缓冲区</li>
<li>DoubleBuffer - doubtl类型的缓冲区</li>
<li>ByteBuffer - byte类型的缓冲区</li>
<li>CharBuffer - char类型的缓冲区</li>
</ul>
<p>以IntBuffer为例，如何创建一个Buffer类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个缓冲区不能直接new，而是需要使用静态方法去生成，有两种方式：</span></span><br><span class="line">    <span class="comment">// 1.申请一个容量为10的int缓冲区</span></span><br><span class="line">    <span class="type">IntBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> IntBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">// 2.可以将现有的数组直接转换为缓冲区（包括数组中的数据）</span></span><br><span class="line">    <span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    <span class="type">IntBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> IntBuffer.wrap(arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本质上如何进行操作的，看看它的源码（allocate方法）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> IntBuffer <span class="title function_">allocate</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">    <span class="comment">//申请容量小于0，直接抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (capacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> IllegalArgumentException();</span><br><span class="line">    <span class="comment">//创建一个IntBuffer实现类</span></span><br><span class="line">    <span class="comment">//HeapIntBuffer实在堆内存中存放数据，本质就是一个数组</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HeapIntBuffer</span>(capacity, capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>wrap方法源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> IntBuffer <span class="title function_">wrap</span><span class="params">(<span class="type">int</span>[] array,</span></span><br><span class="line"><span class="params">                             <span class="type">int</span> offset, <span class="type">int</span> length)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//也是创建一个新的HeapIntBuffer对象，并且给了初始数组以及截取的起始位置和长度</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HeapIntBuffer</span>(array, offset, length);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException x) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> IntBuffer <span class="title function_">wrap</span><span class="params">(<span class="type">int</span>[] array)</span> &#123;</span><br><span class="line">    <span class="comment">//调用的是上面的wrap方法</span></span><br><span class="line">    <span class="keyword">return</span> wrap(array, <span class="number">0</span>, array.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么HeapIntBuffer又是如何实现的，继续往下看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HeapIntBuffer(<span class="type">int</span>[] buf, <span class="type">int</span> off, <span class="type">int</span> len) &#123;<span class="comment">//注意这个构造方法不是public，是默认的访问权限</span></span><br><span class="line">    <span class="built_in">super</span>(-<span class="number">1</span>, off, off + len, buf.length, buf, <span class="number">0</span>);<span class="comment">//调用父类的构造方法</span></span><br><span class="line">    <span class="comment">//mark是标记，off是当前起始下标位置，off+len是最大下标位置，buf.length是底层维护的数组的真正长度，buf就是数组，最后一个0是起始偏移位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看看IntBuffer中的构造方法是如何定义的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span>[] hb;<span class="comment">//只有在堆缓冲区实现时才会使用</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> offset;</span><br><span class="line"><span class="type">boolean</span> isReadOnly;<span class="comment">//只有在堆缓冲区实现时才会使用</span></span><br><span class="line"></span><br><span class="line">IntBuffer(<span class="type">int</span> mark, <span class="type">int</span> pos, <span class="type">int</span> lim, <span class="type">int</span> cap,</span><br><span class="line">          <span class="type">int</span>[] hb, <span class="type">int</span> offset)<span class="comment">//这个构造方法不是public，是默认访问的</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">super</span>(mark, pos, lim, cap);<span class="comment">//调用Buffer类的构造方法</span></span><br><span class="line">    <span class="built_in">this</span>.hb = hb;<span class="comment">//hb就是真正我们存放数据的地方，堆缓冲区底层起始就是这么一个数组</span></span><br><span class="line">    <span class="built_in">this</span>.offset = offset;<span class="comment">//起始偏移位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后看看Buffer中的构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Buffer(<span class="type">int</span> mark, <span class="type">int</span> pos, <span class="type">int</span> lim, <span class="type">int</span> cap) &#123;</span><br><span class="line">    <span class="comment">//容量不能小于0</span></span><br><span class="line">    <span class="keyword">if</span> (cap &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Negative capacity: &quot;</span> + cap);</span><br><span class="line">    <span class="built_in">this</span>.capacity = cap;<span class="comment">//设定缓冲区容量</span></span><br><span class="line">    limit(lim);<span class="comment">//设定最大position位置</span></span><br><span class="line">    position(pos);<span class="comment">//设定起始位置</span></span><br><span class="line">    <span class="keyword">if</span> (mark &gt;= <span class="number">0</span>) &#123;<span class="comment">//如果起始标记大于等于0</span></span><br><span class="line">        <span class="keyword">if</span> (mark &gt; pos)<span class="comment">//并且记录位置大于起始位置，那么就抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;mark &gt; position: (&quot;</span></span><br><span class="line">                                               + mark + <span class="string">&quot; &gt; &quot;</span> + pos + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.mark = mark;<span class="comment">//否则设定mark位置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过观察源码，我们大致可以得到以下结构：</p>
<p><img src="/../images/Java-NIO-Netty/1.png" alt="结构"></p>
<p>总结各职责划分：</p>
<ul>
<li>Buffer：缓冲区的一些基本变量定义，比如当前位置（position）、容量（capacity）、最大限制（limit）、标记（mark）等</li>
<li>intBuffer等子类：定义了存放数据的数组（只有堆缓冲区实现子类才会用到）、是否只读等，也就是说数据的存放位置、以及对于底层数组的相关操作都在这里定义好了，并且已经实现了Comparable接口</li>
<li>HeapIntBuffer堆缓冲区实现子类：数据存放在堆中，实际上就是用的父类的数组在保存数据，并且将父类定义的所有底层操作全部实现了</li>
</ul>
<h3 id="缓冲区写操作"><a href="#缓冲区写操作" class="headerlink" title="缓冲区写操作"></a>缓冲区写操作</h3><p>前面我们了解了Buffer类的基本操作，现在我们来看下如何向缓冲区中存放数据以及获取数据，数据的存放包括以下四个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> IntBuffer <span class="title function_">put</span><span class="params">(<span class="type">int</span> i)</span>;<span class="comment">//在当前position位置插入数据，由具体子类实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> IntBuffer <span class="title function_">put</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> i)</span>;<span class="comment">//在指定位置存放数据，也是由具体子类实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> IntBuffer <span class="title function_">put</span><span class="params">(<span class="type">int</span>[] src)</span>;<span class="comment">//直接存放所有数组中的内容（数组长度不能超出缓冲区大小）</span></span><br><span class="line"><span class="keyword">public</span> IntBuffer <span class="title function_">put</span><span class="params">(<span class="type">int</span>[] src, <span class="type">int</span> offset, <span class="type">int</span> length)</span>;<span class="comment">//直接存放数组中的内容，同上，但是可以指定存放一段范围</span></span><br><span class="line"><span class="keyword">public</span> IntBuffer <span class="title function_">put</span><span class="params">(IntBuffer src)</span>;<span class="comment">//直接存放另一个缓冲区的内容</span></span><br></pre></td></tr></table></figure>

<p>从最简单的开始看，是在当前位置插入一个数据，那么这个当前位置是怎么定义的呢，我们看下源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> IntBuffer <span class="title function_">put</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    hb[ix(nextPutIndex())] = x;   <span class="comment">//这个ix和nextPutIndex()很灵性，我们来看看具体实现</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">ix</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> i + offset;   <span class="comment">//将i的值加上我们之前设定的offset偏移量值，但是默认是0（非0的情况后面会介绍）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">nextPutIndex</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> position;    <span class="comment">//获取Buffer类中的position位置（一开始也是0）</span></span><br><span class="line">    <span class="keyword">if</span> (p &gt;= limit)    <span class="comment">//位置肯定不能超过底层数组最大长度，否则越界</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BufferOverflowException</span>();</span><br><span class="line">    position = p + <span class="number">1</span>;   <span class="comment">//获取之后会使得Buffer类中的position+1</span></span><br><span class="line">    <span class="keyword">return</span> p;   <span class="comment">//返回当前的位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以put操作实际上是将底层数据<code>hb</code>在position位置上的数据进行设定：</p>
<p><img src="/../images/Java-NIO-Netty/14.png" alt="结构"></p>
<p>设定完成后，position自动后移：</p>
<p><img src="/../images/Java-NIO-Netty/15.png" alt="结构"></p>
<p>我们可以通过编码来看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">IntBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> IntBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">    buffer.put(<span class="number">111</span>);</span><br><span class="line">    buffer.put(<span class="number">222</span>);</span><br><span class="line">    buffer.put(<span class="number">333</span>);</span><br><span class="line">    System.out.println(Arrays.toString(buffer.array()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过调试断点，我们来看看实际情况：</p>
<p><img src="/../images/Java-NIO-Netty/16.png" alt="调试"></p>
<p>可以看到我们不断地put操作，position会一直向后移动，当然如果超出最大长度，那么会直接抛出异常：</p>
<p><img src="/../images/Java-NIO-Netty/17.png" alt="异常"></p>
<p>接着来看第二个put操作是如何进行，它能够在指定位置插入数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> IntBuffer <span class="title function_">put</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    hb[ix(checkIndex(i))] = x;  <span class="comment">//这里依然会使用ix，但是会检查位置是否合法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">checkIndex</span><span class="params">(<span class="type">int</span> i)</span> &#123;                       <span class="comment">// package-private</span></span><br><span class="line">    <span class="keyword">if</span> ((i &lt; <span class="number">0</span>) || (i &gt;= limit))    <span class="comment">//插入的位置不能小于0并且不能大于等于底层数组最大长度</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>();</span><br><span class="line">    <span class="keyword">return</span> i;   <span class="comment">//没有问题就把i返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上这个比之前的要好理解一些，注意全程不会操作position的值，这里需要注意一下</p>
<p>接着来看第三个和第四个操作，它是直接在IntBuffer中实现的，是基于前面两个put方法的子类实现来完成的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> IntBuffer <span class="title function_">put</span><span class="params">(<span class="type">int</span>[] src, <span class="type">int</span> offset, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">    checkBounds(offset, length, src.length);   <span class="comment">//检查截取范围是否合法，给offset、调用者指定长度、数组实际长度</span></span><br><span class="line">    <span class="keyword">if</span> (length &gt; remaining())   <span class="comment">//接着判断要插入的数据量在缓冲区是否容得下，装不下也不行</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BufferOverflowException</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> offset + length;   <span class="comment">//计算出最终读取位置，下面开始for</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> offset; i &lt; end; i++)</span><br><span class="line">        <span class="built_in">this</span>.put(src[i]);   <span class="comment">//注意是直接从postion位置开始插入，直到指定范围结束</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;   <span class="comment">//ojbk</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> IntBuffer <span class="title function_">put</span><span class="params">(<span class="type">int</span>[] src)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> put(src, <span class="number">0</span>, src.length);   <span class="comment">//因为不需要指定范围，所以直接0和length，然后调上面的，多捞哦</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">remaining</span><span class="params">()</span> &#123;  <span class="comment">//计算并获取当前缓冲区的剩余空间</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">rem</span> <span class="operator">=</span> limit - position;   <span class="comment">//最大容量减去当前位置，就是剩余空间</span></span><br><span class="line">    <span class="keyword">return</span> rem &gt; <span class="number">0</span> ? rem : <span class="number">0</span>;  <span class="comment">//没容量就返回0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">checkBounds</span><span class="params">(<span class="type">int</span> off, <span class="type">int</span> len, <span class="type">int</span> size)</span> &#123; <span class="comment">// package-private</span></span><br><span class="line">    <span class="keyword">if</span> ((off | len | (off + len) | (size - (off + len))) &lt; <span class="number">0</span>)  <span class="comment">//让我猜猜，看不懂了是吧</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>();</span><br><span class="line">    <span class="comment">//实际上就是看给定的数组能不能截取出指定的这段数据，如果都不够了那肯定不行啊</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大致流程如下，首先来了一个数组要取一段数据全部丢入缓冲区：</p>
<p><img src="/../images/Java-NIO-Netty/18.png" alt="数组"></p>
<p>在检查没有什么问题并且缓冲区有容量时，就可以进行插入：</p>
<p><img src="/../images/Java-NIO-Netty/19.png" alt="插入"></p>
<p>我们可以通过代码来看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">111</span>, <span class="number">222</span>, <span class="number">333</span>, <span class="number">444</span>, <span class="number">555</span>, <span class="number">666</span>&#125;;</span><br><span class="line">    <span class="type">IntBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> IntBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">    buffer.put(arr, <span class="number">2</span>, <span class="number">3</span>);<span class="comment">//从下标2开始，截取三个元素</span></span><br><span class="line">    System.out.println(Arrays.toString(buffer.array()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后的输出结果：</p>
<p><img src="/../images/Java-NIO-Netty/20.png" alt="结果"></p>
<p>第五种方法，我们也可以直接将一个缓冲区的内容存放到另一个缓冲区：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> IntBuffer <span class="title function_">put</span><span class="params">(IntBuffer src)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (src == <span class="built_in">this</span>)   <span class="comment">//不会吧不会吧，不会有人保存自己吧</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="keyword">if</span> (isReadOnly())   <span class="comment">//如果是只读的话，那么也是不允许插入操作的（我猜你们肯定会问为啥就这里会判断只读，前面四个呢）</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ReadOnlyBufferException</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> src.remaining();  <span class="comment">//给进来的src看看容量（注意这里不remaining的结果不是剩余容量，是转换后的，之后会说）</span></span><br><span class="line">    <span class="keyword">if</span> (n &gt; remaining())    <span class="comment">//这里判断当前剩余容量是否小于src容量</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BufferOverflowException</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)   <span class="comment">//也是从position位置开始继续写入</span></span><br><span class="line">        put(src.get());   <span class="comment">//通过get方法一个一个读取数据出来，具体过程后面讲解</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过编码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">IntBuffer</span> <span class="variable">src</span> <span class="operator">=</span> IntBuffer.wrap(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;);</span><br><span class="line">    <span class="type">IntBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> IntBuffer.allocate(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    buffer.put(src);</span><br><span class="line">    System.out.println(Arrays.toString(buffer.array()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是如果这样的话，就会出现问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">IntBuffer</span> <span class="variable">src</span> <span class="operator">=</span> IntBuffer.allocate(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) src.put(i);   <span class="comment">//手动插入数据</span></span><br><span class="line">    <span class="type">IntBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> IntBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">    buffer.put(src);</span><br><span class="line">    System.out.println(Arrays.toString(buffer.array()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<p><img src="/../images/Java-NIO-Netty/21.png" alt="插入"></p>
<p>我们发现，结果和上面的不一样，并没有成功的将数据填到下面的IntBuffer中，这是为什么呢？实际上就是因为<code>remaining()</code>的计算问题，因为这个方法是直接计算position的位置，但是由于我们在写操作完成之后，position跑到后面去了，也就导致了<code>remaining()</code>结果最后算出来为0</p>
<p>因为这里不是写操作，是接下来需要从头开始进行读操作，所以我们得想个办法吧positiion给退回一开始的位置，这样才可以从头开始读取，那么怎么做到呢？一般我们在写入完成后需要进行读操作时（后面都是这样，不只是这里），会使用<code>flip()</code>方法进行翻转：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title function_">flip</span><span class="params">()</span> &#123;</span><br><span class="line">    limit = position;    <span class="comment">//修改limit值，当前写到哪里，下次读的最终位置就是这里，limit的作用开始慢慢体现了</span></span><br><span class="line">    position = <span class="number">0</span>;    <span class="comment">//position归零</span></span><br><span class="line">    mark = -<span class="number">1</span>;    <span class="comment">//标记还原为-1，但是现在我们还没用到</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，再次计算<code>remaining()</code>的结果就是我们需要读取的数量了，这也是为什么put方法中要用<code>remaining()</code>来计算的原因，继续测试下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">IntBuffer</span> <span class="variable">src</span> <span class="operator">=</span> IntBuffer.allocate(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) src.put(i);   <span class="comment">// 手动插入数据</span></span><br><span class="line">    <span class="type">IntBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> IntBuffer.allocate(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    src.flip();<span class="comment">//通过flip来翻转缓冲区</span></span><br><span class="line">    buffer.put(src);</span><br><span class="line">    System.out.println(Arrays.toString(buffer.array()));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>翻转之后再次进行转移，就正常了</p>
<h1 id="Netty框架"><a href="#Netty框架" class="headerlink" title="Netty框架"></a>Netty框架</h1><h2 id="NIO框架存在的问题"><a href="#NIO框架存在的问题" class="headerlink" title="NIO框架存在的问题"></a>NIO框架存在的问题</h2><p>我们之前在使用NIO框架的时候，发现了一些问题</p>
<h3 id="客户端关闭导致服务器空轮询"><a href="#客户端关闭导致服务器空轮询" class="headerlink" title="客户端关闭导致服务器空轮询"></a>客户端关闭导致服务器空轮询</h3><p><img src="/../images/Java-NIO-Netty/2.png" alt="出现错误"></p>
<p>当我们的客户端主动与服务端断开连接时，会导致READ事件一直触发，也就是说<code>selector.select()</code>会直接通过，并且是可读状态，但是我们发现实际上读到的数据是一个空的（上面的图中在空轮询两次后抛出异常，也有可能是无限循环下去）所以这里我们得稍微处理一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">    <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">    <span class="comment">//这里我们需要判断一下，如果read操作得到的结果是-1，那么说明服务端已经断开连接了</span></span><br><span class="line">    <span class="keyword">if</span> (channel.read(buffer) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端已经断开连接了：&quot;</span> + channel.getRemoteAddress());</span><br><span class="line">        channel.close();</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    buffer.flip();</span><br><span class="line">    System.out.println(<span class="string">&quot;接收到客户端数据：&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(buffer.array(), <span class="number">0</span>, buffer.remaining()));</span><br><span class="line">    channel.write(ByteBuffer.wrap(<span class="string">&quot;已收到！&quot;</span>.getBytes()));</span><br></pre></td></tr></table></figure>

<p>这样之后，我们就可以在客户端主动断开时关闭连接了</p>
<p>除了这种情况之外，实际上还有一种可能，这种情况是NIO框架本身的BUG：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> selector.select();  <span class="comment">//由于底层epoll机制的问题，导致select方法可能会一直返回0，造成无限循环的情况。</span></span><br><span class="line">    System.out.println(<span class="string">&quot;监听到 &quot;</span>+count+<span class="string">&quot; 个事件&quot;</span>);</span><br><span class="line">    Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">    Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br></pre></td></tr></table></figure>

<p>本质原因也是因为客户端的主动断开导致</p>
<p>这个问题本质是与操作系统有关的，所以JDK一直都认为是操作系统的问题，不应该由自己来处理，所以这个问题在当时的好几个JDK版本都是存在的，这是一个很严重的空转问题，无限制地进行空转操作会导致CPU资源被疯狂消耗</p>
<p>不过，这个问题被Netty框架巧妙解决了</p>
<h3 id="粘包-拆包问题"><a href="#粘包-拆包问题" class="headerlink" title="粘包&#x2F;拆包问题"></a><strong>粘包&#x2F;拆包问题</strong></h3><p>除了上面的问题，我们接着来看下一个问题</p>
<p>我们在<code>计算机网络</code>这门课程中学过，操作系统是由<code>TCP</code>协议发送数据的时候，也会将数据存放在缓冲区中，而至于什么时候真正地发送出这些数据，是由TCP协议来决定的，这是我们无法控制的事情</p>
<p><img src="/../images/Java-NIO-Netty/3.png" alt="发送包"></p>
<p>也就是说，比如现在我们要发送两个数据包（P1&#x2F;P2），理想情况下，这两个数据包时依次到达服务端，并由服务端正确读取两次数据来，但是由于上面的机制，可能会出现下面的情况：</p>
<ol>
<li>可能P1和P2被合在一起发送给了服务端（粘包现象）</li>
<li>可能P1和P2的前半部分粘合在一起发送给了服务端（拆包现象）</li>
<li>可能P1的前半部分就被单独作为一个部分发送给了服务端，后面的和P2一起发送给了服务端（也是拆包现象）</li>
</ol>
<p><img src="/../images/Java-NIO-Netty/4.png" alt="粘包/拆包现象"></p>
<p>对于这种问题，也有一些比较常见的解决方案：</p>
<ol>
<li>消息定长，发送放和接收方固定固定大小的消息长度，例如每个数据包大小固定为200个字节，如果不够，空位补空格，只有接受了200个字节后，作为一个完整的数据包进行处理</li>
<li>在每个包的末尾使用固定的分隔符，比如每个数据包末尾都是<code>/r/n</code>，这样就一定需要读取到这样的消息分隔符才能将前面所有的数据作为一个完成的数据包进行处理</li>
<li>将消息分为头部和本体，在头部中保存有当前整个数据包的长度，只有在读到足够长之后才算是读到了一个完成的数据包</li>
</ol>
<p>演示第一种解决方案：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">ServerSocketChannel</span> <span class="variable">serverChannel</span> <span class="operator">=</span> ServerSocketChannel.open(); <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open()) &#123;   <span class="comment">// 开启一个新的Selector，这玩意也是要关闭释放资源的</span></span><br><span class="line">    serverChannel.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line">    <span class="comment">// 要使用选择器进行操作，必须使用非阻塞的方式，这样才不会像阻塞IO那样卡在accept()，而是直接通过，让选择器去进行下一步操作</span></span><br><span class="line">    serverChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 将选择器注册到ServerSocketChannel中，后面是选择需要监听的时间，只有发生对应事件时才会进行选择，多个事件用 | 连接，注意，并不是所有的Channel都支持以下全部四个事件，可能只支持部分</span></span><br><span class="line">    <span class="comment">// 因为是ServerSocketChannel这里我们就监听accept就可以了，等待客户端连接</span></span><br><span class="line">    <span class="comment">// SelectionKey.OP_CONNECT --- 连接就绪事件，表示客户端与服务器的连接已经建立成功</span></span><br><span class="line">    <span class="comment">// SelectionKey.OP_ACCEPT --- 接收连接事件，表示服务器监听到了客户连接，服务器可以接收这个连接了</span></span><br><span class="line">    <span class="comment">// SelectionKey.OP_READ --- 读 就绪事件，表示通道中已经有了可读的数据，可以执行读操作了</span></span><br><span class="line">    <span class="comment">// SelectionKey.OP_WRITE --- 写 就绪事件，表示已经可以向通道写数据了（这玩意比较特殊，一般情况下因为都是可以写入的，所以可能会无限循环）</span></span><br><span class="line">    serverChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个数据包要求必须塞满30个字节</span></span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;   <span class="comment">// 无限循环等待新的用户网络操作</span></span><br><span class="line">        <span class="comment">// 每次选择都可能会选出多个已经就绪的网络操作，没有操作时会暂时阻塞</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> selector.select();</span><br><span class="line">        System.out.println(<span class="string">&quot;监听到 &quot;</span> + count + <span class="string">&quot; 个事件&quot;</span>);</span><br><span class="line">        Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">        Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">            <span class="comment">// 根据不同的事件类型，执行不同的操作即可</span></span><br><span class="line">            <span class="keyword">if</span> (key.isAcceptable()) &#123;  <span class="comment">// 如果当前ServerSocketChannel已经做好准备处理Accept</span></span><br><span class="line">                <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> serverChannel.accept();</span><br><span class="line">                System.out.println(<span class="string">&quot;客户端已连接，IP地址为：&quot;</span> + channel.getRemoteAddress());</span><br><span class="line">                <span class="comment">// 现在连接就建立好了，接着我们需要将连接也注册选择器，比如我们需要当这个连接有内容可读时就进行处理</span></span><br><span class="line">                channel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                channel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                <span class="comment">// 这样就在连接建立时完成了注册</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;    <span class="comment">// 如果当前连接有可读的数据并且可以写，那么就开始处理</span></span><br><span class="line">                <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                <span class="keyword">if</span> (channel.read(buffer) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;客户端已经断开连接了：&quot;</span> + channel.getRemoteAddress());</span><br><span class="line">                    channel.close();   <span class="comment">// 直接关闭此通道</span></span><br><span class="line">                    <span class="keyword">continue</span>;   <span class="comment">// 继续进行选择</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (buffer.remaining() == <span class="number">0</span>) &#123;</span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    System.out.println(<span class="string">&quot;接收到客户端数据：&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(buffer.array(), <span class="number">0</span>, buffer.remaining()));</span><br><span class="line">                    buffer.clear();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 直接向通道中写入数据就行</span></span><br><span class="line">                channel.write(ByteBuffer.wrap(<span class="string">&quot;已收到！&quot;</span>.getBytes()));</span><br><span class="line">                <span class="comment">// 别关，说不定用户还要继续通信呢</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 处理完成后，一定记得移出迭代器，不然下次还有</span></span><br><span class="line">            iterator.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，当我们的客户端发送消息时，如果没有达到30个字节，那么会暂时存储起来，等有30个字节后再一次性得到，当然如果数据量超过了30字节，那么最多也会读到30个字节，其他的放在下一批：</p>
<p><img src="/../images/Java-NIO-Netty/5.png" alt="发送"></p>
<p><img src="/../images/Java-NIO-Netty/6.png" alt="接受"></p>
<p>这样就可以在一定程度上解决了粘包&#x2F;拆包问题了</p>
<h2 id="走进Netty框架"><a href="#走进Netty框架" class="headerlink" title="走进Netty框架"></a>走进Netty框架</h2><p>前面我们盘点了一下NIO存在的一些问题，而在Netty框架中，这些问题都被巧妙地解决了</p>
<p>Netty是由JBOSS提供的一个开源的java网络编程框架，主要是对java的NIO包进行了再次封装。Netty比java原生的NIO包提供了更加强大、稳定的功能和易于使用的api。netty的作者是Trustin Lee，这是一个韩国人，他还开发了另外一个著名的网络编程框架，mina。两者在很多方面都十分相似，它们的线程模型也是基本一致。不过netty社区的活跃度要比mina高很多</p>
<p>Nettty实际上应用场景非常多，比如我们的Minecraft游戏服务器</p>
<p>学习了Netty框架后，说不定你也可以摸索到部分Minecraft插件&#x2F;模组开发的底层细节</p>
<p>当然除了游戏服务器之外，我们微服务之间的远程调用也可以使用Netty来完成，比如Dubbo的RPC框架，包括最新的SpringWebFlux框架，也抛弃了内嵌Tomcat而使用Netty作为通信框架。</p>
<p>首先需要导包：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.netty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>netty-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.0.Alpha2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="ByteBuf"><a href="#ByteBuf" class="headerlink" title="ByteBuf"></a>ByteBuf</h3><p>Netty并没有使用NIO提供的ByteBuffer来进行数据装载，而是自定义了一个ByteBuf类</p>
<p>那么这个类相比于NIO中的ByteBuffer有什么不同的呢？</p>
<ul>
<li>写操作完成后无需进行<code>flip()</code>翻转</li>
<li>具有比ByteBuffer更快的响应速度</li>
<li>动态扩容</li>
</ul>
<p>内部结构：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractByteBuf</span> <span class="keyword">extends</span> <span class="title class_">ByteBuf</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">int</span> readerIndex;   <span class="comment">//index被分为了读和写，是两个指针在同时工作</span></span><br><span class="line">    <span class="type">int</span> writerIndex;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> markedReaderIndex;    <span class="comment">//mark操作也分两种</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> markedWriterIndex;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxCapacity;    <span class="comment">//最大容量，没错，这玩意能动态扩容</span></span><br></pre></td></tr></table></figure>

<p>可以看到，读操作和写操作分别由两个指针在进行维护，每写入一次，<code>writeIndex</code>向后移动一位，每读取一次，也是<code>readerIndex</code>向后移动一位，当然<code>readerIndex</code>不能大于<code>writerIndex</code>，这样就不会像NIO中的ByteBufffer那样还需要进行翻转了</p>
<p><img src="/../images/Java-NIO-Netty/7.png" alt="ByteBuf"></p>
<p>其中<code>readerIndex</code>和<code>writerIndex</code>之间的部分就是可读的内容，而<code>writeIndex</code>之后到<code>capacity</code>都是可写的部分</p>
<p>实际应用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个初始容量为10的ByteBuf缓冲区，这里的Unpooled是用于快速生成ByteBuf的工具类</span></span><br><span class="line">    <span class="comment">// 至于为啥叫Unpooled是池化的意思，ByteBuf有池化和非池化两种，区别在于对内存的复用，我们之后再讨论</span></span><br><span class="line">    <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> Unpooled.buffer(<span class="number">10</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;初始状态：&quot;</span> + Arrays.toString(buf.array()));</span><br><span class="line">    buf.writeInt(-<span class="number">888888888</span>);   <span class="comment">// 写入一个Int数据</span></span><br><span class="line">    System.out.println(<span class="string">&quot;写入Int后：&quot;</span> + Arrays.toString(buf.array()));</span><br><span class="line">    buf.readShort();   <span class="comment">// 无需翻转，直接读取一个short数据出来</span></span><br><span class="line">    System.out.println(<span class="string">&quot;读取Short后：&quot;</span> + Arrays.toString(buf.array()));</span><br><span class="line">    buf.discardReadBytes();   <span class="comment">// 丢弃操作，会将当前的可读部分内容丢到最前面，并且读写指针向前移动丢弃的距离</span></span><br><span class="line">    System.out.println(<span class="string">&quot;丢弃之后：&quot;</span> + Arrays.toString(buf.array()));</span><br><span class="line">    buf.clear();    <span class="comment">// 清空操作，清空之后读写指针都归零</span></span><br><span class="line">    System.out.println(<span class="string">&quot;清空之后：&quot;</span> + Arrays.toString(buf.array()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过结合断点调试，可以观察指针的移动情况，更加清楚的认识ByteBuf的底层操作</p>
<p>划分操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//我们也可以将一个byte[]直接包装进缓冲区（和NIO是一样的）不过写指针的值一开始就跑到最后去了</span></span><br><span class="line">    <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> Unpooled.wrappedBuffer(<span class="string">&quot;abcdefg&quot;</span>.getBytes());</span><br><span class="line">    <span class="comment">//除了包装，也可以复制数据，copiedBuffer()会完完整整将数据拷贝到一个新的缓冲区中</span></span><br><span class="line">    buf.readByte();   <span class="comment">//读取一个字节</span></span><br><span class="line">    <span class="type">ByteBuf</span> <span class="variable">slice</span> <span class="operator">=</span> buf.slice();   <span class="comment">//现在读指针位于1，然后进行划分</span></span><br><span class="line"></span><br><span class="line">    System.out.println(slice.arrayOffset());   <span class="comment">//得到划分出来的ByteBuf的偏移地址</span></span><br><span class="line">    System.out.println(Arrays.toString(slice.array()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，划分也是根据当前读取的位置来进行的</p>
<p>我们继续来看它的另一个特性，动态扩容，比如我们申请一个容量为10的缓冲区：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> Unpooled.buffer(<span class="number">10</span>);    <span class="comment">// 容量只有10字节</span></span><br><span class="line">    System.out.println(buf.capacity());</span><br><span class="line">    <span class="comment">// 直接写一个字符串</span></span><br><span class="line">    buf.writeCharSequence(<span class="string">&quot;卢本伟牛逼！&quot;</span>, StandardCharsets.UTF_8);   <span class="comment">// 很明显这么多字已经超过10字节了</span></span><br><span class="line">    System.out.println(buf.capacity());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过测试我们发现，在写入一个超出当前容量的数据时，会进行动态扩容，扩容会从64开始，之后每次触发扩容都会*2，当然如果我们不希望它扩容，可以指定最大容量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//在生成时指定maxCapacity也为10</span></span><br><span class="line">    <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> Unpooled.buffer(<span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">    System.out.println(buf.capacity());</span><br><span class="line">    buf.writeCharSequence(<span class="string">&quot;卢本伟牛逼！&quot;</span>, StandardCharsets.UTF_8);</span><br><span class="line">    System.out.println(buf.capacity());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到无法进行扩容了：</p>
<p><img src="/../images/Java-NIO-Netty/8.png" alt="动态扩容"></p>
<p>接下来看缓冲区的三种实现模式：<strong>堆缓冲区、直接缓冲区、复合缓冲区</strong>模式</p>
<p><strong>堆缓冲区（数组实现）和直接缓冲区</strong>（堆外内存实现）不用多说，前面NIO中已经了解过了，创建一个直接缓冲区也很简单，直接调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> Unpooled.directBuffer(<span class="number">10</span>);</span><br><span class="line">    System.out.println(Arrays.toString(buf.array()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的不能直接拿到数组，因为底层压根不是数组实现的：</p>
<p><img src="/../images/Java-NIO-Netty/9.png" alt="直接缓冲区"></p>
<p><strong>符合缓冲区</strong>，复合缓冲区可以任意的拼接其他缓冲区：</p>
<p><img src="/../images/Java-NIO-Netty/10.png" alt="复合缓冲区"></p>
<p>这样，如果我们想要对两个缓冲区组合的内容进行操作，我们就不用再单独创建一个新的缓冲区了，而是直接将其进行拼接操作，相当于是作为多个缓冲区的视图</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个复合缓冲区</span></span><br><span class="line">    <span class="type">CompositeByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> Unpooled.compositeBuffer();</span><br><span class="line">    buf.addComponent(Unpooled.copiedBuffer(<span class="string">&quot;abc&quot;</span>.getBytes()));</span><br><span class="line">    buf.addComponent(Unpooled.copiedBuffer(<span class="string">&quot;def&quot;</span>.getBytes()));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; buf.capacity(); i++) &#123;</span><br><span class="line">        System.out.println((<span class="type">char</span>) buf.getByte(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过结果可以看到可以正常操作组合后的缓冲区</p>
<p><strong>池化缓冲区和非池化缓冲区的区别</strong></p>
<p>Unpooled工具类中具体是如何创建buffer的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Unpooled</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ByteBufAllocator ALLOC;  <span class="comment">//实际上内部是有一个ByteBufAllocator对象的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ByteOrder BIG_ENDIAN;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ByteOrder LITTLE_ENDIAN;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ByteBuf EMPTY_BUFFER;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ByteBuf <span class="title function_">buffer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ALLOC.heapBuffer();   <span class="comment">//缓冲区的创建操作实际上是依靠ByteBufAllocator来进行的</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &#123;   <span class="comment">//ALLOC在静态代码块中进行指定，实际上真正的实现类是UnpooledByteBufAllocator</span></span><br><span class="line">        ALLOC = UnpooledByteBufAllocator.DEFAULT;</span><br><span class="line">        BIG_ENDIAN = ByteOrder.BIG_ENDIAN;</span><br><span class="line">        LITTLE_ENDIAN = ByteOrder.LITTLE_ENDIAN;</span><br><span class="line">        EMPTY_BUFFER = ALLOC.buffer(<span class="number">0</span>, <span class="number">0</span>);   <span class="comment">//空缓冲区容量和最大容量都是0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> EMPTY_BUFFER <span class="keyword">instanceof</span> EmptyByteBuf : <span class="string">&quot;EMPTY_BUFFER must be an EmptyByteBuf.&quot;</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ByteBufAllocator，负责分配缓冲区的</p>
<p>他有两个具体的实现类：<code>UnpooledByteBufAllocator</code>和<code>PooledByteBufAllocator</code>，一个是非池化缓冲区生成器，还有一个是池化缓冲区生成器，那么池化缓冲区和非池化话冲去的区别是什么呢？</p>
<p>实际上池化缓冲区利用了池化思想，将缓冲区通过设置内存池来进行内存块复用，这样就不用频繁的进行内存的申请，尤其是在使用堆外内存的时候，避免多次重复通过底层<code>malloc()</code>函数系统调用申请内存造成的性能损失。Netty的内存管理主要借鉴<strong>Jemalloc</strong>内存分配策略</p>
<p>所以，由于是复用内存空间，举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ByteBufAllocator</span> <span class="variable">allocator</span> <span class="operator">=</span> PooledByteBufAllocator.DEFAULT;</span><br><span class="line">    <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> allocator.directBuffer(<span class="number">10</span>);   <span class="comment">//申请一个容量为10的直接缓冲区</span></span><br><span class="line">    buf.writeChar(<span class="string">&#x27;T&#x27;</span>);    <span class="comment">//随便操作操作</span></span><br><span class="line">    System.out.println(buf.readChar());</span><br><span class="line">    buf.release();    <span class="comment">//释放此缓冲区</span></span><br><span class="line"></span><br><span class="line">    <span class="type">ByteBuf</span> <span class="variable">buf2</span> <span class="operator">=</span> allocator.directBuffer(<span class="number">10</span>);   <span class="comment">//重新再申请一个同样大小的直接缓冲区</span></span><br><span class="line">    System.out.println(buf2 == buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在使用完成一个缓冲区之后，我们将其进行资源释放，当我们再次申请一个同样大小的缓冲区时，会直接得到之前已经申请好的缓冲区，所以，<code>PooledByteBufAllocator</code>实际上是将ByteBuf实例放入池中在进行复用</p>
<h3 id="Netty工作模型"><a href="#Netty工作模型" class="headerlink" title="Netty工作模型"></a>Netty工作模型</h3><p>Netty正是以主从Reactor多线程模型为基础，构建出一套高效的工作模型</p>
<p>大致工作模型如下：</p>
<p><img src="/../images/Java-NIO-Netty/13.png" alt="工作模型"></p>
<p>可以看到，和我们之前介绍的主从Reactor多线程模型非常类似：</p>
<p><img src="/../images/Java-NIO-Netty/12.png" alt="主从Reactor模型"></p>
<p>所有的客户端需要连接到主Reactor完成Accept操作后，其他的操作由从Reactor去完成，这里也是差不多的思想，但是进行了一些改进：</p>
<ul>
<li>Netty抽象出两组线程池<code>BoosGroup</code>和<code>WorkerGroup</code>，BossGroup专门负责接受客户端的连接，WorkerGroup专门负责读写，就像我们前面说的主从Reactor一样</li>
<li>无论是BossGroup还是WorkerGroup，都是使用EventLoop（事件循环，很多系统都采用了事件循环，比如前端框架Node.js，事件循环顾名思义，就是一个循环，不断地进行事件通知）来进行事件监听，整个Netty也是使用事件驱动来运作的，比如当客户端已经准备好读写、连接建立时，都会进行事件通知，说白了就像我们之前写NIO多路复用那样，只不过这里换成EventLoop而已，它已经帮助我们封装好了一些常用操作，而且我们可以自己添加一些额外的任务，如果有多个EventLoop，会存放在EventLoopGroup中，EventLoopGroup就是BossGroup和WorderGroup的具体实现</li>
<li>在BossGroup之后，会正常将SocketChannel绑定到WorkerGroup中的其中一个EventLoop上，进行后续的读写操作监听</li>
</ul>
<p>创建一个Netty服务器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 这里我们使用NioEventLoopGroup实现类即可，创建BossGroup和WorkerGroup</span></span><br><span class="line">    <span class="comment">// 当然还有EpollEventLoopGroup，但是仅支持Linux，这是Netty基于Linux底层Epoll单独编写的一套本地实现，没有使用NIO那套</span></span><br><span class="line">    <span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(), workerGroup = <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建服务端启动引导类</span></span><br><span class="line">    <span class="type">ServerBootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">    <span class="comment">// 可链式，就很棒</span></span><br><span class="line">    bootstrap</span><br><span class="line">        .group(bossGroup, workerGroup)   <span class="comment">// 指定事件循环组</span></span><br><span class="line">        .channel(NioServerSocketChannel.class)   <span class="comment">// 指定为NIO的ServerSocketChannel</span></span><br><span class="line">        .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;   <span class="comment">// 注意，这里的SocketChannel不是我们NIO里面的，是Netty的</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel channel)</span> &#123;</span><br><span class="line">                <span class="comment">// 获取流水线，当我们需要处理客户端的数据时，实际上是像流水线一样在处理，这个流水线上可以有很多Handler</span></span><br><span class="line">                channel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() &#123;   <span class="comment">// 添加一个Handler，这里使用ChannelInboundHandlerAdapter</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> &#123;  <span class="comment">// ctx是上下文，msg是收到的消息，默认以ByteBuf形式（也可以是其他形式，后面再说）</span></span><br><span class="line">                        <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> (ByteBuf) msg;   <span class="comment">// 类型转换一下</span></span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &gt;&gt; 接收到客户端发送的数据：&quot;</span> + buf.toString(StandardCharsets.UTF_8));</span><br><span class="line">                        <span class="comment">// 通过上下文可以直接发送数据回去，注意要writeAndFlush才能让客户端立即收到</span></span><br><span class="line">                        ctx.writeAndFlush(Unpooled.wrappedBuffer(<span class="string">&quot;已收到！&quot;</span>.getBytes()));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="comment">// 最后绑定端口，启动</span></span><br><span class="line">    bootstrap.bind(<span class="number">8080</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着编写一个客户端，客户端暂时使用之前的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个新的SocketChannel，一会通过通道进行通信</span></span><br><span class="line">    <span class="keyword">try</span> (<span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> SocketChannel.open(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>)); <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in)) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;已连接到服务端！&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;   <span class="comment">// 咱给它套个无限循环，这样就能一直发消息了</span></span><br><span class="line">            System.out.println(<span class="string">&quot;请输入要发送给服务端的内容：&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">            <span class="keyword">if</span> (text.isEmpty()) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 直接向通道中写入数据，真舒服</span></span><br><span class="line">            channel.write(ByteBuffer.wrap(text.getBytes()));</span><br><span class="line">            System.out.println(<span class="string">&quot;已发送！&quot;</span>);</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">            channel.read(buffer);   <span class="comment">// 直接从通道中读取数据</span></span><br><span class="line">            buffer.flip();</span><br><span class="line">            System.out.println(<span class="string">&quot;收到服务器返回：&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(buffer.array(), <span class="number">0</span>, buffer.remaining()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过通道可以正常的收发数据，这样就成功建立了一个Netty服务器</p>
<h3 id="Channel详解"><a href="#Channel详解" class="headerlink" title="Channel详解"></a>Channel详解</h3><p>在学习NIO的过程中，我们就已经接触到了Channel了，我们可以通过通道来进行数据的传输，并且通道支持双向传输</p>
<p>而在Netty中，也有对应的Channel类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Channel</span> <span class="keyword">extends</span> <span class="title class_">AttributeMap</span>, ChannelOutboundInvoker, Comparable&lt;Channel&gt; &#123;</span><br><span class="line">    ChannelId <span class="title function_">id</span><span class="params">()</span>;   <span class="comment">//通道ID</span></span><br><span class="line">    EventLoop <span class="title function_">eventLoop</span><span class="params">()</span>;   <span class="comment">//获取此通道所属的EventLoop，因为一个Channel在它的生命周期内只能注册到一个EventLoop中</span></span><br><span class="line">    Channel <span class="title function_">parent</span><span class="params">()</span>;   <span class="comment">//Channel是具有层级关系的，这里是返回父Channel</span></span><br><span class="line">    ChannelConfig <span class="title function_">config</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isOpen</span><span class="params">()</span>;   <span class="comment">//通道当前的相关状态</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isRegistered</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isActive</span><span class="params">()</span>;</span><br><span class="line">    ChannelMetadata <span class="title function_">metadata</span><span class="params">()</span>;   <span class="comment">//通道相关信息</span></span><br><span class="line">    SocketAddress <span class="title function_">localAddress</span><span class="params">()</span>; </span><br><span class="line">    SocketAddress <span class="title function_">remoteAddress</span><span class="params">()</span>;</span><br><span class="line">    ChannelFuture <span class="title function_">closeFuture</span><span class="params">()</span>;  <span class="comment">//关闭通道，但是会用到ChannelFuture，后面说</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isWritable</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">long</span> <span class="title function_">bytesBeforeUnwritable</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">long</span> <span class="title function_">bytesBeforeWritable</span><span class="params">()</span>;</span><br><span class="line">    Unsafe <span class="title function_">unsafe</span><span class="params">()</span>;</span><br><span class="line">    ChannelPipeline <span class="title function_">pipeline</span><span class="params">()</span>;   <span class="comment">//流水线，之后也会说</span></span><br><span class="line">    ByteBufAllocator <span class="title function_">alloc</span><span class="params">()</span>;   <span class="comment">//可以直接从Channel拿到ByteBufAllocator的实例，来分配ByteBuf</span></span><br><span class="line">    Channel <span class="title function_">read</span><span class="params">()</span>;</span><br><span class="line">    Channel <span class="title function_">flush</span><span class="params">()</span>;   <span class="comment">//刷新，基操</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到Channel相比NIO功能就多得多了。Netty中的Channel主要特点如下：</p>
<ul>
<li>所有的IO操作都是异步的，并不是在当前线程同步运行，方法调用之后就直接返回了，那怎么获取操作的结果呢？还记得我们在前面JUC篇教程中学习的Future吗，没错，这里的ChannelFuture也是干这事的</li>
</ul>
<p>我们可以来看一下Channel接口的父接口ChannelOutboundIncoker接口，这里面定义了大量的I&#x2F;O操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ChannelOutboundInvoker</span> &#123;   <span class="comment">//通道出站调用（包含大量的网络出站操作，比如写）</span></span><br><span class="line">    ChannelFuture <span class="title function_">bind</span><span class="params">(SocketAddress var1)</span>;  <span class="comment">//Socket绑定、连接、断开、关闭等操作</span></span><br><span class="line">    ChannelFuture <span class="title function_">connect</span><span class="params">(SocketAddress var1)</span>;</span><br><span class="line">    ChannelFuture <span class="title function_">connect</span><span class="params">(SocketAddress var1, SocketAddress var2)</span>;</span><br><span class="line">    ChannelFuture <span class="title function_">disconnect</span><span class="params">()</span>;</span><br><span class="line">    ChannelFuture <span class="title function_">close</span><span class="params">()</span>;</span><br><span class="line">    ChannelFuture <span class="title function_">deregister</span><span class="params">()</span>;</span><br><span class="line">    ChannelFuture <span class="title function_">bind</span><span class="params">(SocketAddress var1, ChannelPromise var2)</span>;    <span class="comment">//下面这一系列还有附带ChannelPromise的，ChannelPromise我们后面再说，其实就是ChannelFuture的增强版</span></span><br><span class="line">    ChannelFuture <span class="title function_">connect</span><span class="params">(SocketAddress var1, ChannelPromise var2)</span>;</span><br><span class="line">    ChannelFuture <span class="title function_">connect</span><span class="params">(SocketAddress var1, SocketAddress var2, ChannelPromise var3)</span>;</span><br><span class="line">    ChannelFuture <span class="title function_">disconnect</span><span class="params">(ChannelPromise var1)</span>;</span><br><span class="line">    ChannelFuture <span class="title function_">close</span><span class="params">(ChannelPromise var1)</span>;</span><br><span class="line">    ChannelFuture <span class="title function_">deregister</span><span class="params">(ChannelPromise var1)</span>;</span><br><span class="line">    ChannelOutboundInvoker <span class="title function_">read</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    ChannelFuture <span class="title function_">write</span><span class="params">(Object var1)</span>;    <span class="comment">//可以看到这些常见的写操作，都是返回的ChannelFuture，而不是直接给结果</span></span><br><span class="line">    ChannelFuture <span class="title function_">write</span><span class="params">(Object var1, ChannelPromise var2)</span>;</span><br><span class="line">    ChannelOutboundInvoker <span class="title function_">flush</span><span class="params">()</span>;</span><br><span class="line">    ChannelFuture <span class="title function_">writeAndFlush</span><span class="params">(Object var1, ChannelPromise var2)</span>;</span><br><span class="line">    ChannelFuture <span class="title function_">writeAndFlush</span><span class="params">(Object var1)</span>;</span><br><span class="line"></span><br><span class="line">    ChannelPromise <span class="title function_">newPromise</span><span class="params">()</span>;   <span class="comment">//其他的暂时不提</span></span><br><span class="line">    ChannelProgressivePromise <span class="title function_">newProgressivePromise</span><span class="params">()</span>;</span><br><span class="line">    ChannelFuture <span class="title function_">newSucceededFuture</span><span class="params">()</span>;</span><br><span class="line">    ChannelFuture <span class="title function_">newFailedFuture</span><span class="params">(Throwable var1)</span>;</span><br><span class="line">    ChannelPromise <span class="title function_">voidPromise</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然它还实现了AttributeMap接口，其实有点类似于Session那种感觉，我们可以添加一些属性之类的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AttributeMap</span> &#123;</span><br><span class="line">    &lt;T&gt; Attribute&lt;T&gt; <span class="title function_">attr</span><span class="params">(AttributeKey&lt;T&gt; var1)</span>;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; <span class="type">boolean</span> <span class="title function_">hasAttr</span><span class="params">(AttributeKey&lt;T&gt; var1)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们连接了Netty底层的Channel之后，我们接着来看ChannelHandler，既然现在有了通道，那么怎么进行操作呢？我们可以将需要处理的事情放在ChannelHandler中，ChannelHandler充当了所有入站和出站数据的应用程序逻辑的容器，实际上就是我们之前的Reactor模式中的Handler，全靠它来处理读写操作</p>
<p>不过这里不仅仅是一个简单的ChannelHandler在进行处理，而是一整套流水线，我们之后会介绍ChannelPipeline</p>
<p>比如我们上面就是使用了ChannellnboundHandlerAdapter抽象类，它是ChannelInboundHandler接口的实现，用于处理入站数据，可以看到我们实际上就是通过重写对应的方法来进行处理，这些方法会在合适的时间被调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">channel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> &#123;  </span><br><span class="line">        <span class="comment">//ctx是上下文，msg是收到的消息，以ByteBuf形式</span></span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> (ByteBuf) msg;   <span class="comment">//类型转换一下</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot; &gt;&gt; 接收到客户端发送的数据：&quot;</span>+buf.toString(StandardCharsets.UTF_8));</span><br><span class="line">        <span class="comment">//通过上下文可以直接发送数据回去，注意要writeAndFlush才能让客户端立即收到</span></span><br><span class="line">        ctx.writeAndFlush(Unpooled.wrappedBuffer(<span class="string">&quot;已收到！&quot;</span>.getBytes()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>





































</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="http://example.com">John Doe</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="http://example.com/2025/04/18/Java-NIO-Netty/">http://example.com/2025/04/18/Java-NIO-Netty/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/04/28/JWT/" title="JWT"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Previous</div><div class="prev_info">JWT</div></div></a></div><div class="next-post pull-right"><a href="/2025/03/19/JVM/" title="JVM"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Next</div><div class="next_info">JVM</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">John Doe</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#NIO%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">NIO基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">1.1.</span> <span class="toc-text">缓冲区</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Buffer%E7%B1%BB%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.1.1.</span> <span class="toc-text">Buffer类及其实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA%E5%86%99%E6%93%8D%E4%BD%9C"><span class="toc-number">1.1.2.</span> <span class="toc-text">缓冲区写操作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Netty%E6%A1%86%E6%9E%B6"><span class="toc-number">2.</span> <span class="toc-text">Netty框架</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#NIO%E6%A1%86%E6%9E%B6%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">2.1.</span> <span class="toc-text">NIO框架存在的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%85%B3%E9%97%AD%E5%AF%BC%E8%87%B4%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A9%BA%E8%BD%AE%E8%AF%A2"><span class="toc-number">2.1.1.</span> <span class="toc-text">客户端关闭导致服务器空轮询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B2%98%E5%8C%85-%E6%8B%86%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">2.1.2.</span> <span class="toc-text">粘包&#x2F;拆包问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B5%B0%E8%BF%9BNetty%E6%A1%86%E6%9E%B6"><span class="toc-number">2.2.</span> <span class="toc-text">走进Netty框架</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ByteBuf"><span class="toc-number">2.2.1.</span> <span class="toc-text">ByteBuf</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Netty%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.2.2.</span> <span class="toc-text">Netty工作模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Channel%E8%AF%A6%E8%A7%A3"><span class="toc-number">2.2.3.</span> <span class="toc-text">Channel详解</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/15/CompletableFuture%E5%AD%A6%E4%B9%A0/" title="CompletableFuture学习">CompletableFuture学习</a><time datetime="2025-05-15T08:46:27.000Z" title="Created 2025-05-15 16:46:27">2025-05-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/02/SpringSecurity/" title="SpringSecurity">SpringSecurity</a><time datetime="2025-05-02T01:12:10.000Z" title="Created 2025-05-02 09:12:10">2025-05-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/28/JWT/" title="JWT">JWT</a><time datetime="2025-04-28T14:43:02.000Z" title="Created 2025-04-28 22:43:02">2025-04-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/18/Java-NIO-Netty/" title="Java NIO Netty">Java NIO Netty</a><time datetime="2025-04-18T03:43:38.000Z" title="Created 2025-04-18 11:43:38">2025-04-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/19/JVM/" title="JVM">JVM</a><time datetime="2025-03-19T08:33:04.000Z" title="Created 2025-03-19 16:33:04">2025-03-19</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By John Doe</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>